/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 2001 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Axis" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.axis.encoding.ser ;

import java.io.ByteArrayOutputStream;

import org.apache.axis.utils.JavaUtils;

import java.lang.reflect.Method;
import java.beans.IntrospectionException;
import org.apache.log4j.Category;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;

/**
 * This class is essentially a copy of the PropertyDescriptor information, except
 * that the values in it can be modified.
 * @author Rich Scheuerle <scheu@us.ibm.com>
 **/
class BeanPropertyDescriptor {
    static Category category =
            Category.getInstance(BeanPropertyDescriptor.class.getName());

    private String name;
    private Method getter;
    private Method setter;
    
    public BeanPropertyDescriptor(String _name, Method _getter, Method _setter) {
        name = _name;
        getter = _getter;
        setter = _setter;
    }
    public Method getReadMethod()  { return getter; }
    public Method getWriteMethod() { return setter; }
    public String getName() {return name;}
    public Class getType() {return getter.getReturnType(); }

    /** 
     * This method attempts to sort the property descriptors to match the 
     * order defined in the class.  This is necessary to support 
     * xsd:sequence processing, which means that the serialized order of 
     * properties must match the xml element order.  (This method assumes that the
     * order of the set methods matches the xml element order...the emitter 
     * will always order the set methods according to the xml order.)
     *
     * This routine also looks for set(i, type) and get(i) methods and adjusts the 
     * property to use these methods instead.  These methods are generated by the
     * emitter for "collection" of properties (i.e. maxOccurs="unbounded" on an element).
     * JAX-RPC is silent on this issue, but web services depend on this kind of behaviour.
     * The method signatures were chosen to match bean indexed properties.
     */
    static BeanPropertyDescriptor[] processPropertyDescriptors(
                  PropertyDescriptor[] rawPd, Class cls) {
        BeanPropertyDescriptor[] myPd = new BeanPropertyDescriptor[rawPd.length];

        for (int i=0; i < rawPd.length; i++) {
            myPd[i] = new BeanPropertyDescriptor(rawPd[i].getName(), 
                                               rawPd[i].getReadMethod(), 
                                               rawPd[i].getWriteMethod());
        }
        
        try {
            // Create a new pd array and index into the array
            int index = 0;

            // Build a new pd array
            // defined by the order of the get methods. 
            BeanPropertyDescriptor[] newPd = new BeanPropertyDescriptor[rawPd.length];
            Method[] methods = cls.getMethods();
            for (int i=0; i < methods.length; i++) {
                Method method = methods[i];
                if (method.getName().startsWith("set")) {
                    boolean found = false;
                    for (int j=0; j < myPd.length && !found; j++) {
                        if (myPd[j].getWriteMethod() != null &&
                            myPd[j].getWriteMethod().equals(method)) {
                            found = true;
                            newPd[index] = myPd[j];
                            index++;
                        }
                    }
                }
            }
            // Now if there are any additional property descriptors, add them to the end.
            if (index < myPd.length) {
                for (int m=0; m < myPd.length && index < myPd.length; m++) {
                    boolean found = false;           
                    for (int n=0; n < index && !found; n++) {
                        found = (myPd[m]==newPd[n]);
                    }
                    if (!found) {
                        newPd[index] = myPd[m];
                        index++;
                    }
                }
            }
            // If newPd has same number of elements as myPd, use newPd.
            if (index == myPd.length) {
                myPd = newPd;
            }

            // Get the methods of the class and look for the special set and
            // get methods for property "collections"
            for (int i=0; i < methods.length; i++) {
                if (methods[i].getName().startsWith("set") && 
                    methods[i].getParameterTypes().length == 2) {
                    for (int j=0; j < methods.length; j++) {
                        if ((methods[j].getName().startsWith("get") ||
                             methods[j].getName().startsWith("is")) &&
                            methods[j].getParameterTypes().length == 1 &&
                            methods[j].getReturnType() == methods[i].getParameterTypes()[1] &&
                            methods[j].getParameterTypes()[0] == int.class &&
                            methods[i].getParameterTypes()[0] == int.class) {
                            for (int k=0; k < myPd.length; k++) {
                                if (myPd[k].getReadMethod() != null &&
                                    myPd[k].getWriteMethod() != null &&
                                    myPd[k].getReadMethod().getName().equals(methods[j].getName()) &&
                                    myPd[k].getWriteMethod().getName().equals(methods[i].getName())) {
                                    myPd[k] = new BeanPropertyDescriptor(myPd[k].getName(),
                                                                       methods[j],
                                                                       methods[i]);
                                }
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            // Don't process Property Descriptors if problems occur
            return myPd;
        }
        return myPd;
    }
}

