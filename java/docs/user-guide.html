<!-- saved from url=(0022)http://internet.e-mail -->
<html>
<head>
<title>Axis User's Guide</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
.example { background:#ccccff }
.xml { background:#eeeeee }
body {  font-family: Verdana, Arial, Helvetica, sans-serif; margin-left: 40px}
h2 {  text-decoration: underline; background-color: #DCE1FF; background-position: left; margin-left: -30px}
h3 {  margin-left: -10px}
h1 {  margin-left: -30px}
-->
</style>
</head>

<body bgcolor="#ffffff" text="#000000">
<h1 align="center"><IMG height=96 src="axis.jpg" width=176></h1>
<h1>Axis User's Guide</h1>
<p><i>Alpha 3 Version</i></p>
<h3>Table of Contents</h3>
<p><A href="#Introduction">Introduction</a><br>
  <A href="#Installation">Installing Axis</a><br>
  <A href="#Architecture">Axis Architecture - a Brief Primer</a><br>
  <A href="#ConsumingServices">Consuming Web Services with Axis</a><br>
  <A href="#PublishingServices">Publishing Web Services with Axis</a><br>
  <A href="#DataMapping">XML &lt;-&gt; Java Data Mapping in Axis<br>
  </a> <A href="#WSDL">Using WSDL with Axis</a><br>
  <br>
  <A href="#DeploymentReference">Deployment Reference</a><br>
  <A href="#Glossary">Glossary</a></p>
<h2><a name="Introduction"></a>Introduction</h2>
<p>Welcome to Axis, the third generation of Apache SOAP! This is the <b>alpha 
  3 </b> version. Please note that Axis is a work in progress, and although the 
  basic functionality is there, there are still a lot of unfinished areas and 
  rough edges. That said, we're very psyched about the package so far and would 
  love to get your take on how we can make it better. </p>
<h3>What is SOAP?</h3>
<p>SOAP is an XML<i>-</i>based communitcation protocol and encoding format for 
  inter-application communication. Originally conceived by Microsoft and Userland 
  software, it has evolved through several generations and the current spec, <a href="http://w3.org/TR/soap">SOAP 
  1.1</a>, is fast growing in popularity and usage. The W3C's XML Protocol working 
  group is in the process of turning SOAP into a true open standard, and as of 
  this writing has released a working draft of SOAP 1.2, which cleans up some 
  of the more confusing areas of the 1.1 spec.</p>
<p>SOAP is widely viewed as the backbone to a new generation of cross-platform 
  cross-language distributed computing applications, termed Web Services.</p>
<h3>What is Axis?</h3>
<p>Apache SOAP began at IBM as "SOAP4J" and then became Apache SOAP version 2. 
  The committers on the v2 project began some conversations in late 2000 about 
  making the engine much more flexible, configurable, and able to handle both 
  SOAP and the upcoming XML Protocol specification from the W3C. </p>
<p>After a little while, it became clear that a ground-up rearchitecture was the 
  way to go. Several of the v2 committers proposed very similar designs, all based 
  around configurable "chains" of message "handlers" which would implement small 
  bits of functionality in a very flexible and composable manner. Axis is the 
  result of months of continued discussion and coding effort in this direction. 
  Some of the key Axis features include the following:</p>
<ul>
  <li> <b>Speed.</b> Axis uses SAX (event-based) parsing to acheive significantly 
    greater speed than earlier versions of Apache SOAP. 
  <li><b>Flexibility.</b> The Axis architecture gives the developer complete freedom 
    to insert extensions into the engine for custom header processing, system 
    management, or anything else you can imagine. 
  <li><b>Component-oriented deployment.</b> You can easily define reusable networks 
    of Handlers to implement common patterns of processing for your applications, 
    or to distribute to partners. 
  <li><b>Transport framework.</b> We have a clean and simple abstraction for designing 
    transports (i.e. senders and listeners for SOAP over various protocols such 
    as SMTP, FTP, message-oriented middleware, etc), and the core of the engine 
    is completely transport-independent. 
</ul>
<p>We hope you enjoy using Axis. Please note that this is an open-source effort 
  - if you feel the code could use some new features or fixes, please get involved 
  and lend a hand! The Axis developer community welcomes your participation.</p>
<h4><b>Let us know what you think!</b></h4>
<p>Please send feedback about the package to "<A href="mailto:axis-user@xml.apache.org">axis-user@xml.apache.org</a>". 
  Also, Axis is regsitered in <a href="http://nagoya.apache.org/bugzilla">bugzilla</a>, 
  the Apache bug tracking and feature-request database.</p>
<h3>What's in this release?</h3>
<p>This release includes the following features:</p>
<ul>
  <li>SOAP 1.1 compliant engine 
  <li>Flexible configuration / deployment system 
  <li>Support for "drop-in" deployment of SOAP services (JWS) 
  <li>Support for all basic types, and a type mapping system for defining new 
    serializers/deserializers 
  <li>Automatic serialization/deserialization of Java Beans 
  <li>Automatic two-way conversions between Java "List" collections and SOAP Arrays 
  <li>Providers for RPC and message based SOAP services 
  <li>Automatic WSDL generation from deployed services
  <li>Wsdl2java tool for building Java proxies and skeletons from WSDL documents
  <li>Preliminary security extensions, which can integrate with Servlet 2.2 security/roles
  <li>An EJB provider for accessing EJB's as Web Services
  <li>HTTP servlet-based transport 
  <li>Standalone version of the server (with HTTP support) 
  <li>Examples, including a client and server for the soapbuilders community interoperability 
    tests</li>
</ul>
<h3>What's missing?</h3>
<ul>
  <li>Support for the SOAP with Attachments specification 
  <li>Supprt for multi-dimensional arrays 
  <li>Support for the SOAP actor attribute 
  <li>Support for generating complex type definitions in WSDL 
</ul>
<p>All of these items are on the list for the final release.</p>
<h2><a name="Installation"></a>Installing Axis and Using this Guide</h2>
<p>See the <a href="install.html">Axis Installation Guide</a> for instructions 
  on installing Axis as a web application on your J2EE server. </p>
<p>Before running the examples in this guide, you'll need to make sure that axis.jar 
  is in your classpath. You should find it in the build/lib directory of the distribution.</p>
<h2><a name="Architecture"></a>Axis Architecture - a Brief Primer</h2>
<p>(Skip this section if you want to dive right in - in many cases using the basic 
  features of Axis requires zero knowledge of these topics.)</p>
<p>Axis consists of several subsystems working together. In this section we'll 
  give you an overview of how the package works, but for more details please see 
  the Axis Architecture Guide, a separate document.</p>
<h3>Handlers and the Message Path in Axis</h3>
<p>Put simply, Axis is all about processing Messages. When the central Axis processing 
  logic runs, the </p>
<p>There are two basic ways which Axis is invoked:</p>
<ol>
  <li>As a <b>server</b>, a <b>Transport Listener</b> will create a MessageContext 
    and invoke the Axis processing framework.</li>
  <li>As a <b>client</b>, application code (aided in most cases by the client 
    programming model of Axis) will generate a MessageContext and invoke the Axis 
    processing framework.</li>
</ol>
<p>In either case, the Axis framework's job is simply to pass the resulting MessageContext 
  through a configurable set of Handlers, each of which has an opportunity to 
  do whatever it is designed to do with the MessageContext.</p>
<h3>From XML to Objects and Back Again - Parsing and Encoding</h3>
<p>SOAP is an XML protocol, and as such...</p>
<h4>The Axis SAX Framework</h4>
<p>Central classes include DeserializationContext, </p>
<h2><a name="ConsumingServices"></a>Consuming Web Services with Axis</h2>
<h3>Basics - Getting Started</h3>
<p>Let's take a look at an example Web Service client that will call the <b>echoString</b> 
  method on the public Axis server at Apache.</p>
<div class="example">
<pre>
1   import org.apache.axis.client.Call;
2   import org.apache.axis.client.Service;
3   
4   public class TestClient
5   {
6      public static void main(String [] args) {
7          try {
8              String endpoint =
9                       "http://nagoya.apache.org:5049/axis/servlet/AxisServlet";
10  
11             Service  service = new Service();
12             Call     call    = (Call) service.createCall();
13  
14             call.setTargetEndpointAddress( new java.net.URL(endpoint) );
15             call.setOperationName( "echoString" );
16             call.setProperty( Call.NAMESPACE, "http://soapinterop.org/" );
17  
18             String ret = (String) call.invoke( new Object[] { "Hello!" } );
19  
20             System.out.println("Sent 'Hello!', got '" + ret + "'");
21         } catch (Exception e) {
22             System.err.println(e.toString());
23         }
24     }
25  }
</pre>
</div>
<p>(You'll find this file in <a href="../samples/userguide/example1/TestClient.java">samples/userguide/example1/TestClient.java</a>)</p>
<p>Assuming you have a network connection active, this program can be run as follows:</p>
<pre>% java samples.userguide.example1.TestClient
Sent 'Hello!', got 'Hello!'
% </pre>
<p>
  So what's happening here? On lines 11 and 12 we create new Service and Call
  objects.  These are the standard JAX-RPC objects that are used to store
  metadata about the service to invoke.  On line 14, we set up our endpoint 
  URL - this is the destination for our SOAP message.  On line 15 we define
  the operation (method) name of the Web Service. Line 16 defines the 
  namespace to use on the Body of the SOAP message.  And on line 18 we 
  actually invoke the desired service, passing in an array of parameters - 
  in this case just one String.
  
<p>You can see what happens to the arguments by looking at the SOAP request that 
  goes out on the wire (look at the colored sections, and notice they match the 
  values in the call above):</p>
  <div class="xml">
  <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;SOAP-ENV:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;SOAP-ENV:Body&gt;
    &lt;ns1:<font color="#993333"><b>echoString</b></font> xmlns:ns1="<font color="#009933"><b>http://soapinterop.org/</b></font>"&gt;
      &lt;arg0 xsi:type="xsd:string"&gt;<b><font color="#cc00cc">Hello!</font></b>&lt;/arg0&gt;
    &lt;/ns1:echoString&gt;
  &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
</pre>
  <div align="center"> </div>
</div>
<p>The String argument is automatically serialized into XML, and the server responds 
  with an identical String, which we deserialize and print.</p>
<p><i>Note: to actually watch the XML flowing back and forth between a SOAP client 
  and server, you can use the included tcpmon tool. See the <a href="#tcpmon">appendix</a> 
  for an overview.</i></p>
<h3>Naming Parameters</h3>
<p>In the above example, the parameters are in the order in which we sent them, 
  but since we only passed the objects themselves, Axis automatically named the 
  XML-encoded arguments in the SOAP message "arg0", "arg1", etc. If you want to 
  change this, it's easy! Before calling <code>invoke()</code> you need to call 
  <code>addParameter</code> for each parameter, like so:
<div class="example"><pre>
  call.addParameter("testParam", 
                    org.apache.axis.encoding.XMLType.XSD_STRING,
                    Call.PARAM_MODE_IN);
</pre></div><p>

This will assign the name <b>testParam</b> to the 1st (and only) parameter
on the invoke call.  This will also define the type of the parameter 
(<code>org.apache.axis.encoding.XMLType.XSD_STRING</code>) and whether it is 
an input, output or inout parameter - in this case its an input parameter.
Now when you run the program you'll get a message that looks like this: 
<div class="xml">
  <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;SOAP-ENV:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;SOAP-ENV:Body&gt;
    &lt;ns1:echoString xmlns:ns1="http://soapinterop.org/"&gt;
      &lt;<font color="#cc00cc">testParam</font> xsi:type="xsd:string"&gt;Hello!&lt;/<font color="#cc00cc">testParam</font>&gt;
    &lt;/ns1:echoString&gt;
  &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;</pre>
  
</div>
<p>Note that the param is now named "testParam" as expected.</p>
<h3>Interoperating with &quot;untyped&quot; servers</h3>
<p>In the above examples, we've been casting the return type of invoke(), which 
  is Object, to the appropriate &quot;real&quot; type - for instance, we know 
  that the echoString method returns a String, so we expect to get one back from 
  client.invoke(). Let's take a moment and investigate how this happens, which 
  sheds light on a potential problem (to which, of course, we have a solution 
  - so don't fret :)).</p>
<p>Here's what a typical response might look like to the echoString method: </p>
<pre><div class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;SOAP-ENV:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;SOAP-ENV:Body&gt;
    &lt;ns1:echoStringResponse xmlns:ns1="http://soapinterop.org/"&gt;
      &lt;result <font color="#FF0000">xsi:type="xsd:string"</font>&gt;Hello!&lt;/result&gt;
    &lt;/ns1:echoStringResponse&gt;
  &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;</div></pre>
<p>Take a look at the section which we've highlighted in red - that attribute 
  is a schema <b>type declaration</b>, which Axis uses to figure out that the 
  contents of that element are, in this case, deserializable into a Java String 
  object. Many toolkits put this kind of explicit typing information in the XML 
  to make the message &quot;self-describing&quot;. On the other hand, some toolkits 
  return responses that look like this:</p>
<pre><div class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;SOAP-ENV:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;SOAP-ENV:Body&gt;
    &lt;ns1:echoStringResponse xmlns:ns1="http://soapinterop.org/"&gt;
      &lt;result&gt;Hello, I'm a string!&lt;/result&gt;
    &lt;/ns1:echoStringResponse&gt;
  &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;</div></pre>
<p>There's no type in the message, so how do we know what Java object we should 
  deserialize the &lt;result&gt; element into? The answer is <b>metadata</b> - 
  data about data. In this case, we need a <b>description</b> of the service that 
  tells us what to expect as the return type. Here's how to do it on the client 
  side in Axis:</p>
<div class="example">
  <pre>  call.setReturnType( org.apache.axis.encoding.XMLType.XSD_STRING ); </pre>
</div>
<p>
  This method will tell the Axis client that if the return element is not typed
  then it should act as if the return value has an xsi:type attribute set to
  the predefined SOAP String type.
  (You can see an example of this in action in the interop echo-test 
  client - samples/echo/TestClient.java.)</p>
<p>OK - so now you know the basics of accessing SOAP services as a client. But 
  how do you publish your own services?</p>
<h2><a name="PublishingServices"></a>Publishing Web Services with Axis</h2>
<p>Let's say we have a simple class like the following:</p>
<pre class="example">public class Calculator {
  public int add(int i1, int i2)
  {
    return i1 + i2; 
  }
  
  public int subtract(int i1, int i2)
  {
    return i1 - i2;
  }
} 
</pre>
<p>(You'll find this very class in <a href="../samples/userguide/example2/Calculator.java">samples/userguide/example2/Calculator.java</a>.)</p>
<p>How do we go about making this class available via SOAP? There are a couple 
  of answers to that question, but we'll start with the easiest way Axis provides 
  to do this, which takes almost no effort at all!</p>
<h3>JWS (Java Web Service) Files - Instant Deployment</h3>
<p>OK, here's step 1 : copy the above .java file into your webapp directory, and 
  rename it "Calculator.jws". So you might do something like this:</p>
<pre>% copy Calculator.java <i><font color="#0000FF">&lt;your-webapp-root&gt;</font></i>/axis/Calculator.jws</pre>
<p>Now for step 2... hm, wait a minute. You're done! You should now be able to 
  access the service at the following URL (assuming your Axis web application 
  is on port 8080):</p>
<p><a href="http://localhost:8080/axis/Calculator.jws">http://localhost:8080/axis/Calculator.jws</a> 
</p>
<p>Axis automatically locates the file, compiles the class, and converts SOAP 
  calls correctly into Java invocations of your service class. Try it out - there's 
  a calculator client in samples/userguide/example2/CalcClient.java, which you 
  can use like this:</p>
<pre>% javac CalcClient.java
% java CalcClient -p8080 add 2 5
Got result : 7
% java CalcClient -p8080 subtract 10 9
Got result : 1
% </pre>
(note that you may need to replace the &quot;-p8080&quot; with whatever port your 
J2EE server is running on) 
<h3>Custom Deployment - Introducing WSDD</h3>
<p>JWS files are great quick ways to get your classes out there as Web Services, 
  but they're not always the best choice. For one thing, you need the source code 
  - there might be times when you want to expose a pre-existing class on your 
  system without source. Also, the amount of configuration you can do as to how 
  the service gets accessed is pretty limited - you can't specify custom type 
  mappings, or control which Handlers get invoked when people are using your service.</p>
<h4><a name="descriptors"></a>Deploying via descriptors</h4>
To really use the flexibility available to you in Axis, you should get familiar 
with the Axis <b>Web Service Deployment Descriptor (WSDD)</b> format. A deployment 
descriptor contains a bunch of things you want to "deploy" into Axis - i.e. make 
available to the Axis engine. The most common thing to deploy is a Web Service, 
so let's start by taking a look at a deployment descriptor for a basic service 
(this file is samples/userguide/example3/deploy.xml): 
<div class="example"> 
  <pre>&lt;deployment xmlns=&quot;http://xml.apache.org/axis/wsdd/&quot;
            xmlns:java=&quot;http://xml.apache.org/axis/wsdd/providers/java&quot;&gt;
 &lt;service name="MyService" provider=&quot;java:RPC&quot;&gt;
  &lt;parameter name="className" value="samples.userguide.example3.MyService"/&gt;
  &lt;parameter name="methodName" value="*"/&gt;
 &lt;/service&gt;
&lt;/deployment&gt;</pre>
</div>

<p>Pretty simple, really - the outermost element tells the engine that this is 
  a WSDD deployment, and defines the &quot;java&quot; namespace. Then the service 
  element actually defines the service for us. If you remember from the architecture 
  overview, a service is a <b>targeted chain</b>, which means it may have any/all 
  of: a request Handler, a pivot Handler (which for a service is called a &quot;provider&quot;), 
  and a response Handler. In this case, our provider is &quot;java:RPC&quot;, 
  which is predefined to indicate a Java RPC service.</p>
<p>We need to tell the RPCDispatcher that it should instantiate and call the correct 
  class (e.g. samples.userguide.example3.MyService), and we do so by including 
  a &lt;parameter&gt; tag, giving the service one parameter to configure the class 
  name, and another to tell the engine that any public method on that class may 
  be called via SOAP (that's what the "*" means; we could also have restricted 
  the SOAP-accessible methods by using a space or comma separated list of available 
  method names).</p>
<h4>Using the AdminClient</h4>
<p>Once we have this file, we need to send it to an Axis server in order to actually 
  deploy the described service. We do this with the AdminClient, or the "org.apache.axis.client.AdminClient" 
  class. An invocation of the AdminClient looks like this:</p>
<pre>% java org.apache.axis.client.AdminClient deploy.wsdd
&lt;Admin&gt;Done processing&lt;/Admin&gt;</pre>
<p>This command has now made our service accessible via 
SOAP. Check it out by running the Client class -  it should look like this:</p><PRE>% java samples.userguide.example3.Client "test me!"<BR>You typed : test me!<BR>% </PRE>
<P>If you want to prove to yourself that the deployment really worked, try undeploying 
  the service and calling it again.&nbsp; There's an "undeploy.wsdd" file in the 
  example3/ directory which you can use just as you did the deploy.wsdd file above.&nbsp; 
  Run the AdminClient on that file, then try the service Client again and see 
  what happens.</P>
<P>You can also use the AdminClient to get a listing of all the deployed 
components in the server:</P><PRE>% java org.apache.axis.client.AdminClient list<BR>&lt;big XML document returned here&gt;</PRE>
<P>In there you'll see services, handlers, transports, etc. Note that this listing 
  is an exact copy of the server's &quot;server-config.wsdd&quot; file, which 
  we'll talk about in more detail a little later.</P>
<H4>More deployment - Handlers and Chains</H4>
<p>Now let's start to explore some of the more powerful features of the Axis engine. 
  Let's say you want to track how many times your service has been called. We've 
  included a sample handler in the samples/log directory to do just this. To use 
  a handler class like this, you first need to deploy the Handler itself, and 
  then use the name that you give it in deploying a service. Here's a sample deploy.wsdd 
  file (this is example 4in samples/userguide): </p>
<pre>&lt;deployment xmlns=&quot;http://xml.apache.org/axis/wsdd/&quot;
            xmlns:java=&quot;http://xml.apache.org/axis/wsdd/providers/java&quot;&gt;
 
 &lt;!-- define the logging handler configuration --&gt;
 &lt;handler name="track" type="java:samples.userguide.example4.LogHandler"&gt;
  &lt;parameter name="filename" value="MyService.log"/&gt;
 &lt;/handler&gt;

 &lt;!-- define the service, using the log handler we just defined --&gt;
 &lt;service name="LogTestService"<b> </b>provider=&quot;java:RPC"&gt;
  &lt;requestFlow&gt;
   &lt;handler type=&quot;track&quot;/&gt;
  &lt;/requestFlow&gt;

  &lt;parameter name="className" value="samples.userguide.example4.Service"/&gt;
  &lt;parameter name="methodName" value="*"/&gt;
 &lt;/service&gt;
&lt;/deployment&gt;</pre>
<p>The first section defines a Handler called "track" that is implemented by the 
  class samples.log.LogHandler. We give this Handler an option to let it know 
  which file to write its messages into.</p>
<p>Then we define a service, MyService, which is an RPC service just like we saw 
  above in our first example. The difference is the &lt;requestFlow&gt; element 
  inside the &lt;service&gt; - this indicates a set of Handlers that should be 
  invoked when the service is invoked, before the provider. By inserting a reference 
  to "track", we ensure that the message will be logged each time this service 
  is invoked.<br>
</p>
<h4>Remote Administration</h4>
<p>Note that by default, the Axis server is configured to only accept administration 
  requests from the machine on which it resides - if you wish to enable remote 
  administration, you must set the "enableRemoteAdmin" property of the AdminService 
  to <b>true</b>. To do this, find the "server-config.wsdd" file in your webapp's 
  WEB-INF directory. In it, you'll see a deployment for the AdminService. Add 
  an option as follows:</p>
<pre>&lt;service name="AdminService" provider=&quot;java:MSG"&gt;
 &lt;parameter name="className" value="org.apache.axis.util.Admin"/&gt;
 &lt;parameter name="methodName" value="*"/&gt;
 <b>&lt;parameter name="enableRemoteAdmin" value="true"/&gt;</b>
&lt;/service&gt;</pre>
<p><b>WARNING: enabling remote administration may give unauthorized parties access 
  to your machine. If you do this, please make sure to add security to your configuration!</b><br>
  <i><font color="#ff0000"></font></i> </p>
<i><font color="#ff0000"></font></i><h2><a name="DataMapping"></a>XML &lt;-&gt; Java Data Mapping in Axis</h2>
<h3>Encoding Your Beans - the BeanSerializer</h3>
<p>Axis includes the ability to serialize/deserialize, without writing any code, 
  arbitrary Java classes which follow the standard JavaBean pattern of get/set 
  accessors. All you need to do is tell Axis which Java classes map to which XML 
  Schema types. Configuring a bean mapping looks like this:</p>
<pre class="xml">&lt;beanMapping qname=&quot;ns:local&quot; xmlns:ns="someNamespace"
             languageSpecificType="java:my.java.thingy"/&gt;
</pre>
<p>The &lt;beanMapping&gt; tag maps a Java class (presumably a bean) to an XML 
  QName. You'll note that it has two important attributes, <b>qname</b> and <b>languageSpecificType</b>. 
  So in this case, we'd be mapping the "my.java.thingy" class to the XML QName 
  [someNamespace]:[local].</p>
<p>Let's take a look at how this works in practice. Go look at the samples/userguide/example5/BeanService.java 
  file. (we won't reproduce it here, it's pretty straightforward) The key thing 
  to notice is that the argument to the service method is an Order object. Since 
  Order is not a basic type which Axis understands by default, trying to run this 
  service without a type mapping will result in a fault (if you want to try this 
  for yourself, you can use the bad-deploy.wsdd file in the example5 directory). 
  But if we put a beanMapping into our deployment, all will be well. Here's how 
  to run this example (from the example5 directory):</p>
<pre class="example">% java org.apache.axis.client.AdminClient -llocal:///AdminService deploy.wsdd
&lt;Admin&gt;Done processing&lt;/Admin&gt;

% java Client -llocal:// -n "Glen"
Hi, Glen!

You seem to have ordered the following:

1 of item : mp3jukebox
4 of item : 1600mahBattery

If this had been a real order processing system, we'd probably have charged you about now.
%<br>
</pre>
<h3>When Beans Are Not Enough - Custom Serialization</h3>
<p>Just as JWS deployment is sometimes not flexible enough to meet all needs, 
  the default bean serialization model isn't robust enough to handle every case 
  either. At times there will be non-bean Java classes (especially in the case 
  of pre-existing assets) which you need to map to/from XML, and there also may 
  be some custom XML schema types which you want to map into Java in particular 
  ways. Axis gives you the ability to write custom serializers/deserializers, 
  and some tools to help make your life easier when you do so.</p>
<p><i><font color="#ff0000">TBD - this section will be expanded in a future version! 
  For now, take a look at the ArraySerializer, the BeanSerializer (both in org.apache.axis.encoding), 
  and the DataSer example (in samples/encoding) to see how custom serializers 
  work.</font></i></p>
<h4>Deploying custom mappings - the &lt;typeMapping&gt; tag</h4>
<p>Now that you've built your serializers and deserializers, you need to tell 
  Axis which types they should be used for. You do this with a typeMapping tag 
  in WSDD, which looks like this:</p>
<pre class="xml">&lt;typeMapping qname=&quot;ns:local&quot; xmlns:ns="someNamespace"
             languageSpecificType="java:my.java.thingy"
             serializer=&quot;&quot;
             deserializer=&quot;&quot;/&gt;</pre>
<p>This looks a lot like the &lt;beanMapping&gt; tag we saw earlier, but there 
  are two extra attributes. One, <b>serializer</b>, is the Java class name of 
  the Serializer class which should be used to write the specified Java class 
  (i.e. my.java.thingy) into XML. The other, <b>deserializer</b>, is the class 
  name of a Deserializer <i>factory</i> that generates Deserializers which can 
  be used to unmarshall XML into the correct Java class.</p>
<p>(the &lt;beanMapping&gt; tag is really just shorthand for a &lt;typeMapping&gt; 
  tag with serializer=&quot;org.apache.axis.encoding.BeanSerializer&quot; and 
  deserializer=&quot;org.apache.axis.encoding.BeanSerializer$BeanSerFactory&quot;, 
  but clearly it can save a lot of typing!)</p>
<h2><a name="WSDL"></a>Using WSDL with Axis</h2>
<p>The <a href="http://www.w3.org/TR/wsdl">Web Service Description Language</a> 
  is a specification authored by IBM and Microsoft, and supported by many other 
  organizations. WSDL serves to describe Web Services in a structured way. A WSDL 
  description of a service tells us, in a machine-understandable way, the interface 
  to the service, the data types it uses, and where the service is located. Please 
  see the spec (follow the link in the first sentence) for details about WSDL's 
  format and options.</p>
<p>Axis supports WSDL in two ways: first, when you deploy a service in Axis, users 
  may then access your service's URL with a standard web browser and by appending 
  &quot;?WSDL&quot; to the end of the URL, they will obtain an automatically-generated 
  WSDL document which describes your service. Second, we provide a &quot;Wsdl2java&quot; 
  tool which will build Java proxies and skeletons for services with WSDL descriptions. 
  Both of these techniques are explained in more detail below.</p>
<h3>WSDL generation for deployed services</h3>
<p>When you make a service available using Axis, there is typically a unique URL 
  associated with that service. For JWS files, that URL is simply the path to 
  the JWS file itself. For non-JWS services, this is usually the URL &quot;http://&lt;host&gt;/axis/services/&lt;service-name&gt;&quot;.</p>
<p>If you access the service URL in a browser, you'll see a message indicating 
  that the endpoint is an Axis service, and that you should usually access it 
  using SOAP. However, if you tack on &quot;?wsdl&quot; to the end of the URL, 
  Axis will automatically generate a service description for the deployed service, 
  and return it as XML in your browser (try it!). The resulting description may 
  be saved or used as input to proxy-generation, described next. You can give 
  the WSDL-generation URL to your online partners, and they'll be able to use 
  it to access your service with toolkits like .NET, SOAP::Lite, or any other 
  software which supports using WSDL.</p>
<h3>Building stubs and skeletons with Wsdl2java</h3>
<p>You'll find the Axis WSDL -&gt; Java tool in &quot;org.apache.axis.wsdl.Wsdl2java&quot;. 
  The basic invocation form looks like this:</p>
<div class="example">
  <pre>% java org.apache.axis.wsdl.Wsdl2java <i>(url-to-wsdl-file)</i>
</pre>
</div>
<h4>Stubs - making Web Service access transparent from the client side</h4>
<p>A <b>stub</b> is a Java class which has the same interface as a remote Web 
  Service. It stands in as a <b>proxy</b> (another term for the same idea) for 
  the remote service, letting you call it exactly as if it were a local object. 
  In other words, you don't need to deal with the endpoint URL, namespace, or 
  parameter arrays which are involved in dynamic invocation via the Service
  and Call objects. 
  The stub hides all that work for you.</p>
<p>You can try an example, assuming you've deployed the service in <a href="#descriptors">example 
  3</a> above and have your Axis server up and running. Type the following at 
  the command line:</p>
<pre>% java org.apache.axis.wsdl.Wsdl2java http://localhost:8080/axis/services/MyService?wsdl</pre>
<p>You can add the &quot;--verbose&quot; option right before the URL if you want 
  some more feedback on what the tool is up to. This will generate stub code, 
  which we'll describe.</p>
<p>Wsdl2java generates a few classes; here's a rundown of what they are and how 
  to use them:</p>
<ul>
  <li>There will be an interface for each referenced PortType in the WSDL. These 
    interfaces are the ones you will actually use to call the remote methods, 
    as they contain the operations described in the WSDL. For the example, above, 
    the generated interface is called MyServicePortType.</li>
  <li>The Stub classes implement the interface, and contain the code which turns 
    the method invocations into SOAP calls using the Axis Service and Call
    objects. For the 
    example, this is MyServiceSoapBindingStub. The stubs themselves also have 
    a few additional methods for getting a little more control over the SOAP invocations 
    - in this version of Axis we won't go into more detail about these, though 
    you can read the code if you're inclined.</li>
  <li>The Service class serves as a factory for obtaining Stub instances - MyService 
    for our example. The Service class will by default make a Stub which points 
    to the endpoint URL described in the WSDL file, but you may also specify a 
    different URL when you ask for the PortType.</li>
</ul>
<p>So a typical usage of the stub classes would be as follows:</p>
<pre class="example">public class Tester {
  public static void main(String [] args) throws Exception
  {
    // Make a service (PortType factory)
    MyService service = new MyService();


    // Now use the service to get a PortType that we can call.
    MyServicePortType port = service.getMyServicePort();
 
    // Make the actual call
    String ret = port.serviceMethod(&quot;test string&quot;);
    System.out.println(&quot;Return val was &quot; + ret);
  }
} </pre>
<h4>Skeletons - frameworks for implementing Web Services</h4>
<p>Just as a stub is the client side of a Web Service represented in Java, a <b>skeleton</b> 
  is a Java framework for the server side. You'd want to make a skeleton if you 
  had a WSDL description of a service which you'd like to implement. For instance, 
  you might want to join a digital marketplace which requires you to make your 
  inventory available via a particular Web Service interface.</p>
<p>To make skeleton classes, you just specify the &quot;--skeleton&quot; option 
  to Wsdl2java. For instance, if we wanted to replicate the service in the last 
  example, we'd type:</p>
<pre>% java org.apache.axis.wsdl.Wsdl2java --skeleton http://localhost:8080/axis/services/MyService?wsdl</pre>
<p>There are a couple of classes produced by the skeleton generator, so let's 
  take a look at them:</p>
<ul>
  <li>The Skeleton proper (in our example, <b>MyServiceSoapBindingSkeleton</b>) 
    is the class you'll actually deploy as an Axis service. You won't need to 
    edit the code in here at all.</li>
  <li>The Implementation class (<b>MyServiceSoapBindingImpl</b>) is the actual 
    framework class which you'll flesh out with your own code.</li>
</ul>
The tool also builds you a &quot;deploy.xml&quot; and an &quot;undeploy.xml&quot; 
for use with the AdminClient. These files may be used to deploy the service once 
you've filled in the methods of the Implementation class, compiled the code, and 
made the classes available to your Axis engine. 
<h4>Data Types for Stubs and Skeletons</h4>
<h3></h3>
<p>WSDL files can contain (or reference) XML Schema describing the data types 
  used by particular operations. As we've seen, Axis needs to do some work to 
  map schema types to Java types, and this remains true whether we code the Java 
  by hand or generate it with a tool. When you use Wsdl2java to generate either 
  stubs or skeletons for operations which contain complex types, you will notice 
  that Java classes corresponding to the XML data types are also generated. For 
  the stub, the code inside the stub handles setting up the type mapping in Axis 
  - and for the skeleton, the type mappings are included in the generated &quot;deploy.xml&quot; 
  file. </p>
<h5>Holders</h5>
<p>You'll notice that for each data class that Wsdl2java generates, there is a 
  corresponding &quot;Holder&quot; class - for instance a class called &quot;MyDataType&quot; 
  would also get a companion class &quot;MyDataTypeHolder&quot;. These classes 
  exist so that we have a reasonably clean mapping for WSDL's in/out and out parameters 
  in Java. See the examples for more details.</p>
<h4>Wsdl2java details</h4>
Wsdl2java has a number of options, some of which have already been detailed.
<p>Usage:&nbsp; java org.apache.axis.wsdl.Wsdl2java [options] WSDL-URI
<br>Options:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -h, --help
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print this message and exit
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -v, --verbose
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print informational messages
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -s, --skeleton
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
emit skeleton class for web service
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -m, --messageContext
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
emit a MessageContext parameter to skeleton methods
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -N, --NStoPkg &lt;argument>=&lt;value>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mapping of namespace to package
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -o, --output &lt;argument>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
output directory for emitted files
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -d, --deployScope &lt;argument>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
add scope to deploy.xml: "Application", "Request", "Session"
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -t, --testCase
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
emit junit testcase class for web service
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -n, --noImports
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
only generate code for the immediate WSDL document
<br>&nbsp;
<h5>
-h, --help</h5>
Print the usage statement and exit
<h5>
-v, --verbose</h5>
See what the tool is generating as it is generating it.
<h5>
-s, --skeleton</h5>
Detailed above.
<h5>
-m, --messageContext</h5>
The AXIS runtime contains a MessageContext that is normally not available
to the server-side implementation.&nbsp; Turning on this option adds a
MessageContext argument to each operation in the server-side interface
so that the implementation can be given the context.
<h5>
-N, --NStoPkg &lt;argument>=&lt;value></h5>
By default, package names are generated from the namespace strings in the
WSDL document.&nbsp; Users can provide their own mapping using the --NStoPkg
argument, which can be repeated as often as necessary, once for each unique
namespace mapping.&nbsp; For example, if there is a namespace in the WSDL
document called "urn:AddressFetcher2", and you want files generated from
the objects within this namespace to reside in the package samples.addr,
you would provide the following option to Wsdl2java:
<pre>--NStoPkg urn:AddressFetcher2=samples.addr</pre>
If there are a number of namespaces in the WSDL document, listing a mapping
for them all could become tedious.&nbsp; To help keep the command line
terse, Wsdl2java will also look for mappings in a file called NStoPkg.properties
residing in the default package (ie., no package).&nbsp; The entries in
this file are of the same form as the arguments to the --NStoPkg command
line option.&nbsp; For example, instead of providing the command line option
as above, we could provide the same information in NStoPkg.properties:
<pre>urn\:AddressFetcher2=samples.addr</pre>
(Note that the colon must be escaped in the properties file.)
<p>If an entry for a given mapping exists both on the command line and
in the properties file, the command line entry takes precedence.
<h5>
-o, --output &lt;argument></h5>
The root directory for all emitted files.
<h5>
-d, --deployScope &lt;argument></h5>
Add scope to deploy.xml: "Application", "Request", or "Session".&nbsp;
If this option does not appear, no scope tag appears in deploy.xml, which
the AXIS runtime defaults to "Request".
<h5>
-t, --testCase</h5>
Generate a client-side JUnit test case.
<h5>
-n, --noImports</h5>
Only generate code for the WSDL document that appears on the command line.&nbsp;
The default behaviour is to generate files for all WSDL documents, the
immediate one and all imported ones.
<h2><a name="DeploymentReference"></a>Deployment Reference</h2>
<i>Note: this reference reflects the state of the deploy.xml structure as of the 
alpha 1 release. This will <b>very likely change</b> in a subsequent release to 
become a format called WSDD (Web Service Deployment Descriptor). You can find 
information on WSDD in the Axis source tree, under xml-axis/java/wsdd.</i> 
<dl> 
  <dt><b><font face="Courier New, Courier, mono">&lt;m:deploy xmlns:m=&quot;AdminService&quot;&gt;</font></b></dt>
  <dd>The root element of the deployment document which tells the Axis engine 
    that this is a deployment. Must be in the &quot;AdminService&quot; namespace.</dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;m:undeploy xmlns:m=&quot;AdminService&quot;&gt;</font></b></dt>
  <dd>The root element of the deployment document which tells Axis that this is 
    an undeployment. Must be in the &quot;AdminService&quot; namespace.</dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;handler name=&quot;</font></b><font face="Courier New, Courier, mono"><i>name</i></font><b><font face="Courier New, Courier, mono">&quot; 
    class=&quot;</font></b><font face="Courier New, Courier, mono"><i>classname</i></font><b><font face="Courier New, Courier, mono">&quot;/&gt;</font></b></dt>
  <dd>Belongs inside a deploy or undeploy. Names a Handler, and indicates the 
    class which corresponds to the name. May contain an arbitrary number of <b><font face="Courier New, Courier, mono">&lt;option 
    name=&quot;</font></b><font face="Courier New, Courier, mono"><i>name</i></font><b><font face="Courier New, Courier, mono">&quot; 
    value=&quot;</font></b><font face="Courier New, Courier, mono"><i>value</i></font><b><font face="Courier New, Courier, mono">&quot;&gt;</font></b> 
    elements, each of which will supply an option to the deployed Handler.</dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;service name=&quot;</font></b><font face="Courier New, Courier, mono"><i>name</i></font><b><font face="Courier New, Courier, mono">&quot; 
    request=&quot;</font></b><font face="Courier New, Courier, mono"><i>handler</i></font><b><font face="Courier New, Courier, mono">&quot; 
    response=&quot;</font></b><font face="Courier New, Courier, mono"><i>handler</i></font><b><font face="Courier New, Courier, mono">&quot; 
    pivot=&quot;</font></b><font face="Courier New, Courier, mono"><i>handler</i></font><b><font face="Courier New, Courier, mono">&quot; 
    &gt;</font></b></dt>
  <dd>Deploys/undeploys an Axis Service. Common options for this element (i.e. 
    subelements of the form <code><b>&lt;option name=&quot;</b>name<b>&quot; value=&quot;</b>value<b>&quot;/&gt;</b>)</code> 
    include:<br>
    <b>className</b> : the backend implementation class<br>
    <b>methodName</b> : the allowed methods<br>
    <b>allowedRoles</b> : comma-separated list of roles allowed to access this 
    service</dd>
  <dt><b><br>
    <font face="Courier New, Courier, mono">&lt;chain name=&quot;</font></b><font face="Courier New, Courier, mono"><i>name</i></font><b><font face="Courier New, Courier, mono">&quot; 
    flow=&quot;</font></b><font face="Courier New, Courier, mono"><i>handler handler...</i></font><b><font face="Courier New, Courier, mono">&quot;&gt;</font></b></dt>
  <dd>Defines a chain. Each <i>handler</i> (i.e. deployed handler name) in the 
    list will be invoked() in turn when the chain is invoked. This enables you 
    to build up &quot;modules&quot; of commonly used functionality.</dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;transport name=&quot;</font></b><font face="Courier New, Courier, mono"><i>name</i></font><b><font face="Courier New, Courier, mono">&quot;&gt;</font></b></dt>
  <dd>Defines a transport.</dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;typeMappings&gt;</font></b></dt>
  <dd>Contains an abitrary number of <b>&lt;typeMapping&gt;</b> elements:<br>
    <br>
    <b><font face="Courier New, Courier, mono">&lt;typeMapping qname=&quot;</font></b><font face="Courier New, Courier, mono"><i>ns:localName</i></font><b><font face="Courier New, Courier, mono">&quot; 
    classname=&quot;</font></b><font face="Courier New, Courier, mono"><i>classname</i></font><b><font face="Courier New, Courier, mono">&quot; 
    serializer=&quot;</font></b><font face="Courier New, Courier, mono"><i>classname</i></font><b><font face="Courier New, Courier, mono">&quot; 
    deserializerFactory=&quot;</font></b><font face="Courier New, Courier, mono"><i>classname</i></font><b><font face="Courier New, Courier, mono">&quot;/&gt;</font><br>
    <br>
    </b>Each typeMapping maps an XML qualified name to/from a Java class, using 
    a specified Serializer and DeserializerFactory. (note: the reason we specify 
    the Serializer directly, and the Deserializer as a factory, is because Deserializers 
    are stateful, and are tied to a particular element. Serializers, on the other 
    hand, are stateless and may be freely shared, so we only need one)</dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;beanMappings&gt;</font></b></dt>
  <dd>Contains an arbitrary number of elements, each of which represents a mapping 
    of an XML QName to a Java class.<br>
    <br>
    <b><font face="Courier New, Courier, mono">&lt;</font></b><font face="Courier New, Courier, mono"><i>ns:localName</i></font><b><font face="Courier New, Courier, mono"> 
    classname=&quot;</font></b><font face="Courier New, Courier, mono"><i>classname</i></font><b><font face="Courier New, Courier, mono">&quot;/&gt;</font><br>
    <br>
    </b>The class named by &quot;classname&quot; must follow the JavaBean standard 
    pattern of get/set accessors.</dd>
</dl>
<p> </p>
<h2>Pre-Configured Axis Components Reference</h2>
<h3>On the server:</h3>
<dl> 
  <dt><b>LogHandler</b> 
  <dd>The LogHandler will simply log a message to a logger when it gets invoked. 
  <dt> 
  <dt><b>EchoHandler</b> 
  <dd>The EchoHandler copies the request message into the response message. 
  <dt><b>HTTPAuth</b>
  <dd>The HTTPAuthHandler takes HTTP-specific authentication information (right 
    now, just Basic authentication) and turns it into generic MessageContext properties 
    for username and password
  <dt><b>SimpleAuthenticationHandler</b> 
  <dd>The SimpleAuthentication handler passes a MessageContext to a SecurityProvider 
    (see org.apache.axis.security) to authenticate the user using whatever information 
    the SecurityProvider wants (right now, just the username and password).
  <dt><b>SimpleAuthorizationHandler</b> 
  <dd>This handler, typically deployed alongside the SimpleAuthenticationHandler 
    (a chain called &quot;authChecks&quot; is predefined for just this combination), 
    checks to make sure that the currently authenticated user satisfies one of 
    the allowed roles for the target service. Throws a Fault if access is denied.
  <dt><b>URLMapper</b> 
  <dd>The URLMapper, an HTTP-specific handler, usually goes on HTTP transport 
    chains (it is deployed by default). It serves to do service dispatch based 
    on URL - for instance, this is the Handler which allows URLs like http://localhost:8080/axis/services/MyService?wsdl 
    to work.
  <dt>&nbsp;
  <dt> 
  <dt><b>RPCDispatcher</b> 
  <dd>The RPCDispatcher is the pivot point for all RPC services. It accepts the 
    following options: <br>
    <b><i>className</i></b> = the class of the backend object to invoke<br>
    <b><i>methodName</i></b> = a space-separated list of methods which are exported 
    as web services. The special value &quot;*&quot; matches all public methods 
    in the class. 
  <dt> 
  <dt><b>MsgDispatcher</b> 
  <dd>The MsgDispatcher is the pivot point for all messaging services. It accepts 
    the following options: <br>
  <dd><b><i>className</i></b> = the class of the backend object to invoke<br>
    <b><i>methodName</i></b> = a space-separated list of methods which are exported 
    as web services. The special value &quot;*&quot; matches all public methods 
    in the class. 
  <dt> 
  <dt><b></b> 
  <dt> 
  <dt><b>LocalResponder</b> 
  <dd>The LocalResponder is a Handler whose job in life is to serialize the response 
    message coming back from a local invocation into a String. It is by default 
    on the server's local transport response chain, and it ensures that serializing 
    the message into String form happens in the context of the server's type mappings.</dd>
</dl>
<h3>On the client:</h3>
<dl> 
  <dt><b>HTTPSender</b> 
  <dd>A Handler which sends the request message to a remote server via HTTP, and 
    collects the response message.
  <dt> 
  <dt><b>LocalSender</b> 
  <dd>A Handler which sends the request message to a &quot;local&quot; AxisServer, 
    which will process it and return a response message. This is extremely useful 
    for testing, and is by default mapped to the &quot;local:&quot; transport. 
    So, for instance, you can test the AdminClient by doing something like this:<br>
    <pre>% java org.apache.axis.client.AdminClient -llocal:// list</pre>
  <dt></dt>
</dl>
<a name="tcpmon"></a><h2>Using the Axis TCP Monitor (tcpmon) </h2>
<p>The included &quot;tcpmon&quot; utility can be found in the org.apache.axis.utils 
  package. To run it from the command line:</p>
<pre>% java org.apache.axis.utils.tcpmon [listenPort targetHost targetPort]</pre>
<p>Without any of the optional arguments, you will get a gui which looks like this:</p>
<p align="center"><img src="tcpmon1.jpg" width="599" height="599"></p>
<p align="left">To use the program, you should select a local port which tcpmon 
  will monitor for incoming connections, a target host where it will forward such 
  connections, and the port number on the target machine which should be &quot;tunneled&quot; 
  to. Then click &quot;add&quot;. You should then notice another tab appearing 
  in the window for your new tunneled connection. Looking at that panel, you'll 
  see something like this:</p>
<p align="center"><img src="tcpmon2.jpg" width="599" height="600"></p>
<p align="left">Now each time a SOAP connection is made to the local port, you 
  will see the request appear in the &quot;Request&quot; panel, and the response 
  from the server in the &quot;Response&quot; panel. Tcpmon keeps a log of all 
  request/response pairs, and allows you to view any particular pair by selecting 
  an entry in the top panel. You may also remove selected entries, or all of them, 
  or choose to save to a file for later viewing.</p>
<p align="left">The &quot;resend&quot; button will resend the request you are 
  currently viewing, and record a new response. This is particularly handy in 
  that you can edit the XML in the request window before resending - so you can 
  use this as a great tool for testing the effects of different XML on SOAP servers.</p>
<dl>
  <dt> </dt>
</dl>
<a name="Glossary"></a><h2>Glossary</h2>
<dl> 
  <dt><i>Handler</i>
  <dd>&lt;definition&gt; 
  <dt>
  <dt><i>SOAP</i>
  <dd>The Simple Object Access Protocol (yes, despite the fact that it sometimes 
    doesn't seem so simple, and doesn't have anything to do with objects... :)). 
    You can read the SOAP 1.1 specification at <a href="http://www.w3.org/TR/SOAP">http://www.w3.org/TR/SOAP</a>. 
    The W3C is currently in the midst of work on SOAP 1.2, under the auspices 
    of the <a href="http://www.w3.org/2000/xp/Group/">XML Protocol Group</a>. 
  <dt>
  <dt><i>Provider</i>
  <dd>&lt;definition&gt; 
  <dt>
  <dt><i></i></dt>
</dl>
</body>
</html>
