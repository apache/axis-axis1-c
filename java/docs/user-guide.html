<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.73 [en] (WinNT; U) [Netscape]">
   <title>Axis User's Guide</title>
<!-- saved from url=(0022)http://internet.e-mail -->
<style type="text/css">
<!--
.example { background:#ccccff }
.xml { background:#eeeeee }
body {  font-family: Verdana, Arial, Helvetica, sans-serif; margin-left: 40px}
h2 {  text-decoration: underline; background-color: #DCE1FF; background-position: left; margin-left: -30px}
h3 {  margin-left: -10px}
h1 {  margin-left: -30px}
-->
</style>
</head>
<body text="#000000" bgcolor="#FFFFFF">

<center>
<h1>
<img SRC="axis.jpg" height=96 width=176></h1></center>

<h1>
Axis User's Guide</h1>
<i>Beta 2 Version</i> 
<h3>
Table of Contents</h3>

<ul>
  <li> <a href="#Introduction">Introduction</a></li>
  <li> <a href="#Installation">Installing Axis</a></li>
  <li> <a href="#ConsumingServices">Consuming Web Services with Axis</a></li>
  <li> <a href="#PublishingServices">Publishing Web Services with Axis</a></li>
  <li> <a href="#DataMapping">XML &lt;-> Java Data Mapping in Axis</a></li>
  <li> <a href="#WSDL">Using WSDL with Axis</a></li>
  <ul>
    <li> &nbsp;<a href="#WSDL: Obtaining WSDL for deployed services">?WSDL: Obtaining 
      WSDL for deployed services</a></li>
    <li> &nbsp;<a href="#WSDL2Java: Building stubs, skeletons, and data">WSDL2Java: 
      Building stubs, skeletons, and data</a></li>
    <li> &nbsp;<a href="#Java2WSDL: Building WSDL from Java">Java2WSDL: Building 
      WSDL from Java</a></li>
  </ul>
  <li> <a href="#published interfaces">Published Interfaces</a></li>
  <li> <a href="#tcpmon">Appendix : Using TCPMon</a></li>
  <li> <a href="#Glossary">Glossary</a></li>
</ul>

<h2>
<a NAME="Introduction"></a>Introduction</h2>
Welcome to Axis, the third generation of Apache SOAP! This is the <b>beta 2</b> 
version. 
<h3>
What is SOAP?</h3>
SOAP is an XML<i>-</i>based communication protocol and encoding format for inter-application 
communication. Originally conceived by Microsoft and Userland software, it has 
evolved through several generations and the current spec, <a href="http://w3.org/TR/soap">SOAP 
1.1</a>, is fast growing in popularity and usage. The W3C's <a href="http://www.w3.org/2000/xp/Group/">XML 
Protocol working group</a> is in the process of turning SOAP into a true open 
standard, and as of this writing has released a working draft of SOAP 1.2, which 
cleans up some of the more confusing areas of the 1.1 spec. 
<p>SOAP is widely viewed as the backbone to a new generation of cross-platform
cross-language distributed computing applications, termed Web Services.
<h3>
What is Axis?</h3>
Axis is essentially a <i>SOAP engine</i> -- a framework for
constructing SOAP processors such as
clients, servers, gateways, etc.
The current version of Axis is written in Java, but
a C++ implementation of the client side of Axis is being developed.
<p>
But Axis isn't just a SOAP engine -- it also includes:
<ul>
  <li> a simple stand-alone server,
  <li> a server which plugs into servlet engines such as Tomcat,
  <li> extensive support for the <i>Web Service Description Language (WSDL)</i>,
  <li> emitter tooling that generates Java classes from WSDL.
  <li> some sample programs, and
  <li> a tool for monitoring TCP/IP packets.
</ul>
<p>
Axis is the third generation of Apache SOAP (which began at IBM as "SOAP4J").
In late 2000, the committers of Apache SOAP v2 began discussing
how to make the engine much more flexible, configurable, and able to handle
both SOAP and the upcoming XML Protocol specification from the W3C.
<p>After a little while, it became clear that a ground-up rearchitecture
was required. Several of the v2 committers proposed very similar designs,
all based around configurable "chains" of message "handlers" which would
implement small bits of functionality in a very flexible and composable
manner.
<p>After months of continued discussion and coding
effort in this direction, Axis now delivers the following key features:
<ul>
  <li> <b>Speed.</b> Axis uses SAX (event-based) parsing to acheive significantly 
    greater speed than earlier versions of Apache SOAP.</li>
  <li> <b>Flexibility.</b> The Axis architecture gives the developer complete 
    freedom to insert extensions into the engine for custom header processing, 
    system management, or anything else you can imagine.</li>
  <li> <b>Stability.</b> Axis defines a set of <a href="#published interfaces">published 
    interfaces</a> which change relatively slowly compared to the rest of Axis.</li>
  <li> <b>Component-oriented deployment.</b> You can easily define reusable networks 
    of Handlers to implement common patterns of processing for your applications, 
    or to distribute to partners.</li>
  <li> <b>Transport framework.</b> We have a clean and simple abstraction for 
    designing transports (i.e. senders and listeners for SOAP over various protocols 
    such as SMTP, FTP, message-oriented middleware, etc), and the core of the 
    engine is completely transport-independent.</li>
  <li><b>WSDL support.</b> Axis supports the <a href="http://www.w3.org/TR/wsdl">Web 
    Service Description Language</a>, version 1.1, which allows you to easily 
    build stubs to access remote services, and also to automatically export machine-readable 
    descriptions of your deployed services from Axis.</li>
</ul>
<p>
We hope you enjoy using Axis. Please note that this is an open-source effort
- if you feel the code could use some new features or fixes, please get
involved and lend a hand! The Axis developer community welcomes your participation.
<h4>
<b>Let us know what you think!</b></h4>
Please send feedback about the package to "<a href="mailto:axis-user@xml.apache.org">axis-user@xml.apache.org</a>".
Also, Axis is registered in <a href="http://nagoya.apache.org/bugzilla">bugzilla</a>,
the Apache bug tracking and feature-request database.
<h3>
What's in this release?</h3>
This release includes the following features:
<ul>
  <li> SOAP 1.1 compliant engine (with some SOAP 1.2 support as well)</li>
  <li> Flexible configuration / deployment system</li>
  <li> Support for "drop-in" deployment of SOAP services (JWS)</li>
  <li> Support for all basic types, and a type mapping system for defining new 
    serializers/deserializers</li>
  <li> Automatic serialization/deserialization of Java Beans, including customizable 
    mapping of fields to XML elements/attributes</li>
  <li> Automatic two-way conversions between Java Collections and SOAP Arrays</li>
  <li> Providers for RPC and message based SOAP services</li>
  <li> Automatic WSDL generation from deployed services</li>
  <li> WSDL2Java tool for building Java proxies and skeletons from WSDL documents</li>
  <li> Java2WSDL tool for building WSDL from Java classes.</li>
  <li> Preliminary security extensions, which can integrate with Servlet 2.2 security/roles</li>
  <li>Support for session-oriented services, via HTTP cookies or transport-independent 
    SOAP headers</li>
  <li>Preliminary support for the <b>SOAP with Attachments</b> specification</li>
  <li> An EJB provider for accessing EJB's as Web Services</li>
  <li> HTTP servlet-based transport</li>
  <li> Standalone version of the server (with HTTP support)</li>
  <li> Examples, including a client and server for the soapbuilders community 
    interoperability tests and experimental TCP and file-based transports.</li>
</ul>

<h3> What's missing?</h3>

<ul>
  <li>Full SOAP 1.2 support</li>
</ul>
<h2>
<a NAME="Installation"></a>Installing Axis and Using this Guide</h2>
See the <a href="install.html">Axis Installation Guide</a>
for instructions on installing Axis as a web application on your J2EE server.
<p>Before running the examples in this guide, you'll need to make sure
that your CLASSPATH includes (note:  if you build axis from a CVS checkout, these will be in xml-axis/java/build/lib instead of xml-axis-beta2/lib):
<ul>
<li>xml-axis-beta2/lib/axis.jar</li>
<li>xml-axis-beta2/lib/jaxrpc.jar</li>
<li>xml-axis-beta2/lib/commons-logging.jar</li>
<li>xml-axis-beta2/lib/tt-bytecode.jar</li>
<li>xml-axis-beta2/lib/wsdl4j.jar</li>
  <li>xml-axis-beta2/ <i><font color="#9966FF">(for the sample code)</font></i></li>
  <li>A JAXP-1.1 compliant XML parser such as xerces or crimson</li>
</ul>
<h2>
<a NAME="ConsumingServices"></a>Consuming Web Services with Axis</h2>

<h3>
Basics - Getting Started</h3>
Let's take a look at an example Web Service client that will call the <b>echoString</b>
method on the public Axis server at Apache.
<pre class="example">1&nbsp;&nbsp; import org.apache.axis.client.Call;
2&nbsp;&nbsp; import org.apache.axis.client.Service;
3&nbsp;&nbsp; import javax.xml.rpc.namespace.QName;
4&nbsp;&nbsp;&nbsp;
5&nbsp;&nbsp; public class TestClient {
6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static void main(String [] args) {
7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String endpoint =
9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "http://nagoya.apache.org:5049/axis/services/echo";
10&nbsp;&nbsp;
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Service&nbsp; service = new Service();
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Call&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; = (Call) service.createCall();
13&nbsp;&nbsp;
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call.setTargetEndpointAddress( new java.net.URL(endpoint) );
15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call.setOperationName(new QName("<font color="#009933">http://soapinterop.org/</font>", "<font color="#993333">echoString</font>"));
16&nbsp;&nbsp;
17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String ret = (String) call.invoke( new Object[] { "<font color="#CC00CC">Hello!</font>" } );
18&nbsp;&nbsp;
19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Sent 'Hello!', got '" + ret + "'");
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e) {
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(e.toString());
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
23&nbsp;&nbsp;&nbsp;&nbsp; }
24&nbsp; }</pre>
(You'll find this file in <a href="../samples/userguide/example1/TestClient.java">samples/userguide/example1/TestClient.java</a>)
<p>Assuming you have a network connection active, this program can be run
as follows:
<pre class="example">% java samples.userguide.example1.TestClient
Sent 'Hello!', got 'Hello!'
%</pre>
So what's happening here? On lines 11 and 12 we create new Service and
Call objects. These are the standard JAX-RPC objects that are used to store
metadata about the service to invoke. On line 14, we set up our endpoint
URL - this is the destination for our SOAP message. On line 15 we define
the operation (method) name of the Web Service. And on line 17 we actually invoke
the desired service, passing in an array of parameters - in this case just
one String.
<p>You can see what happens to the arguments by looking at the SOAP request that 
  goes out on the wire (look at the colored sections, and notice they match the 
  values in the call above): 
<pre class="xml">&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;SOAP-ENV:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
&nbsp; &lt;SOAP-ENV:Body>
&nbsp;&nbsp;&nbsp; &lt;ns1:<b><font color="#993333">echoString</font></b> xmlns:ns1="<b><font color="#009933">http://soapinterop.org/</font></b>">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;arg0 xsi:type="xsd:string"><b><font color="#CC00CC">Hello!</font></b>&lt;/arg0>
&nbsp;&nbsp;&nbsp; &lt;/ns1:echoString>
&nbsp; &lt;/SOAP-ENV:Body>
&lt;/SOAP-ENV:Envelope></pre>
<p>The String argument is automatically serialized into XML, and the server
responds with an identical String, which we deserialize and print.</p>
<p><i>Note: to actually watch the XML flowing back and forth between a
SOAP client and server, you can use the included tcpmon tool. See the <a href="#tcpmon">appendix</a>
for an overview.</i></p>
<h3>Naming Parameters</h3>
In the above example, you can see that Axis automatically names the XML-encoded 
arguments in the SOAP message "arg0", "arg1", etc. (in this case there's just 
&quot;arg0&quot;) If you want to change this, it's easy! Before calling <tt>invoke()</tt> 
you need to call <tt>addParameter</tt> for each parameter and <tt>setReturnType</tt> for the return, like so: 
<pre class="example">&nbsp; call.addParameter("testParam",&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; org.apache.axis.Constants.XSD_STRING,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; javax.xml.rpc.ParameterMode.IN);
&nbsp; call.setReturnType(org.apache.axis.Constants.XSD_STRING);&nbsp;</pre>
This will assign the name <b>testParam</b> to the 1st (and only) parameter
on the invoke call. This will also define the type of the parameter (<tt>org.apache.axis.Constants.XSD_STRING</tt>)
and whether it is an input, output or inout parameter - in this case its
an input parameter. Now when you run the program you'll get a message that
looks like this:
<pre class="xml">&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;SOAP-ENV:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
&nbsp; &lt;SOAP-ENV:Body>
&nbsp;&nbsp;&nbsp; &lt;ns1:echoString xmlns:ns1="http://soapinterop.org/">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<font color="#CC00CC">testParam</font> xsi:type="xsd:string">Hello!&lt;/<font color="#CC00CC">testParam</font>>
&nbsp;&nbsp;&nbsp; &lt;/ns1:echoString>
&nbsp; &lt;/SOAP-ENV:Body>
&lt;/SOAP-ENV:Envelope></pre>
Note that the param is now named "testParam" as expected.
<h3>Interoperating with "untyped" servers</h3>
In the above examples, we've been casting the return type of invoke(),
which is Object, to the appropriate "real" type - for instance, we know
that the echoString method returns a String, so we expect to get one back
from client.invoke(). Let's take a moment and investigate how this happens,
which sheds light on a potential problem (to which, of course, we have
a solution - so don't fret :)).
<p>Here's what a typical response might look like to the echoString method: </p>
<pre class="xml">&lt;?xml version="1.0" encoding="UTF-8"?><br> &lt;SOAP-ENV:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
                    xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"> 
  &lt;SOAP-ENV:Body>
   &lt;ns1:echoStringResponse xmlns:ns1="http://soapinterop.org/"> 
    &lt;result <font color="#FF0000">xsi:type="xsd:string"</font>>Hello!&lt;/result>
   &lt;/ns1:echoStringResponse> 
  &lt;/SOAP-ENV:Body>
 &lt;/SOAP-ENV:Envelope></pre>
<p>Take a look at the section which we've highlighted in <font color="#FF0000">red</font> 
- that attribute is a schema <b>type declaration</b>, which Axis uses to figure 
out that the contents of that element are, in this case, deserializable into a 
Java String object. Many toolkits put this kind of explicit typing information 
in the XML to make the message "self-describing". On the other hand, some toolkits 
return responses that look like this: </p>
<pre class="xml">&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;SOAP-ENV:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 &lt;SOAP-ENV:Body>
  &lt;ns1:echoStringResponse xmlns:ns1="http://soapinterop.org/">
   &lt;result>Hello, I'm a string!&lt;/result>
  &lt;/ns1:echoStringResponse>
 &lt;/SOAP-ENV:Body>
&lt;/SOAP-ENV:Envelope></pre>
<p>There's no type in the message, so how do we know what Java object we should
deserialize the &lt;result> element into? The answer is <b>metadata</b>
- data about data. In this case, we need a <b>description</b> of the service
that tells us what to expect as the return type. Here's how to do it on
the client side in Axis:</p>
<pre class="example">&nbsp; call.setReturnType( org.apache.axis.Constants.XSD_STRING );</pre>
<p>This method will tell the Axis client that if the return element is not typed 
  then it should act as if the return value has an xsi:type attribute set to the 
  predefined SOAP String type. (You can see an example of this in action in the 
  interop echo-test client - samples/echo/TestClient.java.) </p>
<p>There is also a similar method which allows you to specify the Java class of 
  the expected return type:</p>
<pre class="example">call.setReturnClass(String.class);</pre>
<p>OK - so now you know the basics of accessing SOAP services as a client.
But how do you publish your own services?
<h2>
<a NAME="PublishingServices"></a>Publishing Web Services with Axis</h2>
Let's say we have a simple class like the following:
<pre class="example">public class Calculator {
&nbsp; public int add(int i1, int i2)
&nbsp; {
&nbsp;&nbsp;&nbsp; return i1 + i2;&nbsp;
&nbsp; }
&nbsp;&nbsp;
&nbsp; public int subtract(int i1, int i2)
&nbsp; {
&nbsp;&nbsp;&nbsp; return i1 - i2;
&nbsp; }
}</pre>
(You'll find this very class in <a href="../samples/userguide/example2/Calculator.java">samples/userguide/example2/Calculator.java</a>.)
<p>How do we go about making this class available via SOAP? There are a
couple of answers to that question, but we'll start with the easiest way
Axis provides to do this, which takes almost no effort at all!
<h3>
JWS (Java Web Service) Files - Instant Deployment</h3>
OK, here's step 1 : copy the above .java file into your webapp directory,
and rename it "Calculator.jws". So you might do something like this:
<pre>% copy Calculator.java <i><font color="#0000FF">&lt;your-webapp-root></font></i>/axis/Calculator.jws</pre>
Now for step 2... hm, wait a minute. You're done! You should now be able
to access the service at the following URL (assuming your Axis web application
is on port 8080):
<p><a href="http://localhost:8080/axis/Calculator.jws">http://localhost:8080/axis/Calculator.jws</a>
<p>Axis automatically locates the file, compiles the class, and converts
SOAP calls correctly into Java invocations of your service class. Try it
out - there's a calculator client in samples/userguide/example2/CalcClient.java,
which you can use like this:
<pre class="example">% java samples.userguide.example2.CalcClient -p8080 add 2 5
Got result : 7
% java samples.userguide.example2.CalcClient -p8080 subtract 10 9
Got result : 1
%</pre>
(note that you may need to replace the "-p8080" with whatever port your
J2EE server is running on)
<h3>
Custom Deployment - Introducing WSDD</h3>
JWS files are great quick ways to get your classes out there as Web Services, 
but they're not always the best choice. For one thing, you need the source code 
- there might be times when you want to expose a pre-existing class on your system 
without source. Also, the amount of configuration you can do as to how the service 
gets accessed is pretty limited - you can't specify custom type mappings, or control 
which Handlers get invoked when people are using your service. <i>(note for the 
future : the Axis team, and the Java SOAP community at large, are thinking about 
ways to be able to embed this sort of metadata into your source files if desired 
- stay tuned!)</i> 
<h4>
<a NAME="descriptors"></a>Deploying via descriptors</h4>
<p>To really use the flexibility available to you in Axis, you should get
familiar with the Axis <b>Web Service Deployment Descriptor (WSDD)</b>
format. A deployment descriptor contains a bunch of things you want to
"deploy" into Axis - i.e. make available to the Axis engine. The most common
thing to deploy is a Web Service, so let's start by taking a look at a
deployment descriptor for a basic service (this file is <a href="../samples/userguide/example3/deploy.wsdd">samples/userguide/example3/deploy.wsdd</a>):</p>
<pre class="example">&lt;deployment xmlns="http://xml.apache.org/axis/wsdd/"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmlns:java="http://xml.apache.org/axis/wsdd/providers/java">
&nbsp;&lt;service name="MyService" provider="java:RPC">
&nbsp; &lt;parameter name="className" value="samples.userguide.example3.MyService"/>
&nbsp; &lt;parameter name="allowedMethods" value="*"/>
&nbsp;&lt;/service>
&lt;/deployment></pre>
Pretty simple, really - the outermost element tells the engine that this is a 
WSDD deployment, and defines the "java" namespace. Then the service element actually 
defines the service for us. A service is a <b>targeted chain</b> (see the <a href="architecture-guide.html">Architecture 
Guide</a>), which means it may have any/all of: a request flow, a pivot Handler 
(which for a service is called a "provider"), and a response flow. In this case, 
our provider is "java:RPC", which is built into Axis, and indicates a Java RPC 
service. The actual class which handles this is <b>org.apache.axis.providers.java.RPCProvider</b>. 
<p>We need to tell the RPCProvider that it should instantiate and call the correct 
  class (e.g. samples.userguide.example3.MyService), and we do so by including 
  &lt;parameter> tags, giving the service one parameter to configure the class 
  name, and another to tell the engine that any public method on that class may 
  be called via SOAP (that's what the "*" means; we could also have restricted 
  the SOAP-accessible methods by using a space or comma separated list of available 
  method names).
<h4>Advanced WSDD - specifying more options</h4>
<p>WSDD descriptors can also contain other information about services, and also 
  other pieces of Axis called &quot;Handlers&quot; which we'll cover in a later 
  section.
<h5>Scoped Services</h5>
<p>Axis supports scoping service objects (the actual Java objects which implement 
  your methods) three ways. &quot;Request&quot; scope, the default, will create 
  a new object each time a SOAP request comes in for your service. &quot;Application&quot; 
  scope will create a singleton shared object to service <b>all</b> requests. 
  &quot;Session&quot; scope will create a new object for each session-enabled 
  client who accesses your service. To specify the scope option, you add a &lt;parameter&gt; 
  to your service like this (where &quot;<i><font color="#FF0000">value</font></i>&quot; 
  is request, session, or application):</p>
<pre class="xml">&lt;service name=&quot;MyService&quot;...&gt;
  &lt;parameter name=&quot;scope&quot; value=&quot;<font color="#FF0000"><i>value</i></font>&quot;/&gt;
  ...
&lt;/service&gt;</pre>
<h4>Using the AdminClient</h4>
Once we have this file, we need to send it to an Axis server in order to
actually deploy the described service. We do this with the AdminClient,
or the "org.apache.axis.client.AdminClient" class. An invocation of the
AdminClient looks like this:
<pre class="example">% java org.apache.axis.client.AdminClient deploy.wsdd
&lt;Admin>Done processing&lt;/Admin></pre>
This command has now made our service accessible via SOAP. Check it out
by running the Client class - it should look like this:
<pre class="example">% java samples.userguide.example3.Client "test me!"
You typed : test me!
%</pre>
If you want to prove to yourself that the deployment really worked, try
undeploying the service and calling it again.&nbsp; There's an "undeploy.wsdd"
file in the example3/ directory which you can use just as you did the deploy.wsdd
file above.&nbsp; Run the AdminClient on that file, then try the service
Client again and see what happens.
<p>You can also use the AdminClient to get a listing of all the deployed
components in the server:
<pre class="example">% java org.apache.axis.client.AdminClient list
&lt;big XML document returned here></pre>
In there you'll see services, handlers, transports, etc. Note that this
listing is an exact copy of the server's "server-config.wsdd" file, which
we'll talk about in more detail a little later.
<h4>
More deployment - Handlers and Chains</h4>
Now let's start to explore some of the more powerful features of the Axis
engine. Let's say you want to track how many times your service has been
called. We've included a sample handler in the samples/log directory to
do just this. To use a handler class like this, you first need to deploy
the Handler itself, and then use the name that you give it in deploying
a service. Here's a sample deploy.wsdd file (this is example 4 in samples/userguide):
<pre class="example">&lt;deployment xmlns="http://xml.apache.org/axis/wsdd/"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmlns:java="http://xml.apache.org/axis/wsdd/providers/java">
&nbsp;&nbsp;&lt;!-- define the logging handler configuration -->
&nbsp;&lt;handler name="track" type="java:samples.userguide.example4.LogHandler">
&nbsp; &lt;parameter name="filename" value="MyService.log"/>
&nbsp;&lt;/handler>
&nbsp;
&nbsp;&lt;!-- define the service, using the log handler we just defined -->
&nbsp;&lt;service name="LogTestService"<b> </b>provider="java:RPC">
&nbsp; &lt;requestFlow>
&nbsp;&nbsp; &lt;handler type="track"/>
&nbsp; &lt;/requestFlow>
&nbsp;
&nbsp; &lt;parameter name="className" value="samples.userguide.example4.Service"/>
&nbsp; &lt;parameter name="allowedMethods" value="*"/>
&nbsp;&lt;/service>
&lt;/deployment></pre>
<p>The first section defines a Handler called "track" that is implemented
by the class samples.userguide.example4.LogHandler. We give this Handler
an option to let it know which file to write its messages into.
<p>Then we define a service, LogTestService, which is an RPC service just
like we saw above in our first example. The difference is the &lt;requestFlow>
element inside the &lt;service> - this indicates a set of Handlers that
should be invoked when the service is invoked, before the provider. By
inserting a reference to "track", we ensure that the message will be logged
each time this service is invoked.
<h4>
Remote Administration</h4>
Note that by default, the Axis server is configured to only accept administration
requests from the machine on which it resides - if you wish to enable remote
administration, you must set the "enableRemoteAdmin" property of the AdminService
to <b>true</b>. To do this, find the "server-config.wsdd" file in your
webapp's WEB-INF directory. In it, you'll see a deployment for the AdminService.
Add an option as follows:
<pre class="xml">&lt;service name="AdminService" provider="java:MSG">
&nbsp;&nbsp;&lt;parameter name="className" value="org.apache.axis.util.Admin"/>
&nbsp;&nbsp;&lt;parameter name="allowedMethods" value="*"/>
&nbsp;&nbsp;<b>&lt;parameter name="enableRemoteAdmin" value="true"/>
</b>&lt;/service></pre>
<p><b>WARNING: enabling remote administration may give unauthorized parties
access to your machine. If you do this, please make sure to add security
to your configuration!</b>
<h2>
<a NAME="DataMapping"></a>XML &lt;-> Java Data Mapping in Axis</h2>

<h3>
Encoding Your Beans - the BeanSerializer</h3>
Axis includes the ability to serialize/deserialize, without writing any
code, arbitrary Java classes which follow the standard JavaBean pattern
of get/set accessors. All you need to do is tell Axis which Java classes
map to which XML Schema types. Configuring a bean mapping looks like this:
<pre class="xml">&lt;beanMapping qname="ns:local" xmlns:ns="someNamespace"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; languageSpecificType="java:my.java.thingy"/></pre>
The &lt;beanMapping> tag maps a Java class (presumably a bean) to an XML
QName. You'll note that it has two important attributes, <b>qname</b> and
<b>languageSpecificType</b>.
So in this case, we'd be mapping the "my.java.thingy" class to the XML
QName [someNamespace]:[local].
<p>Let's take a look at how this works in practice. Go look at <a href="../samples/userguide/example5/BeanService.java">samples/userguide/example5/BeanService.java</a>.  The key
thing to notice is that the argument to the service method is an Order
object. Since Order is not a basic type which Axis understands by default,
trying to run this service without a type mapping will result in a fault
(if you want to try this for yourself, you can use the bad-deploy.wsdd
file in the example5 directory). But if we put a beanMapping into our deployment,
all will be well. Here's how to run this example (from the example5 directory):
<pre class="example">% java org.apache.axis.client.AdminClient -llocal:///AdminService deploy.wsdd
&lt;Admin>Done processing&lt;/Admin>

% java samples.userguide.example5.Client -llocal://
Hi, Glen Daniels!

You seem to have ordered the following:

1 of item : mp3jukebox
4 of item : 1600mahBattery

If this had been a real order processing system, we'd probably have charged you about now.
%

</pre>

<h3>
When Beans Are Not Enough - Custom Serialization</h3>
Just as JWS deployment is sometimes not flexible enough to meet all needs,
the default bean serialization model isn't robust enough to handle every
case either. At times there will be non-bean Java classes (especially in
the case of pre-existing assets) which you need to map to/from XML, and
there also may be some custom XML schema types which you want to map into
Java in particular ways. Axis gives you the ability to write custom serializers/deserializers,
and some tools to help make your life easier when you do so.
<p><i><font color="#FF0000">TBD - this section will be expanded in a future
version! For now look at the DataSer/DataDeser 
classes (in samples/encoding).  
Also look at the BeanSerializer, BeanDeserializer, ArraySerializer, ArrayDeserializer and other classes in the org.apache.axis.encoding.ser package.
</font></i>
<h4>
Deploying custom mappings - the &lt;typeMapping> tag</h4>
Now that you've built your serializers and deserializers, you need to tell
Axis which types they should be used for. You do this with a typeMapping
tag in WSDD, which looks like this:
<pre class="xml">&lt;typeMapping qname="ns:local" xmlns:ns="someNamespace"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; languageSpecificType="java:my.java.thingy"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serializer="my.java.Serializer"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deserializer="my.java.DeserializerFactory"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/></pre>
<p>This looks a lot like the &lt;beanMapping> tag we saw earlier, but there
are three extra attributes. One, <b>serializer</b>, is the Java class name
of the Serializer <i>factory</i> which gets the serializer to 
be used to marshal an object of the specified Java class 
(i.e. my.java.thingy) into XML. Two, <b>deserializer</b>, is
the class name of a Deserializer <i>factory</i> that gets the deserializer
to be used to unmarshall XML into the correct Java class.  Finally, the <b>encodingStyle</b>, which is SOAP encoding.
<p>(The &lt;beanMapping> tag is really just shorthand for a &lt;typeMapping> tag 
  with <tt>serializer="org.apache.axis.encoding.ser.BeanSerializerFactory"</tt>,
<tt>deserializer="org.apache.axis.encoding.ser.BeanDeserializerFactory"</tt>, 
  and <tt>encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"</tt>, but clearly it 
  can save a lot of typing!) 
<h2>
<a NAME="WSDL"></a>Using WSDL with Axis</h2>
The <a href="http://www.w3.org/TR/wsdl">Web Service Description Language</a>
is a specification authored by IBM and Microsoft, and supported by many
other organizations. WSDL serves to describe Web Services in a structured
way. A WSDL description of a service tells us, in a machine-understandable
way, the interface to the service, the data types it uses, and where the
service is located. Please see the spec (follow the link in the first sentence)
for details about WSDL's format and options.
<p>Axis supports WSDL in three ways:
<ol>
<li>
When you deploy a service in Axis, users may then access your service's
URL with a standard web browser and by appending "?WSDL" to the end of
the URL, they will obtain an automatically-generated WSDL document which
describes your service.</li>

<li>
We provide a "WSDL2Java" tool which will build Java proxies and skeletons
for services with WSDL descriptions.</li>

<li>
We provide a "Java2WSDL" tool which will build WSDL from Java classes.</li>
</ol>

<h3>
<a NAME="WSDL: Obtaining WSDL for deployed services"></a>?WSDL: Obtaining
WSDL for deployed services</h3>
When you make a service available using Axis, there is typically a unique
URL associated with that service. For JWS files, that URL is simply the
path to the JWS file itself. For non-JWS services, this is usually the
URL "http://&lt;host>/axis/services/&lt;service-name>".
<p>If you access the service URL in a browser, you'll see a message indicating
that the endpoint is an Axis service, and that you should usually access
it using SOAP. However, if you tack on "?wsdl" to the end of the URL, Axis
will automatically generate a service description for the deployed service,
and return it as XML in your browser (try it!). The resulting description
may be saved or used as input to proxy-generation, described next. You
can give the WSDL-generation URL to your online partners, and they'll be
able to use it to access your service with toolkits like .NET, SOAP::Lite,
or any other software which supports using WSDL.
<p>You can also generate WSDL files from existing Java classes (see <a href="#Java2WSDL: Building WSDL from Java">Java2WSDL:
Building WSDL from Java</a>&nbsp;).
<br>&nbsp;
<h3><a NAME="WSDL2Java: Building stubs, skeletons, and data"></a>WSDL2Java:
Building stubs, skeletons, and data types from WSDL</h3>

<h4>Client-side bindings</h4>
<p>You'll find the AXIS WSDL -> Java tool in "org.apache.axis.wsdl.WSDL2Java".
The basic invocation form looks like this:</p>
<pre class="example">
% java org.apache.axis.wsdl.WSDL2Java (WSDL-file-URL)
</pre>

<p>This will generate only those bindings necessary for the client.&nbsp;
AXIS follows the JAX-RPC specification when generating Java client bindings
from WSDL.&nbsp; For this discussion, assume we executed the following:</p>
<pre class="example">
% cd samples/addr
% java org.apache.axis.wsdl.WSDL2Java AddressBook.wsdl
</pre>
<p>The generated files will reside in the directory "AddressFetcher2".&nbsp;
They are put here because that is the target namespace from the WSDL and namespaces map to Java packages.&nbsp;
Namespaces will be discussed in detail later.</p>
<table BORDER COLS=2 WIDTH="100%" >
<tr>
<td><b>WSDL clause</b></td>

<td><b>Java class(es) generated</b></td>
</tr>

<tr>
<td>For each entry in the type section</td>

<td>A java class</td>
</tr>

<tr>
<td></td>

<td>A holder if this type is used as an inout/out parameter</td>
</tr>

<tr>
<td>For each portType</td>

<td>A java interface</td>
</tr>

<tr>
<td>For each binding</td>

<td>A stub class</td>
</tr>

<tr>
<td>For each service</td>

<td>A service interface</td>
</tr>

<tr>
<td></td>

<td>A service implementation (the locator)</td>
</tr>
</table>

<h4>Types</h4>
<p>The Java class generated from a WSDL type will be named from the WSDL type.&nbsp;
This class will typically, though not always, be a bean.&nbsp; For example,
given the WSDL (the WSDL used throughout the WSDL2Java discussion is from
the <a href="../samples/addr/AddressBook.wsdl">Address Book sample</a>):</p>
<pre class="example">
&lt;xsd:complexType name="phone">
&nbsp;&nbsp;&lt;xsd:all>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:element name="areaCode" type="xsd:int"/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:element name="exchange" type="xsd:string"/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:element name="number" type="xsd:string"/>
&nbsp;&nbsp;&lt;/xsd:all>
&lt;/xsd:complexType>
</pre>
<p>WSDL2Java will generate:
<pre class="example">
public class Phone implements java.io.Serializable {
&nbsp;&nbsp;&nbsp;&nbsp;public Phone() {...}
&nbsp;&nbsp;&nbsp;&nbsp;public int getAreaCode() {...}
&nbsp;&nbsp;&nbsp;&nbsp;public void setAreaCode(int areaCode) {...}
&nbsp;&nbsp;&nbsp;&nbsp;public java.lang.String getExchange() {...}
&nbsp;&nbsp;&nbsp;&nbsp;public void setExchange(java.lang.String exchange) {...}
&nbsp;&nbsp;&nbsp;&nbsp;public java.lang.String getNumber() {...}
&nbsp;&nbsp;&nbsp;&nbsp;public void setNumber(java.lang.String number) {...}
&nbsp;&nbsp;&nbsp;&nbsp;public boolean equals(Object obj) {...}
&nbsp;&nbsp;&nbsp;&nbsp;public int hashCode() {...}
}
</pre>
<h4>Mapping XML to Java types : Metadata</h4>
<p>Notice in the mapping above, the XML type name is &quot;phone&quot; and the 
  generated Java class is &quot;Phone&quot; - the capitalization of the first 
  letter has changed to match the Java coding convention that classes begin with 
  an uppercase letter. This sort of thing happens a lot, because the rules for 
  expressing XML names/identifiers are much less restrictive than those for Java. 
  For example, if one of the sub-elements in the &quot;phone&quot; type above 
  was named &quot;new&quot;, we couldn't just generate a Java field called &quot;new&quot;, 
  since that is a reserved word and the resultant source code would fail to compile.</p>
<p>To support this kind of mapping, and also to enable the serialization/deserialization 
  of XML attributes, we have a <b>type metadata</b> system which allows us to 
  associate Java data classes with descriptors which control these things.</p>
<p>When the WSDL2Java tool creates a data bean like the Phone class above, it 
  notices if the schema contains any attributes, or any names which do not map 
  directly to Java field/property names. If it finds any of these things, it will 
  generate a static piece of code to supply a <b>type descriptor</b> for the class. 
  The type descriptor is essentially a collection of <b>field descriptors</b>, 
  each of which maps a Java field/property to an XML element or attribute.</p>
<p>To see an example of this kind of metadata, look at the &quot;test.encoding.AttributeBean&quot; 
  class in the Axis source, or generate your own bean from XML which uses attributes 
  or names which would be illegal in Java.</p>
<h4>Holders</h4>
<p>This type may be used as an inout or out parameter.&nbsp; Java does not
have the concept of inout/out parameters.&nbsp; In order to achieve this
behavior, JAX-RPC specifies the use of holder classes.&nbsp; A holder class
is simply a class that contains an instance of its type.&nbsp; For example,
the holder for the Phone class would be:</p>
<pre class="example">
public final class PhoneHolder implements javax.xml.rpc.holders.Holder {
    public Phone value;

    public PhoneHolder()
    {
    }

    public PhoneHolder(Phone value) {
        this.value = value;
    }
}
</pre>
<p>A holder class is <b>only</b> generated for a type if that type is used as
an inout or out parameter.</p>
<p>The holder classes for the primitive types can be found in javax.xml.rpc.holders.</p>
<h4>PortTypes</h4>
<p>The Service Definition Interface (SDI) is the interface that's derived
from a WSDL's portType.&nbsp; This is the interface you use to access the
operations on the service.&nbsp; For example, given the WSDL:</p>
<pre class="example">
&lt;message name="empty">
&lt;message name="AddEntryRequest">
&nbsp; &lt;part name="name" type="xsd:string"/>
&nbsp; &lt;part name="address" type="typens:address"/>
&lt;/message>
&lt;portType name="AddressBook">
&nbsp; &lt;operation name="addEntry">
&nbsp;&nbsp;&nbsp; &lt;input message="tns:AddEntryRequest"/>
&nbsp;&nbsp;&nbsp; &lt;output message="tns:empty"/>
  &lt;/operation>
&lt;/portType>
</pre>
<p>WSDL2Java will generate:
<pre class="example">
public interface AddressBook extends java.rmi.Remote {
    public void addEntry(String name, Address address) throws java.rmi.RemoteException;
}
</pre>
<p>A note about the name of the SDI.  The name of the SDI is typically the name of the portType.  However, to construct the SDI, WSDL2Java needs information from both the portType <b>and</b> the binding.  (This is unfortunate and is a topic of discussion for WSDL version 2.)
<p>JAX-RPC says (section 4.3.3):  "The name of the Java interface is mapped
from the name attribute of the wsdl:portType element. ... If the mapping to
a service definition interface uses elements of the wsdl:binding ..., then
the name of the service definition interface is mapped from the name of the
wsdel:binding element."
<p>Note the name of the spec.  It contains the string "RPC".  So this spec,
and WSDL2Java, assumes that the interface generated from the portType is an
RPC interface.  If information from the binding tells us otherwise (in
other words, we use elements of the wsdl:binding), then the name of the
interface is derived instead from the binding.
<p>Why?  We could have one portType - pt - and two bindings - bRPC and
bDoc.  Since document/literal changes what the interface looks like, we cannot use a single interface for both of these bindings, so we end up with 2 interfaces - one named pt and another named bDoc - and two stubs - bRPCStub (which implements pt) and bDocStub (which implements bDoc).
<p>Ugly, isn't it?  But you can see why it's necessary.  Since document/literal changes what the interface looks like, and we could have more than one binding referring to a single portType, we have to create more than one interface, and each interface must have a unique name.
<br>&nbsp;
<h4>
Bindings</h4>
A Stub class implements the SDI.&nbsp; Its name is the binding name with
the suffix "Stub".&nbsp; It contains the code which turns the method invocations
into SOAP calls using the Axis Service and Call objects.&nbsp; It stands
in as a <b>proxy</b> (another term for the same idea) for the remote service,
letting you call it exactly as if it were a local object. In other words,
you don't need to deal with the endpoint URL, namespace, or parameter arrays
which are involved in dynamic invocation via the Service and Call objects.
The stub hides all that work for you.
<p>Given the following WSDL snippet:
<pre class="example">&lt;binding name="AddressBookSOAPBinding" type="tns:AddressBook">
&nbsp; ...
&lt;/binding></pre>
<p>WSDL2Java will generate:
<pre class="example">public class AddressBookSOAPBindingStub extends org.apache.axis.client.Stub
                                        implements AddressBook {
&nbsp;&nbsp;&nbsp; public AddressBookSOAPBindingStub() throws org.apache.axis.AxisFault
    {...}

&nbsp;&nbsp;&nbsp; public AddressBookSOAPBindingStub(URL endpointURL, 
                                      javax.xml.rpc.Service service)
        throws org.apache.axis.AxisFault
    {...}
<br>&nbsp;&nbsp;&nbsp; public AddressBookSOAPBindingStub(javax.xml.rpc.Service service)
        throws org.apache.axis.AxisFault
    {...}
<br>&nbsp;&nbsp;&nbsp; public void addEntry(String name, Address address) throws RemoteException
    {...}<br>}</pre>
<h4>
Services</h4>
Normally, a client program would not instantiate a stub directly.&nbsp;
It would instead instantiate a service locator and call a get method which
returns a stub.&nbsp; This locator is derived from the service clause in
the WSDL.&nbsp; WSDL2Java generates two objects from a service clause.&nbsp;
For example, given the WSDL:
<pre class="example">&lt;service name="AddressBookService">
&nbsp; &lt;port name="AddressBook" binding="tns:AddressBookSOAPBinding">
&nbsp;&nbsp;&nbsp; &lt;soap:address location="http://localhost:8080/axis/services/AddressBook"/>
&nbsp; &lt;/port>
&lt;/service></pre>
<p>WSDL2Java will generate the service interface:
<pre class="example">public interface AddressBookService extends javax.xml.rpc.Service {
&nbsp;&nbsp;&nbsp; public String getAddressBookAddress();
<br>&nbsp;&nbsp;&nbsp; public AddressBook getAddressBook() throws javax.xml.rpc.ServiceException;
<br>&nbsp;&nbsp;&nbsp; public AddressBook getAddressBook(URL portAddress) throws javax.xml.rpc.ServiceException;
}</pre>
<p>WSDL2Java will also generate the locator which implements this interface:
<pre class="example">public class AddressBookServiceLocator extends org.apache.axis.client.Service
                                       implements AddressBookService {
&nbsp;&nbsp;&nbsp; ...
}</pre>
<p>The service interface defines a get method for each port listed in the
service element of the WSDL. The locator is the implementation of this
service interface.&nbsp; It implements these get methods. It serves as
a locator for obtaining Stub instances. The Service class will by default
make a Stub which points to the endpoint URL described in the WSDL file,
but you may also specify a different URL when you ask for the PortType.
<p>A typical usage of the stub classes would be as follows:

<pre class="example">public class Tester
{
  &nbsp; public static void main(String [] args) throws Exception {
&nbsp;&nbsp;    &nbsp; // Make a service
    &nbsp;&nbsp;&nbsp; AddressBookService service = new AddressBookServiceLocator();
&nbsp;
&nbsp;&nbsp;&nbsp;     // Now use the service to get a stub which implements the SDI.
    &nbsp;&nbsp;&nbsp; AddressBook port = service.getAddressBook();
&nbsp;
    &nbsp;&nbsp;&nbsp; // Make the actual call
    &nbsp;&nbsp;&nbsp; Address address = new Address(...);
    &nbsp;&nbsp;&nbsp; port.addEntry("Russell Butek", address);
&nbsp;&nbsp;&nbsp; }<br>}</pre>

<h4>
Server-side bindings</h4>
Just as a stub is the client side of a Web Service represented in Java,
a <b>skeleton</b> is a Java framework for the server side.&nbsp; To make
skeleton classes, you just specify the "--server-side --skeletonDeploy true" options
to WSDL2Java.
For instance, using the AddressBook.wsdl as we had above:
<pre class="example">% java org.apache.axis.wsdl.WSDL2Java --server-side --skeletonDeploy true AddressBook.wsdl</pre>
<p>You will see that WSDL2Java generates all the classes that were generated
before for the client, but it generates a few new files:
<br>&nbsp;
<br>&nbsp;
<table BORDER COLS=2 WIDTH="100%" >
<tr>
<td><b>WSDL clause</b></td>

<td><b>Java class(es) generated</b></td>
</tr>

<tr>
<td>For each binding</td>

<td>A skeleton class</td>
</tr>

<tr>
<td></td>

<td>An implementation template class</td>
</tr>

<tr>
<td>For all services</td>

<td>One deploy.wsdd file</td>
</tr>

<tr>
<td></td>

<td>One undeploy.wsdd file</td>
</tr>
</table>

<p>If you don't specify the "--skeletonDeploy true" option, a skeleton will not be
generated.  Instead, the generated deploy.wsdd will indicate that the implementation
class is deployed directly.  In such cases, the deploy.wsdd contains extra meta
data describing the operations and parameters of the implementation class.

Here is how you run WSDL2Java to deploy directly to the implementation:
<pre class="example">% java org.apache.axis.wsdl.WSDL2Java --server-side AddressBook.wsdl</pre>
<p>And here are the server side files that are generated:
<br>&nbsp;
<br>&nbsp;
<table BORDER COLS=2 WIDTH="100%" >
<tr>
<td><b>WSDL clause</b></td>

<td><b>Java class(es) generated</b></td>
</tr>

<tr>
<td>For each binding</td>
<td>An implementation template class</td>

</tr>

<tr>
<td>For all services</td>

<td>One deploy.wsdd file with operation meta data</td>
</tr>

<tr>
<td></td>

<td>One undeploy.wsdd file</td>
</tr>
</table>

<h4>
Bindings</h4>
<h5>
Skeleton Description (for Skeleton Deployment) </h5>
The skeleton class is the class that sits between the AXIS engine and the
actual service implementation.&nbsp; Its name is the binding name with
suffix "Skeleton".&nbsp; For example, for the AddressBook binding, WSDL2Java
will generate:
<pre class="example">public class AddressBookSOAPBindingSkeleton implements AddressBook,
                                                   &nbsp;&nbsp;&nbsp; org.apache.axis.wsdl.Skeleton {
&nbsp;&nbsp;&nbsp; private AddressBook impl;
&nbsp;
&nbsp;&nbsp;&nbsp; public AddressBookSOAPBindingSkeleton() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.impl = new AddressBookSOAPBindingImpl();
&nbsp;&nbsp;&nbsp; }
&nbsp;
&nbsp;&nbsp;&nbsp; public AddressBookSOAPBindingSkeleton(AddressBook impl) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.impl = impl;
&nbsp;&nbsp;&nbsp; }
&nbsp;
&nbsp;&nbsp;&nbsp; public void addEntry(java.lang.String name, Address address)
        throws java.rmi.RemoteException
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; impl.addEntry(name, address);
&nbsp;&nbsp;&nbsp; }
}</pre>
<p>(The real skeleton is actually much richer.&nbsp; For brevity we just show 
  you the basic skeleton.) 
<p>The skeleton contains an implementation of the AddressBook service.&nbsp;
This implementation is either passed into the skeleton on construction,
or an instance of the generated implementation is created.&nbsp; When the
AXIS engine calls the skeleton's addEntry method, it simply delegates the
invocation to the real implementation's addEntry method.
<h5>
Implementation Template Description </h5>
<p>WSDL2Java also generates an implementation template
from the binding:
<pre class="example">public class AddressBookSOAPBindingImpl implements AddressBook {
<br>&nbsp;&nbsp;&nbsp; public void addEntry(String name, Address address)
        throws java.rmi.RemoteException {
&nbsp;&nbsp;&nbsp; }
}</pre>
<p>This template could actually be used as a test implementation but, as
you can see, it doesn't do anything.&nbsp; It is intended that the service
writer fill out the implementation from this template.</p>
<p>When WSDL2Java is asked to generate the implementation template (via the --server-side 
  flag), it will ONLY generate it if it does not already exist.&nbsp; If this 
  implementation already exists, it will not be overwritten.</p>
<h4>Services</h4>
<p>The tool also builds you a "deploy.wsdd" and an "undeploy.wsdd" for each
service for use with the AdminClient. These files may be used to deploy
the service once you've filled in the methods of the Implementation class,
compiled the code, and made the classes available to your Axis engine.</p>
<h3><a NAME="Java2WSDL: Building WSDL from Java"></a>Java2WSDL: Building WSDL
from Java</h3>
The Java2WSDL and WSDL2Java emitters make it easy to develop a new web service.  The following sections describe the steps in building a web service from a Java interface.
<br>&nbsp;
<h4>
Step 1: Provide a Java interface or class</h4>
Write and compile a Java interface (or class) that describes the web service
interface.&nbsp; Here is an example interface that describes a web services
that can be used to set/query the price of widgets (<a href="../samples/userguide/example6/WidgetPrice.java">samples/userguide/example6/WidgetPrice.java</a>):
<pre class="example">package samples.userguide.example6;
<br>/**
&nbsp;* Interface describing a web service to set and get Widget prices.
&nbsp;**/
public interface WidgetPrice {
&nbsp;&nbsp;&nbsp; public void setWidgetPrice(String widgetName, String price);
&nbsp;&nbsp;&nbsp; public String getWidgetPrice(String widgetName);
}</pre>
<p><b>Note: </b>If you compile your class with debug information, Java2WSDL
will use the debug information to obtain the method parameter names.
<h4>
Step 2: Create WSDL using Java2WSDL</h4>
Use the Java2WSDL tool to create a WSDL file from the interface above.
<p>Here is an example invocation that produces the wsdl file (<tt>wp.wsdl</tt>)
from the interface described in the previous section:
<pre class="example">% java org.apache.axis.wsdl.Java2WSDL -o wp.wsdl&nbsp; -l"http://localhost:8080/axis/services/WidgetPrice" -n&nbsp; "urn:Example6"&nbsp;-p"samples.userguide.example6" "urn:Example6"&nbsp; samples.userguide.example6.WidgetPrice</pre>
<p>Where:
<ul>
<li>
-o indicates the name of the <b><i>output WSDL</i></b> file</li>

<li>
-l indicates the<b><i> location of the service</i></b></li>

<li>
-n is the target <b><i>namespace</i></b> of the WSDL file</li>

<li>
-p indicates a mapping from the <b><i>package to a namespace</i></b>.&nbsp;
There may be multiple mappings.</li>

<li>
the class specified contains the interface of the webservice.</li>
</ul>
The output WSDL document will contain the appropriate WSDL types, messages,
portType, bindings and service descriptions to support a SOAP rpc, encoding
web service.&nbsp; If your specified interface methods reference other
classes, the Java2WSDL tool will generate the appropriate xml types to
represent the classes and any nested/inherited types.&nbsp; The tool supports
JAX-RPC complex types (bean classes), extension classes, enumeration classes,
arrays and Holder classes.
<p>The Java2WSDL tool has many additional options which are detailed in the <a href="reference.html#Java2WSDL">reference 
  guide</a>. 
<h4>
Step 3: Create Bindings using WSDL2Java</h4>
Use the generated WSDL file to build the appropriate client/server bindings
for the web service (see <a href="#WSDL2Java: Building stubs, skeletons, and data">WSDL2Java</a>):
<pre class="example">% java org.apache.axis.wsdl.WSDL2Java -o . -d Session -s -S true&nbsp; -Nurn:Example6 samples.userguide.example6 wp.wsdl</pre>
<p>This will generate the following files:
<ul>
  <li> <b><tt>WidgetPriceSoapBindingImpl.java</tt></b> : Java file containing 
    the default server implementation of the WidgetPrice web service.</li>
  <br>
  You will need to modify the *SoapBindingImpl file to add your implementation 
  (see&nbsp; <a href="../samples/userguide/example6/WidgetPriceSoapBindingImpl.java">../samples/userguide/example6/WidgetPriceSoapBindingImpl.java</a> 
  ). 
  <li> <b><tt>WidgetPrice.java</tt></b>:&nbsp; New interface file that contains 
    the appropriate <b><tt>java.rmi.Remote</tt></b> usages.</li>
  <li> <b><tt>WidgetPriceService.java</tt></b>: Java file containing the client 
    side service interface.</li>
  <li> <b><tt>WidgetPriceServiceLocator.java</tt></b>: Java file containing the 
    client side service implementation class.</li>
  <li> <b><tt>WidgetPriceSoapBindingSkeleton.java</tt></b>: Server side skeleton.</li>
  <li> <b><tt>WidgetPriceSoapBindingStub.java</tt></b>: Client side stub.</li>
  <li> <b><tt>deploy.wsdd</tt></b>: Deployment descriptor</li>
  <li> <b><tt>undeploy.wsdd</tt></b>: Undeployment descriptor</li>
  <li> (data types):&nbsp; Java files will be produced for all of the other types 
    and holders necessary for the web service.&nbsp; There are no additional files 
    for the WidgetPrice web service.</li>
</ul>
<p>Now you have all of the necessary files to build your client/server side code 
  and deploy the web service!</p>
<h2>
<a NAME="published interfaces"></a>Published Axis Interfaces</h2>
Although you may use any of the interfaces and classes present in Axis, you need to
be aware that some are more stable than others since there is a continuing
need to refactor Axis to maintain and improve its modularity.
<p>Hence certain interfaces are designated as <i>published</i>, which means
that they are relatively stable. As Axis is refactored, the Axis developers
will try to avoid changing published interfaces unnecessarily and will
certainly consider the impact on users of any modifications.
<p>So if you stick to using only published interfaces, you'll minimise
the pain of migrating between releases of Axis. On the other hand, if you
decide to use unpublished interfaces, migrating between releases could
be an interesting exercise! If you would like an interface to be published,
you should make the case for this on the
<a href="mailto:axis-user@xml.apache.org">axis-user</a>
mailing list.
<p>The current list of published interfaces is as follows:
<ul>
<li>
JAX-RPC interfaces.  At the time of this writing, JAX-RPC is still in the public review stage of its existence, meaning that it may still change.  As it does, the JAX-RPC interfaces may also change.  JAX-RPC is expected to become official some time during the summer of 2002.
<ul>
<li>javax.xml.messaging.Endpoint</li>
<li>javax.xml.messaging.URLEndpoint</li>
<li>javax.xml.rpc.Call</li>
<li>javax.xml.rpc.FaultException</li>
<li>javax.xml.rpc.JAXRPCException</li>
<li>javax.xml.rpc.ParameterMode</li>
<li>javax.xml.rpc.Service</li>
<li>javax.xml.rpc.ServiceException</li>
<li>javax.xml.rpc.ServiceFactory</li>
<li>javax.xml.rpc.Stub</li>
<li>javax.xml.rpc.encoding.DeserializationContext</li>
<li>javax.xml.rpc.encoding.Deserializer</li>
<li>javax.xml.rpc.encoding.DeserializerFactory</li>
<li>javax.xml.rpc.encoding.SerializationContext</li>
<li>javax.xml.rpc.encoding.Serializer</li>
<li>javax.xml.rpc.encoding.SerializerFactory</li>
<li>javax.xml.rpc.encoding.TypeMapping</li>
<li>javax.xml.rpc.encoding.TypeMappingRegistry</li>
<li>javax.xml.rpc.handler.Handler</li>
<li>javax.xml.rpc.handler.HandlerChain</li>
<li>javax.xml.rpc.handler.HandlerInfo</li>
<li>javax.xml.rpc.handler.HandlerRegistry</li>
<li>javax.xml.rpc.handler.MessageContext</li>
<li>javax.xml.rpc.handler.soap.SOAPMessageContext</li>
<li>javax.xml.rpc.holders.BigDecimalHolder</li>
<li>javax.xml.rpc.holders.BigIntegerHolder</li>
<li>javax.xml.rpc.holders.BooleanHolder</li>
<li>javax.xml.rpc.holders.BooleanWrapperHolder</li>
<li>javax.xml.rpc.holders.ByteArrayHolder</li>
<li>javax.xml.rpc.holders.ByteHolder</li>
<li>javax.xml.rpc.holders.ByteWrapperArrayHolder</li>
<li>javax.xml.rpc.holders.ByteWrapperHolder</li>
<li>javax.xml.rpc.holders.CalendarHolder</li>
<li>javax.xml.rpc.holders.DateHolder</li>
<li>javax.xml.rpc.holders.DoubleHolder</li>
<li>javax.xml.rpc.holders.DoubleWrapperHolder</li>
<li>javax.xml.rpc.holders.FloatHolder</li>
<li>javax.xml.rpc.holders.FloatWrapperHolder</li>
<li>javax.xml.rpc.holders.Holder</li>
<li>javax.xml.rpc.holders.IntHolder</li>
<li>javax.xml.rpc.holders.IntegerWrapperHolder</li>
<li>javax.xml.rpc.holders.LongHolder</li>
<li>javax.xml.rpc.holders.LongWrapperHolder</li>
<li>javax.xml.rpc.holders.ObjectHolder</li>
<li>javax.xml.rpc.holders.QNameHolder</li>
<li>javax.xml.rpc.holders.ShortHolder</li>
<li>javax.xml.rpc.holders.ShortWrapperHolder</li>
<li>javax.xml.rpc.holders.StringHolder</li>
<li>javax.xml.rpc.namespace.QName</li>
<li>javax.xml.rpc.server.ServiceLifecycle</li>
<li>javax.xml.rpc.soap.SOAPFault</li>
<li>javax.xml.rpc.soap.SOAPHeaderFault</li>
<li>javax.xml.transform.Source</li>
</ul>
</li>
<li>AXIS interfaces:
<ul>
<li>org.apache.axis.AxisFault</li>
<li>org.apache.axis.Handler</li>
<li>org.apache.axis.DefaultEngineConfigurationFactory</li>
<li>org.apache.axis.EngineConfiguration</li>
<li>org.apache.axis.EngineConfigurationFactory</li>
<li>org.apache.axis.Message</li>
<li>org.apache.axis.MessageContext</li>
<li>org.apache.axis.SOAPPart</li>
<li>org.apache.axis.client.Call</li>
<li>org.apache.axis.client.Service</li>
<li>org.apache.axis.client.ServiceFactory</li>
<li>org.apache.axis.client.Stub</li>
<li>org.apache.axis.client.Transport</li>
<li>org.apache.axis.description.TypeDesc</li>
<li>org.apache.axis.description.AttributeDesc</li>
<li>org.apache.aixs.description.ElementDesc</li>
<li>org.apache.axis.encoding.DeserializationContext</li>
<li>org.apache.axis.encoding.Deserializer</li>
<li>org.apache.axis.encoding.DeserializerFactory</li>
<li>org.apache.axis.encoding.DeserializerTarget</li>
<li>org.apache.axis.encoding.FieldTarget</li>
<li>org.apache.axis.encoding.MethodTarget</li>
<li>org.apache.axis.encoding.SerializationContext</li>
<li>org.apache.axis.encoding.Serializer</li>
<li>org.apache.axis.encoding.SerializerFactory</li>
<li>org.apache.axis.encoding.SimpleType</li>
<li>org.apache.axis.encoding.Target</li>
<li>org.apache.axis.encoding.TypeMapping</li>
<li>org.apache.axis.encoding.TypeMappingRegistry</li>
<li>org.apache.axis.encoding.ser.BaseDeserializerFactory</li>
<li>org.apache.axis.encoding.ser.BaseSerializerFactory</li>
<li>org.apache.axis.encoding.ser.BeanPropertyTarget</li>
<li>org.apache.axis.encoding.ser.SimpleSerializer</li>
<li>org.apache.axis.encoding.ser.SimpleDeserializer</li>
<li>org.apache.axis.session.Session</li>
<li>org.apache.axis.transport.http.SimpleAxisServer</li>
<li>org.apache.axis.utils.BeanProperty</li>
<li>org.apache.axis.wsdl.WSDL2Java</li>
<li>org.apache.axis.wsdl.Java2WSDL</li>
</ul>
</ul>
<h2> <a NAME="tcpmon"></a>Appendix : Using the Axis TCP Monitor (tcpmon)</h2>
The included "tcpmon" utility can be found in the org.apache.axis.utils
package. To run it from the command line:
<pre>% java org.apache.axis.utils.tcpmon [listenPort targetHost targetPort]</pre>
Without any of the optional arguments, you will get a gui which looks like
this:
<center>
<p><img SRC="tcpmon1.jpg" height=599 width=599></center>

<p>To use the program, you should select a local port which tcpmon will
monitor for incoming connections, a target host where it will forward such
connections, and the port number on the target machine which should be
"tunneled" to. Then click "add". You should then notice another tab appearing
in the window for your new tunneled connection. Looking at that panel,
you'll see something like this:
<center>
<p><img SRC="tcpmon2.jpg" height=600 width=599></center>

<p>Now each time a SOAP connection is made to the local port, you will
see the request appear in the "Request" panel, and the response from the
server in the "Response" panel. Tcpmon keeps a log of all request/response
pairs, and allows you to view any particular pair by selecting an entry
in the top panel. You may also remove selected entries, or all of them,
or choose to save to a file for later viewing.
<p>The "resend" button will resend the request you are currently viewing, and 
  record a new response. This is particularly handy in that you can edit the XML 
  in the request window before resending - so you can use this as a great tool 
  for testing the effects of different XML on SOAP servers. Note that you may 
  need to change the content-length HTTP header value before resending an edited 
  request. 
<a NAME="Glossary">
<h2>Glossary</h2></a>

<dl> 
  <dt> <i>Handler</i></dt>
  <dd> A reusable class which is responsible for processing a MessageContext in 
    some custom way. The Axis engine invokes a series of Handlers whenever a request 
    comes in from a client or a transport listener.</dd>
  <dt> <i>SOAP</i></dt>
  <dd> The Simple Object Access Protocol (yes, despite the fact that it sometimes 
    doesn't seem so simple, and doesn't have anything to do with objects... :)). 
    You can read the SOAP 1.1 specification at <a href="http://www.w3.org/TR/SOAP">http://www.w3.org/TR/SOAP</a>. 
    The W3C is currently in the midst of work on SOAP 1.2, under the auspices 
    of the <a href="http://www.w3.org/2000/xp/Group/">XML Protocol Group</a>.</dd>
  <dt> <i>Provider</i></dt>
  <dd> A provider is the &quot;back-end&quot; Handler which is responsible for 
    actually performing the &quot;meat&quot; of the desired SOAP operation. Typically 
    this means calling a method on some back-end service object. The two commonly 
    used providers are RPCProvider and MsgProvider, both in the org.apache.axis.providers.java 
    package.</dd>
  
</dl>

</body>
</html>
