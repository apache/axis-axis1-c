<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.73 [en] (WinNT; U) [Netscape]">
   <title>Axis System Integration Guide</title>
<!-- saved from url=(0022)http://internet.e-mail -->
<style type="text/css">
<!--
.example { background:#ccccff }
.xml { background:#eeeeee }
body {  font-family: Verdana, Arial, Helvetica, sans-serif; margin-left: 40px}
h2 {  text-decoration: underline; background-color: #DCE1FF; background-position: left; margin-left: -30px}
h3 {  margin-left: -10px}
h1 {  margin-left: -30px}
-->
</style>
</head>
<body text="#000000" bgcolor="#FFFFFF">

<center>
<h1>
<img SRC="axis.jpg" height=96 width=176></h1></center>

<h1>
Axis System Integration Guide</h1>
<i>1.0 Version</i>
<h3>
Table of Contents</h3>
<a href="#Introduction">Introduction</a>
<br><a href="#Pluggable APIs">Pluggable APIs</a>
<br>&nbsp; <a href="#System Management Plug">System Management</a>
<br>&nbsp; <a href="#Logging/Tracing Plug">Logging/Tracing</a>
<br>&nbsp; <a href="#Configuration Plug">Configuration</a>
<br>&nbsp; <a href="#Handlers Plug">Handlers</a>
<br>&nbsp; <a href="#Internationalization Plug">Internationalization</a>
<br>&nbsp; <a href="#Performance Monitoring Plug">Performance Monitoring</a>
<br>&nbsp; <a href="#Encoding Plug">Encoding</a>
<br>&nbsp; <a href="#WSDL plug">WSDL Parser and Code Generator Framework</a>
<h2>
<a NAME="Introduction"></a>Introduction</h2>
The primary purpose of this guide is
to present how AXIS can be integrated into an existing web application
server, such as Tomcat or WebSphere, for example.&nbsp; AXIS has a number
of Pluggable APIs that are necessary for such an integration.
<p>
The reader may find useful background information in the
<a href="architecture-guide.html">Architecture Guide</a>.

<h2>
<a NAME="Pluggable APIs"></a>Pluggable APIs</h2>
The following are the points that are pluggable in order to integrate AXIS
into a web application server.
<h3>
<a NAME="System Management Plug"></a>System Management</h3>
What points are necessary to manage AXIS?
<ul>
<li>
Justification/Rationale - why is this plug point necessary?&nbsp; Spec
compliance?</li>

<li>
Interfaces</li>

<li>
Mechanism</li>

<ul>
<li>
Life cycle</li>

<li>
Exception handling - in general; plug-in shouldn't throw any exceptions
- does runtime ignore? Log?)</li>

<li>
Multiple thread support?&nbsp; Ie., is synchronization required?</li>
</ul>

<li>
Configuration/reconfiguration</li>

<li>
Default behavior if not plugged.</li>

<li>
Example</li>
</ul>

<h3><a NAME="Logging/Tracing Plug"></a>Logging/Tracing</h3>
AXIS logging and tracing is based on the Logging component of the
<a href="http://jakarta.apache.org/commons/index.html">Jakarta Commons</a>
project, or the Jakarta Commons Logging (JCL) SPI.
The JCL provides a Log interface with thin-wrapper implementations for
other logging tools, including
<a href="http://jakarta.apache.org/log4j/docs/index.html">Log4J</a>,
<a href="http://jakarta.apache.org/avalon/logkit/index.html">Avalon LogKit</a>,
and
<a>JDK 1.4</a>.
The interface maps closely to Log4J and LogKit.

<h4>Justification/Rationale</h4>
A pluggable logging/trace facility enables
AXIS to direct logging/trace messages to a host web application server's
logging facility.
A central logging facility with a single point of configuration/control
is superior to distinct logging mechanisms for each of a multitude of
middleware components that are to be integrated into
a web application server.

<h4>Integration</h4>
The minimum requirement to integrate with another logger
is to provide an implementation of the
<code>org.apache.commons.logging.Log</code> interface.
In addition, an implementation of the
<code>org.apache.commons.logging.LogFactory</code> interface
can be provided to meet
specific requirements for connecting to, or instantiating, a logger.
<ul>
<li><h5>org.apache.commons.logging.Log</h5></li>
The <code>Log</code> interface defines the following methods for use
in writing log/trace messages to the log:
<ul>
<code>
<br>log.fatal(Object message);
<br>log.fatal(Object message, Throwable t);
<br>log.error(Object message);
<br>log.error(Object message, Throwable t);
<br>log.warn(Object message);
<br>log.warn(Object message, Throwable t);
<br>log.info(Object message);
<br>log.info(Object message, Throwable t);
<br>log.debug(Object message);
<br>log.debug(Object message, Throwable t);
<br>log.trace(Object message);
<br>log.trace(Object message, Throwable t);
<br>&nbsp;
<br>log.isFatalEnabled();
<br>log.isErrorEnabled();
<br>log.isWarnEnabled();
<br>log.isInfoEnabled();
<br>log.isDebugEnabled();
<br>log.isTraceEnabled();
<br>
</code>
</ul>
<p>
Semantics for these methods are such that it is expected
that the severity of messages is ordered, from highest to lowest:
<p>
<ul>
<li>fatal - Consider logging to console and system log.</li>
<li>error - Consider logging to console and system log.</li>
<li>warn - Consider logging to console and system log.</li>
<li>info - Consider logging to console and system log.</li>
<li>debug - Log to system log, if enabled.</li>
<li>trace - Log to system log, if enabled.</li>
</ul>

<br>&nbsp;
<li><h5>org.apache.commons.logging.LogFactory</h5></li>
If desired, the default implementation of the
<code>org.apache.commons.logging.LogFactory</code>
interface can be overridden,
allowing the JDK 1.3 Service Provider discovery process
to locate and create a LogFactory specific to the needs of the application.
Review the Javadoc for the <code>LogFactoryImpl.java</code>
for details.
</ul>

<h4>Mechanism</h4>
<ul>
<li><h5>Life cycle</h5></li>
The JCL LogFactory implementation must assume responsibility for
either connecting/disconnecting to a logging toolkit,
or instantiating/initializing/destroying a logging toolkit.
<br>&nbsp;
<li><h5>Exception handling</h5></li>
The JCL Log interface doesn't specify any exceptions to be handled,
the implementation must catch any exceptions.
<br>&nbsp;
<li><h5>Multiple threads</h5></li>
The JCL Log and LogFactory implementations must ensure
that any synchronization required by the logging toolkit
is met.
</ul>

<h4>Logger Configuration</h4>
<ul>
<li><h5>Log</h5></li>
The default <code>LogFactory</code> provided by JCL
can be configured to instantiate a specific implementation of the
<code>org.apache.commons.logging.Log</code> interface
by setting the property <code>org.apache.commons.logging.Log</code>.
This property can be specified as a system property,
or in the <code>commons-logging.properties</code> file,
which must exist in the CLASSPATH.
<br>&nbsp;
<li><h5>Default logger if not plugged</h5></li>
The Jakarta Commons Logging SPI uses the
implementation of the <code>org.apache.commons.logging.Log</code>
interface specified by the system property
<code>org.apache.commons.logging.Log</code>.
If the property is not specified or the class is not available then the JCL
provides access to a default logging toolkit by searching the CLASSPATH
for the following toolkits, in order of preference:
<ul>
<li><a href="http://jakarta.apache.org/log4j/docs/index.html">Log4J</a></li>
<li>JDK 1.4</li>
<li>JCL SimpleLog</li>
</ul>
</ul>

<h3>
<a NAME="Configuration Plug"></a>Configuration</h3>
How can AXIS fit into existing configuration systems?
<ul>
<li>
Justification/Rationale - why is this plug point necessary?&nbsp; Spec
compliance?</li>

<li>
Interfaces</li>

<li>
Mechanism</li>

<ul>
<li>
Life cycle</li>

<li>
Exception handling - in general; plug-in shouldn't throw any exceptions
- does runtime ignore? Log?)</li>

<li>
Multiple thread support?&nbsp; Ie., is synchronization required?</li>
</ul>

<li>
Configuration/reconfiguration</li>

<li>
Default behavior if not plugged.</li>

<li>
Example</li>
</ul>

<h3>
<a NAME="Handlers Plug"></a>Handlers</h3>
What new handlers might a system integrator wish to implement?
<ul>
<li>
Justification/Rationale - why is this plug point necessary?&nbsp; Spec
compliance?</li>

<li>
Interfaces</li>

<li>
Mechanism</li>

<ul>
<li>
Life cycle</li>

<li>
Exception handling - in general; plug-in shouldn't throw any exceptions
- does runtime ignore? Log?)</li>

<li>
Multiple thread support?&nbsp; Ie., is synchronization required?</li>
</ul>

<li>
Configuration/reconfiguration</li>

<li>
Default behavior if not plugged.</li>

<li>
Example</li>
</ul>

<h3>
<a NAME="Internationalization Plug"></a>Internationalization</h3>
The plug point for internationalization isn't a framework, but simply a
property file of the strings used in AXIS.
<br>&nbsp;
<ul>
<li>
Justification/Rationale</li>

<br>In order for readers of languages other than English to be comfortable
with AXIS, we provide a mechanism for the strings used in AXIS to be translated.&nbsp;
We do not provide any translations in AXIS; we merely provide a means by
which translators can easily plug in their translations.
<br>&nbsp;
<li>
Interfaces</li>

<br>AXIS uses the standard Java internationalization class:&nbsp; <font face="Courier New,Courier"><font size=-1>PropertyResourceBundle</font></font>.&nbsp;
To make this class easy to use, there are a number of methods on JavaUtils
that are used to get the messages within the resource bundle.
<p><font face="Courier New,Courier"><font size=-1>public static java.util.ResourceBundle
getMessageResourceBundle();</font></font>
<p><font face="Courier New,Courier"><font size=-1>public static String
getMessage(String key) throws java.util.MissingResourceException;</font></font>
<p><font face="Courier New,Courier"><font size=-1>public static String
getMessage(String key, String var) throws java.util.MissingResourceException;</font></font>
<p><font face="Courier New,Courier"><font size=-1>public static String
getMessage(String key, String var1, String var2) throws java.util.MissingResourceException;</font></font>
<p><font face="Courier New,Courier"><font size=-1>public static String
getMessage(String key, String[] vars) throws java.util.MissingResourceException;</font></font>
<p>AXIS programmers can work with the resource bundle directly via a call
to <font face="Courier New,Courier"><font size=-1>JavaUtils.getMessageResourceBundle</font></font>,
but the <font face="Courier New,Courier"><font size=-1>getMessage</font></font>
methods should be used instead for two reasons:
<br>&nbsp;
<ol>
<li>
It's a shortcut.&nbsp; It is cleaner to call</li>

<ol><font face="Courier New,Courier"><font size=-1>JavaUtils.getMessage("myMsg00");</font></font></ol>
than
<ol><font face="Courier New,Courier"><font size=-1>JavaUtils.getMessageResourceBundle().getString("myMsg00");</font></font></ol>

<li>
The <font face="Courier New,Courier"><font size=-1>getMessage</font></font>
methods enable messages with variables.</li>
</ol>

<h4>
The getMessage methods</h4>
If you have a message with no variables
<ol><font face="Courier New,Courier"><font size=-1>myMsg00=This is a string.</font></font></ol>
then simply call
<ol><font face="Courier New,Courier"><font size=-1>JavaUtils.getMessage("myMsg00");</font></font></ol>

<p><br>If you have a message with variables, use the syntax <font face="Courier New,Courier">"{X}"</font>
where <font face="Courier New,Courier"><font size=-1>X</font></font> is
the number of the variable, starting at 0.&nbsp; For example:
<ol><font face="Courier New,Courier"><font size=-1>myMsg00=My {0} is {1}.</font></font></ol>
then call:
<ol><font face="Courier New,Courier"><font size=-1>JavaUtils.getMessage("myMsg00",
"name", "Russell");</font></font></ol>
and the resulting string will be:&nbsp; "My name is Russell."
<p>You could also call the String array version of <font face="Courier New,Courier"><font size=-1>getMessage</font></font>:
<ol><font face="Courier New,Courier"><font size=-1>JavaUtils.getMessage("myMsg00",
new String[] {"name", "Russell"});</font></font></ol>

<p><br>The String array version of <font face="Courier New,Courier"><font size=-1>getMessage</font></font>
is all that is necessary, but the vast majority of messages will have 0,
1 or 2 variables, so the other <font face="Courier New,Courier"><font size=-1>getMessage</font></font>
methods are provided as a convenience to avoid the complexity of the String
array version.
<p>Note that the <font face="Courier New,Courier"><font size=-1>getMessage</font></font>
methods throw <font face="Courier New,Courier"><font size=-1>MissingResourceException</font></font>
if the resource cannot be found.&nbsp; And ParseException if there are
more {X} entries than arguments.&nbsp; These exceptions are <font face="Courier New,Courier"><font size=-1>RuntimeException'</font></font>s,
so the caller doesn't have to explicitly catch them.
<p>The resource bundle properties file is org/apache/axis/utils/axisNLS.properties.
<br>&nbsp;
<li>
Mechanism</li>

<br>The Java internationalization mechanism - i.e., a ResourceBundle backed
by a properties file - and the java.text.MessageFormat class, are sufficient
for our needs.
<p>Entries in the properties file must follow the pattern:&nbsp; <font face="Courier New,Courier"><font size=-1>&lt;string>&lt;2-digit
suffix></font></font>.
<p>Entries should be ordered in the properties file alphabetically by key.
<p>Entries in the properties file must never be changed.&nbsp; If a code
change requires a message change, don't change the existing message; instead
create a new entry, incrementing the 2-digit suffix.&nbsp; This must be
done for two reasons:&nbsp; 1.&nbsp; You don't know whether the message
is being used elsewhere.&nbsp; 2.&nbsp; So the translator only has to be
aware of, and translate, the new strings.&nbsp; Without this restriction,
every time translators are given the properties file to translate, they
would have to translate all strings all the time.
<ul>&nbsp;</ul>
We may occasionally want to trim the properties file of old data, but this
should only be done on major releases.
<ul>&nbsp;</ul>

<li>
Default behavior</li>

<br>The default behavior, meaning what happens when a translated file doesn't
exist for a given locale, is to fall back on the English-language properties
file.&nbsp; If that file doesn't exist (unlikely unless something is seriously
wrong), AXIS with throw an exception with an English-language reason message.
<br>&nbsp;
<li>
Examples</li>

<br>In <font face="Courier New,Courier"><font size=-1>org.apache.axis.client.Call.invoke</font></font>,
there is the following statement:
<p><font face="Courier New,Courier"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if ( operationName == null )</font></font>
<br><font face="Courier New,Courier"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
throw new AxisFault( "No operation name specified" );</font></font>
<p>We will have to add an entry into org/apache/axis/utils/axisNLS.properties.&nbsp;
Something like:
<p><font face="Courier New,Courier"><font size=-1>noOperation=No operation
name specified.</font></font>
<p>And change the code to read:
<p><font face="Courier New,Courier"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if ( operationName == null )</font></font>
<br><font face="Courier New,Courier"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
throw new AxisFault(JavaUtils.getMessage("noOperation"));</font></font></ul>

<h3>
<a NAME="Performance Monitoring Plug"></a>Performance Monitoring</h3>
How can we monitor the performance of AXIS?
<ul>
<li>
Justification/Rationale - why is this plug point necessary?&nbsp; Spec
compliance?</li>

<li>
Interfaces</li>

<li>
Mechanism</li>

<ul>
<li>
Life cycle</li>

<li>
Exception handling - in general; plug-in shouldn't throw any exceptions
- does runtime ignore? Log?)</li>

<li>
Multiple thread support?&nbsp; Ie., is synchronization required?</li>
</ul>

<li>
Configuration/reconfiguration</li>

<li>
Default behavior if not plugged.</li>

<li>
Example</li>
</ul>

<h3>
<a NAME="Encoding Plug"></a>Encoding</h3>
How can a system integrator plug in other encoding mechanisms such as SOAP
1.2 or optimized XML-based encoding?
<ul>
<li>
Justification/Rationale - why is this plug point necessary?&nbsp; Spec
compliance?</li>

<li>
Interfaces</li>

<li>
Mechanism</li>

<ul>
<li>
Life cycle</li>

<li>
Exception handling - in general; plug-in shouldn't throw any exceptions
- does runtime ignore? Log?)</li>

<li>
Multiple thread support?&nbsp; Ie., is synchronization required?</li>
</ul>

<li>
Configuration/reconfiguration</li>

<li>
Default behavior if not plugged.</li>

<li>
Example</li>
</ul>

<h3>
<a NAME="WSDL plug"></a>WSDL Parser and Code Generator Framework</h3>
WSDL2Java is AXIS's tool to generate Java artifacts from WSDL.&nbsp; This
tool is extensible.&nbsp; If users of AXIS wish to extend AXIS, then they
may also need to extend or change the generated artifacts.&nbsp; For example,
if AXIS is inserted into some product which has an existing deployment
model that's different than AXIS's deployment model, then that product's
version of WSDL2Java will be required to generate deployment descriptors
other than AXIS's deploy.wsdd.
<p>What follows immediately is a description of the framework.&nbsp; If
you would rather dive down into the dirt of <a href="#WSDL Examples">examples</a>,
you could learn a good deal just from them.&nbsp; Then you could come back
up here and learn the gory details.
<p>There are three parts to WSDL2Java:
<ol>
<li>
The symbol table</li>

<li>
The parser front end with a generator framework</li>

<li>
The code generator back end (WSDL2Java itself)</li>
</ol>

<h4>
Symbol Table</h4>
The symbol table, found in org.apache.axis.wsdl.symbolTable, will contain
all the symbols from a WSDL document, both the symbols from the WSDL constructs
themselves (portType, binding, etc), and also the XML schema types that
the WSDL refers to.
<p><font color="#FF0000">NOTE:&nbsp; Needs lots of description here.</font>
<p>The symbol table is not extensible, but you <b>can</b> add fields to
it by using the Dynamic Variables construct:
<ul>
<li>
You must have some constant object for a dynamic variable key.&nbsp; For
example:&nbsp; public static final String MY_KEY = "my key";</li>

<li>
You set the value of the variable in your GeneratorFactory.generatorPass:&nbsp;
entry.setDynamicVar(MY_KEY, myValue);</li>

<li>
You get the value of the variable in your generators:&nbsp; Object myValue
= entry.getDynamicVar(MY_KEY);</li>
</ul>

<h4>
Parser Front End and Generator Framework</h4>
The parser front end and generator framework is located in org.apache.axis.wsdl.gen.&nbsp;
The parser front end consists of two files:
<ul>
<li>
Parser</li>

<br><tt>public class Parser {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public Parser();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public boolean isDebug();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void setDebug(boolean);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public boolean isImports();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void setImports(boolean);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public boolean isVerbose();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void setVerbose(boolean);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public long getTimeout();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void setTimeout(long);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public java.lang.String getUsername();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void setUsername(java.lang.String);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public java.lang.String getPassword();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void setPassword(java.lang.String);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public GeneratorFactory getFactory();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void setFactory(GeneratorFactory);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public org.apache.axis.wsdl.symbolTable.SymbolTable
getSymbolTable();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public javax.wsdl.Definition getCurrentDefinition();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public java.lang.String getWSDLURI();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void run(String wsdl) throws java.lang.Exception;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void run(String context, org.w3c.dom.Document
wsdlDoc) throws java.io.IOException, javax.wsdl.WSDLException;</tt>
<br><tt>}</tt>
<p>The basic behavior of this class is simple:&nbsp; you instantiate a
Parser, then you run it.
<ul><tt>Parser parser = new Parser();</tt>
<br><tt>parser.run("myfile.wsdl");</tt></ul>

<p><br>There are various options on the parser that have accessor methods:
<ul>
<li>
debug - default is false - dump the symbol table after the WSDL file has
been parsed</li>

<li>
imports - default is true - should imported files be visited?</li>

<li>
verbose - default is false - list each file as it is being parsed</li>

<li>
timeout - default is 45 - the number of seconds to wait before halting
the parse</li>

<li>
username - no default - needed for protected URI's</li>

<li>
password - no default - needed for protected URI's</li>
</ul>

<p><br>Other miscellaneous methods on the parser:
<ul>
<li>
get/setFactory - get or set the GeneratorFactory on this parser - see below
for details.&nbsp; The default generator factory is NoopFactory, which
generates nothing.</li>

<li>
getSymbolTable - once a run method is called, the symbol table will be
populated and can get queried.</li>

<li>
getCurrentDefinition - once a run method is called, the parser will contain
a Definition object which represents the given wsdl file.&nbsp; Definition
is a WSDL4J object.</li>

<li>
getWSDLURI - once the run method which takes a string is called, the parser
will contain the string representing the location of the WSDL file.&nbsp;
Note that the other run method - run(String context, Document wsdlDoc)
- does not provide a location for the wsdl file.&nbsp; If this run method
is used, getWSDLURI will be null.</li>

<li>
There are two run methods.&nbsp; The first, as shown above, takes a URI
string which represents the location of the WSDL file.&nbsp; If you've
already parsed the WSDL file into an XML Document, then you can use the
second run method, which takes a context and the WSDL Document.</li>
</ul>

<p><br>An extension of this class would ...
<br><br>
<font color="#FF0000">NOTE:&nbsp; continue this sentiment...</font>
<br>&nbsp;
<li>
WSDL2</li>

<br>Parser is the programmatic interface into the WSDL parser.&nbsp; WSDL2
is the command line tool for the parser.&nbsp; It provides an extensible
framework for calling the Parser from the command line.&nbsp; It is named
WSDL2 because extensions of it will likely begin with WSDL2:&nbsp; <b>WSDL2</b>Java,
<b>WSDL2</b>Lisp, <b>WSDL2</b>XXX.
<p><tt>public class WSDL2 {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected WSDL2();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected Parser createParser();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected Parser getParser();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected void addOptions(org.apache.axis.utils.CLOptionDescriptor[]);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected void parseOption(org.apache.axis.utils.CLOption);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected void validateOptions();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected void printUsage();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected void run(String[]);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public static void main(String[]);</tt>
<br><tt>}</tt>
<p>Like all good command line tools, it has a main method.&nbsp; Unlike
some command line tools, however, its methods are not static.&nbsp; Static
methods are not extensible.&nbsp; WSDL2's main method constructs an instance
of itself and calls methods on that instance rather than calling static
methods.&nbsp; These methods follow a behavior pattern.&nbsp; The main
method is very simple:
<br>&nbsp;
<ul><tt>&nbsp;&nbsp;&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WSDL2 wsdl2 = new WSDL2();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wsdl2.run(args);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt></ul>

<p><br>The constructor calls createParser to construct a Parser or an extension
of Parser.
<p>run calls:
<ul>
<li>
parseOption to parse each command line option and call the appropriate
Parser accessor.&nbsp; For example, when this method parses --verbose,
it calls parser.setVerbose(true)</li>

<li>
validateOptions to make sure all the option values are consistent</li>

<li>
printUsage if the usage of the tool is in error</li>

<li>
parser.run(args);</li>
</ul>

<p><br>If an extension has additional options, then it is expected to call
addOptions before calling run.&nbsp; So extensions will call, as necessary,
getParser, addOptions, run.&nbsp; Extensions will override, as necessary,
createParser, parseOption, validateOptions, printUsage.
<br>&nbsp;
<p>The generator framework consists of 2 files:
<ul>
<li>
Generator</li>

<br>The Generator interface is very simple.&nbsp; It just defines a generate
method.
<p><tt>public interface Generator</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void generate() throws java.io.IOException;</tt>
<br><tt>}</tt>
<br>&nbsp;
<li>
GeneratorFactory</li>

<p><br><tt>public interface GeneratorFactory</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void generatorPass(javax.wsdl.Definition,
SymbolTable);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public Generator getGenerator(javax.wsdl.Message,
SymbolTable);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public Generator getGenerator(javax.wsdl.PortType,
SymbolTable);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public Generator getGenerator(javax.wsdl.Binding,
SymbolTable);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public Generator getGenerator(javax.wsdl.Service,
SymbolTable);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public Generator getGenerator(TypeEntry, SymbolTable);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public Generator getGenerator(javax.wsdl.Definition,
SymbolTable);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void setBaseTypeMapping(BaseTypeMapping);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public BaseTypeMapping getBaseTypeMapping();</tt>
<br><tt>}</tt>
<p>The GeneratorFactory interface defines a set of methods that the parser
uses to get generators.&nbsp; There should be a generator for each of the
WSDL constructs (message, portType, etc - note that these depend on the
WSDL4J classes:&nbsp; javax.xml.Message, javax.xml.PortType, etc); a generator
for schema types; and a generator for the WSDL Definition itself.&nbsp;
This last generator is used to generate anything that doesn't fit into
the previous categories
<p>In addition to the getGeneratorMethods, the GeneratorFactory defines
a generatorPass method which provides the factory implementation a chance
to walk through the symbol table to do any preprocessing before the actual
generation begins.
<p>Accessors for the base type mapping are also defined.&nbsp; These are
used to translate QNames to base types in the given target mapping.
<br>&nbsp;</ul>
In addition to Parser, WSDL2, Generator, and GeneratorFactory, the org.apache.axis.wsdl.gen
package also contains a couple of no-op classes:&nbsp; NoopGenerator and
NoopFactory.&nbsp; NoopGenerator is a convenience class for extensions
that do not need to generate artifacts for every WSDL construct.&nbsp;
For example, WSDL2Java does not generate anything for messages, therefore
its factory's getGenerator(Message, SymbolTable) method returns an instance
of NoopGenerator.&nbsp; NoopFactory returns a NoopGenerator for all getGenerator
methods.&nbsp; The default factory for Parser is the NoopFactory.</ul>

<h4>
Code Generator Back End</h4>
The meat of the WSDL2Java back end generators is in org.apache.axis.wsdl.toJava.&nbsp;
Emitter extends Parser.&nbsp; org.apache.axis.wsdl.WSDL2Java extends WSDL2.&nbsp;
JavaGeneratorFactory implements GeneratorFactory.&nbsp; And the various
JavaXXXWriter classes implement the Generator interface.
<p><font color="#FF0000">NOTE:&nbsp; Need lots more description here...</font>
<h4>
<a NAME="WSDL Examples"></a>WSDL Framework Extension Examples</h4>
Everything above sounds rather complex.&nbsp; It is, but that doesn't mean
your extension has to be.
<h5>
Example 1 - Simple extension of WSDL2Java - additional artifact</h5>
The simplest extension of the framework is one which generates everything
that WSDL2Java already generates, plus something new.&nbsp; Example 1 is
such an extension.&nbsp; It's extra artifact is a file for each service
that lists that service's ports.&nbsp; I don't know why you'd want to do
this, but it makes for a good, simple example.&nbsp; See samples/integrationGuide/example1
for the complete implementation of this example.
<br>&nbsp;
<ul>
<li>
First you must create your writer that writes the new artifact.&nbsp; This
new class extends org.apache.axis.wsdl.toJava.JavaWriter.&nbsp; JavaWriter
dictates behavior to its extensions; it calls writeFileHeader and writeFileBody.&nbsp;
Since we don't care about a file header for this example, writeFileHeader
is a no-op method.&nbsp; writeFileBody does the real work of this writer.</li>

<p><br><tt>public class MyListPortsWriter extends JavaWriter {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; private Service service;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public MyListPortsWriter(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Emitter emitter,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ServiceEntry sEntry,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SymbolTable symbolTable) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(emitter,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new QName(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sEntry.getQName().getNamespaceURI(),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sEntry.getQName().getLocalPart() + "Lst"),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"", "lst", "Generating service port list file", "service list");</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.service = sEntry.getService();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected void writeFileHeader() throws IOException
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected void writeFileBody() throws IOException
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map portMap = service.getPorts();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator portIterator
= portMap.values().iterator();</tt><tt></tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (portIterator.hasNext())
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Port p = (Port) portIterator.next();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pw.println(p.getName());</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pw.close();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
<li>
Then you need a main program.&nbsp; This main program extends WSDL2Java
so that it gets all the functionality of that tool.&nbsp; The main of this
tool does 3 things:</li>

<ul>
<li>
instantiates itself</li>

<li>
adds MyListPortsWriter to the list of generators for a WSDL service</li>

<li>
calls the run method.</li>
</ul>
That's it!&nbsp; The base tool does all the rest of the work.
<p><tt>public class MyWSDL2Java extends WSDL2Java {</tt><tt></tt>
<p><tt>&nbsp;&nbsp;&nbsp; public static void main(String args[]) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyWSDL2Java myWSDL2Java
= new MyWSDL2Java();</tt><tt></tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JavaGeneratorFactory
factory =</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(JavaGeneratorFactory) myWSDL2Java.getParser().getFactory();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; factory.addGenerator(Service.class,
MyListPortsWriter.class);</tt><tt></tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myWSDL2Java.run(args);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt></ul>

<h5>
Example 2 - Not quite as simple an extension of WSDL2Java - change an artifact</h5>
In this example, we'll replace deploy.wsdd with mydeploy.useless.&nbsp;
For brevity, mydeploy.useless is rather useless.&nbsp; Making it useful
is an exercise left to the reader.&nbsp; See samples/integrationGuide/example2
for the complete implementation of this example.
<ul>
<li>
First, here is the writer for the mydeploy.useless.&nbsp; This new class
extends org.apache.axis.wsdl.toJava.JavaWriter.&nbsp; JavaWriter dictates
behavior to its extensions; it calls writeFileHeader and writeFileBody.&nbsp;
Since we don't care about a file header for this example, writeFileHeader
is a no-op method.&nbsp; writeFileBody does the real work of this writer.&nbsp;
It simply writes a bit of a song, depending on user input.</li>

<p><br>Note that we've also overridden the generate method.&nbsp; The parser
always calls generate, but since this is a server-side artifact, we don't
want to generate it unless we are generating server-side artifacts (in
other words, in terms of the command line options, we've specified the
--serverSide option).
<p><tt>public class MyDeployWriter extends JavaWriter {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public MyDeployWriter(Emitter emitter, Definition
definition,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SymbolTable symbolTable) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(emitter,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new QName(definition.getTargetNamespace(), "deploy"),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"", "useless", "Generating deploy.useless", "deploy");</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void generate() throws IOException {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (emitter.isServerSide())
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
super.generate();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected void writeFileHeader() throws IOException
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected void writeFileBody() throws IOException
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyEmitter myEmitter
= (MyEmitter) emitter;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (myEmitter.getSong()
== MyEmitter.RUM) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pw.println("Yo!&nbsp; Ho!&nbsp; Ho!&nbsp; And a bottle of rum.");</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (myEmitter.getSong()
== MyEmitter.WORK) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pw.println("Hi ho!&nbsp; Hi ho!&nbsp; It's off to work we go.");</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pw.println("Feelings...&nbsp; Nothing more than feelings...");</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pw.close();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><tt></tt>&nbsp;
<li>
Since we're changing what WSDL2Java generates, rather than simply adding
to it like the previous example did, calling addGenerator isn't good enough.&nbsp;
In order to change what WSDL2Java generates, you have to create a generator
factory and provide your own generators.&nbsp; Since we want to keep most
of WSDL2Java's artifacts, we can simply extend WSDL2Java's factory - JavaGeneratorFactory
- and override the addDefinitionGenerators method.</li>

<p><br><tt>public class MyGeneratorFactory extends JavaGeneratorFactory
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected void addDefinitionGenerators() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addGenerator(Definition.class,
JavaDefinitionWriter.class); // WSDL2Java's JavaDefinitionWriter</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addGenerator(Definition.class,
MyDeployWriter.class); // our DeployWriter</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addGenerator(Definition.class,
JavaUndeployWriter.class); // WSDL2Java's JavaUndeployWriter</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
<li>
Now we must write the API's to our tool.&nbsp; Since we've added an option
- song - we need both the programmatic API - an extension of Parser (actually
Emitter in this case since we're extending WSDL2Java and Emitter is WSDL2Java's
parser extension) - and the command line API.</li>

<p><br>Here is our programmatic API.&nbsp; It adds song accessors to Emitter.&nbsp;
It also, in the constructor, lets the factory know about the emitter and
the emitter know about the factory.
<p><tt>public class MyEmitter extends Emitter {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public static final int RUM&nbsp; = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public static final int WORK = 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; private int song = -1;</tt><tt></tt>
<p><tt>&nbsp;&nbsp;&nbsp; public MyEmitter() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyGeneratorFactory factory
= new MyGeneratorFactory();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setFactory(factory);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; factory.setEmitter(this);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public int getSong() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return song;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void setSong(int song) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.song = song;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<p>And here is our command line API.&nbsp; It's a bit more complex that
our previous example's main program, but it does 2 extra things:
<ol>
<li>
accept a new command line option:&nbsp; --song rum|work (this is the biggest
chunk of the new work).</li>

<li>
create a new subclass of Parser</li>
</ol>

<p><br><tt>public class WSDL2Useless extends WSDL2Java {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected static final int SONG_OPT = 'g';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected static final CLOptionDescriptor[]
options = new CLOptionDescriptor[]{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new CLOptionDescriptor("song",</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
CLOptionDescriptor.ARGUMENT_REQUIRED,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SONG_OPT,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Choose a song for deploy.useless:&nbsp; work or rum")</tt>
<br><tt>&nbsp;&nbsp;&nbsp; };</tt><tt></tt>
<p><tt>&nbsp;&nbsp;&nbsp; public WSDL2Useless() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addOptions(options);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected Parser createParser() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new MyEmitter();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; protected void parseOption(CLOption option)
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (option.getId() ==
SONG_OPT) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
String arg = option.getArgument();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (arg.equals("rum")) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((MyEmitter) parser).setSong(MyEmitter.RUM);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else if (arg.equals("work")) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((MyEmitter) parser).setSong(MyEmitter.WORK);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
super.parseOption(option);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public static void main(String args[]) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WSDL2Useless useless
= new WSDL2Useless();</tt><tt></tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; useless.run(args);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<p>Let's go through this one method at a time.
<ul>
<li>
constructor - this constructor adds the new option --song rum|work.&nbsp;
(the abbreviated version of this option is "-g", rather an odd abbreviation,
but "-s" is the abbreviation for --serverSide and "-S" is the abbreviation
for --skeletonDeploy.&nbsp; Bummer.&nbsp; I just picked some other letter.</li>

<li>
createParser - we've got to provide a means by which the parent class can
get our Parser extension.</li>

<li>
parseOption - this method processes our new option.&nbsp; If the given
option isn't ours, just let super.parseOption do its work.</li>

<li>
main - this main is actually simpler than the first example's main.&nbsp;
The first main had to add our generator to the list of generators.&nbsp;
In this example, the factory already did that, so all that this main must
do is instantiate itself and run itself.</li>
</ul>
</ul>
</body>
</html>
