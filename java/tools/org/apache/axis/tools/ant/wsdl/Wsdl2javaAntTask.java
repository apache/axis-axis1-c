/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2001-2002 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names "The Jakarta Project", "Ant", and "Apache Software
 *    Foundation" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.axis.tools.ant.wsdl;

import java.io.File;
import java.io.IOException;
import java.net.Authenticator;
import java.util.HashMap;

import org.apache.axis.enum.Scope;
import org.apache.axis.utils.DefaultAuthenticator;
import org.apache.axis.wsdl.toJava.Emitter;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;

/*
 * IMPORTANT: see Java2WsdlAntTask on how to javadoc this task and rebuild
 * the task documentation afterwards
 *
 */

/**
 * Create Java classes from local or remote WSDL.
 * Mappings from namespaces to packages can be provided as nested &lt;mapping&gt;
 * elements.
 * <p>
 * Proxy settings are taken from the java runtime settings of http.ProxyHost,
 * http.ProxyPort, etc. The Ant task &lt;setProxy&gt; can set these.
 * As well as the nested mapping elements, this task uses  the file
 * <tt>NStoPkg.properties</tt> in the project base directory
 * for namespace mapping
 * <p>
 * This task does no dependency checking; files are generated whether they
 * need to be or not. The exception to this is the Impl class, which is
 * not overwritten if it exists. This is a safety measure. However, all other
 * classes are generated overwriting anything that exists.
 * <p>
 * The safe way to use this task is to have it generate the java source in
 * a build directory, then have a &lt;copy&gt task selectively copy the
 * files you need into a safe location. Again, copying into the source tree
 * is dangerous, but a separate build/src tree is safe. Then include this
 * separate tree in the &lt;javac&gt; task's src attribute to include it in the
 * build. Implement your own implementation classes of the server stub and the
 * test cases using the generated templates.
 * If you want to add methods to autogenerated data types, consider subclassing
 * them, or write helper classes.
 * <p>
 * Tip: if you &lt;get&gt; the wsdl, and use the &lt;filesmatch&gt; condition
 * to compare the fetched wsdl with a catched copy, you can make the target that
 * calls the axis-wsd2ljava task conditional on the WSDL having changed. This stops
 * spurious code regeneration and follow-on rebuilds across the java source tree.
 * @ant.task category="axis" name="axis-wsdl2java"
 * @author Davanum Srinivas (dims@yahoo.com)
 * @author steve loughran
 */
public class Wsdl2javaAntTask extends Task
{
    private boolean verbose = false;
    private boolean debug = false;
    private boolean server = false;
    private boolean skeletonDeploy = false;
    private boolean testCase = false;
    private boolean noImports = false;
    private boolean all = false;
    private boolean helperGen = false;
    private boolean noWrapped = false;
    private String factory = null;
    private HashMap namespaceMap = new HashMap();
    private String output = "." ;
    private String protocolHandlerPkgs = "";
    private String deployScope = "";
    private String url = "";
    private String typeMappingVersion = TypeMappingVersionEnum.DEFAULT_VERSION;
    private long timeout = 45000;
    private File  namespaceMappingFile=null;
    private MappingSet mappings = new MappingSet();
    private String username=null;
    private String password=null;

    /**
     * do we print a stack trace when something goes wrong?
     */
    private boolean printStackTraceOnFailure=true;
    /**
     * what action to take when there was a failure and the source was some
     * URL
     */
    private boolean failOnNetworkErrors=false;

    public Wsdl2javaAntTask() {
    }

    /**
     * validation code
     * @throws  BuildException  if validation failed
     */
    protected void validate()
            throws BuildException {
        if(url==null || url.length()==0) {
            throw new BuildException("No url specified");
        }
        if(timeout<-1) {
            throw new BuildException("negative timeout supplied");
        }
        File outdir=new File(output);
        if(!outdir.isDirectory() || !outdir.exists()) {
            throw new BuildException("output directory is not valid");
        }

    }

    /**
     * trace out parameters
     * @param logLevel to log at
     * @see org.apache.tools.ant.Project#log
     */
    public void traceParams(int logLevel) {
        log("Running Wsdl2javaAntTask with parameters:", logLevel);
        log("\tverbose:" + verbose, logLevel);
        log("\tdebug:" + debug, logLevel);
        log("\tserver-side:" + server, logLevel);
        log("\tskeletonDeploy:" + skeletonDeploy, logLevel);
        log("\thelperGen:" + helperGen, logLevel);
        log("\tfactory:" + factory, logLevel);
        log("\ttestCase:" + testCase, logLevel);
        log("\tnoImports:" + noImports, logLevel);
        log("\tNStoPkg:" + namespaceMap, logLevel);
        log("\toutput:" + output, logLevel);
        log("\tprotocolHandlerPkgs:" + protocolHandlerPkgs, logLevel);
        log("\tdeployScope:" + deployScope, logLevel);
        log("\tURL:" + url, logLevel);
        log("\tall:" + all, logLevel);
        log("\ttypeMappingVersion:" + typeMappingVersion, logLevel);
        log("\ttimeout:" + timeout, logLevel);
        log("\tfailOnNetworkErrors:" + failOnNetworkErrors, logLevel);
        log("\tprintStackTraceOnFailure:" + printStackTraceOnFailure, logLevel);
        log("\tnamespaceMappingFile:"+namespaceMappingFile, logLevel);
        log("\tusername:" + username, logLevel);
        log("\t:password" + password, logLevel);
        log("\t:noWrapped" + noWrapped, logLevel);
        traceNetworkSettings(logLevel);
    }

    /**
     * The method executing the task
     * @throws  BuildException  if validation or execution failed
     */
    public void execute() throws BuildException {
        //before we get any further, if the user didnt spec a namespace mapping
        //file, we load in the default
     
        traceParams(Project.MSG_VERBOSE);
        validate();
        try {
            // Instantiate the emitter
            Emitter emitter = new Emitter();

            //extract the scope
            Scope scope = Scope.getScope(deployScope, null);
            if (scope != null) {
                emitter.setScope(scope);
            } else if (deployScope.length()==0
                    ||  "none".equalsIgnoreCase(deployScope)) {
                /* leave default (null, or not-explicit) */;
            } else {
                log("Unrecognized scope:  " + deployScope + ".  Ignoring it.", Project.MSG_VERBOSE);
            }

            //do the mappings, with namespaces mapped as the key
            mappings.execute(this, namespaceMap, false);
            if (!namespaceMap.isEmpty()) {
                emitter.setNamespaceMap(namespaceMap);
            }
            emitter.setTestCaseWanted(testCase);
            emitter.setHelperWanted(helperGen);
            if (factory != null) {
                emitter.setFactory(factory);
            }
            emitter.setImports(!noImports);
            emitter.setAllWanted(all);
            emitter.setOutputDir(output);
            emitter.setServerSide(server);
            emitter.setSkeletonWanted(skeletonDeploy);
            emitter.setVerbose(verbose);
            emitter.setDebug(debug);
            emitter.setTypeMappingVersion(typeMappingVersion);
            emitter.setNowrap(noWrapped);
	        if (namespaceMappingFile != null) {
	            emitter.setNStoPkg(namespaceMappingFile.toString());
	        }    
            emitter.setTimeout(timeout);

            Authenticator.setDefault(new DefaultAuthenticator(username,password));

            log("WSDL2Java " + url, Project.MSG_INFO);
            try {
                emitter.run(url);
            } catch (Throwable e) {
                if (url.startsWith("http://")) {
                    // What we have is either a network error or invalid XML -
                    // the latter most likely an HTML error page.  This makes
                    // it impossible to continue with the test, so we stop here
                    if(!failOnNetworkErrors) {
                        // test mode, issue a warning, and return without
                        //reporting a fatal error.
                        log(e.toString(), Project.MSG_WARN);
                        return;
                    } else {
                        //in 'consumer' mode, bail out with the URL
                        throw new BuildException("Could not build "+url,e);
                    }
                } else {
                    throw e;
                }
            }
        } catch (BuildException b) {
            //we rethrow this immediately; but need to catch it to stop it being
            //mistaken for a throwable.
            throw b;
        } catch (Throwable t) {
            if(printStackTraceOnFailure) {
                traceParams(Project.MSG_INFO);
                t.printStackTrace();
            }
            throw new BuildException("Error while processing WSDL in Wsdl2javaAntTask for "+url,t);
        }

    }

    /**
     *  flag for verbose output; default=false
     *
     *@param  verbose  The new verbose value
     */
    public void setVerbose(boolean verbose) {
        this.verbose = verbose;
    }

    /**
     *  flag for debug output; default=false
     *
     *@param  debug  The new debug value
     */
    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    /**
     *  emit server-side bindings for web service; default=false
     */
    public void setServerSide(boolean parameter) {
        this.server = parameter;
    }

    /**
     * deploy skeleton (true) or implementation (false) in deploy.wsdd.
     * Default is false.  Assumes server-side="true".
     */
    public void setSkeletonDeploy(boolean parameter) {
        this.skeletonDeploy = parameter;
    }

    /**
     * flag for automatic Junit testcase generation
     * default is false
     */
    public void setTestCase(boolean parameter) {
        this.testCase = parameter;
    }

    /**
     * Turn on/off Helper class generation;
     * default is false
     */
    public void setHelperGen(boolean parameter) {
        this.helperGen = parameter;
    }

    /**
     * name of the Java2WSDLFactory class for
     * extending WSDL generation functions
     */
    public void setFactory(String parameter) {
        this.factory = parameter;
    }

    /**
     * only generate code for the immediate WSDL document,
     * and not imports; default=false;
     */
    public void setNoImports(boolean parameter) {
        this.noImports = parameter;
    }

    /**
     * output directory for emitted files
     */
    public void setOutput(File parameter) throws BuildException {
        try {
            this.output = parameter.getCanonicalPath();
        } catch (IOException ioe) {
            throw new BuildException(ioe);
        }
    }

    /**
     * append any protocol handler pkgs specified with the task
     */
    public void setProtocolHandlerPkgs(String handlerPkgs) {
        String currentPkgs = System.getProperty("java.protocol.handler.pkgs");
        String newPkgs = null;

        if (currentPkgs == null)
            newPkgs = handlerPkgs;
        else
            // append to the existing list
            newPkgs = currentPkgs + "|" + handlerPkgs;

        System.setProperty("java.protocol.handler.pkgs", newPkgs);
    }

    /**
     * add scope to deploy.xml: "Application", "Request", "Session"
     * optional;
     */
    public void setDeployScope(String scope) {
        this.deployScope = scope;
    }
/*
    //unused till we can somehow get ant to be case insensitive when handling enums
    public void setDeployScope(DeployScopeEnum scope) {
        this.deployScope = scope.getValue();
    }
*/
    /**
     * URL to fetch and generate WSDL for.
     * Can be remote or a local file.
     */
    public void setURL(String parameter) {
        this.url = parameter;
    }

    /**
     * flag to generate code for all elements, even unreferenced ones
     * default=false;
     */
    public void setAll(boolean parameter) {
        this.all = parameter;
    }

    /**
     *  the default type mapping registry to use. Either 1.1 or 1.2.
     * Default is 1.1
     * @param parameter new version
     */
    public void setTypeMappingVersion(TypeMappingVersionEnum parameter) {
        this.typeMappingVersion = parameter.getValue();
    }

    /**
     * timeout in milliseconds for URL retrieval; default is 45 seconds.
     * Set this to -1 to disable timeouts altogether: other negative values
     * are not allowed)
     */
    public void setTimeout(long parameter) {
        this.timeout = parameter;
    }

    /**
     * add a mapping of namespaces to packages
     */
    public void addMapping(NamespaceMapping mapping) {
        mappings.addMapping(mapping);
    }

    /**
     * add a mapping of namespaces to packages
     */
    public void addMappingSet(MappingSet mappingset) {
        mappings.addMappingSet(mappingset);
    }

    /**
     * set the mapping file. This is a properties file of
     * package=namespace order. Optional, default is to look for
     * a file called NStoPkg.properties in the project directory.
     * @param namespaceMappingFile
     */
    public void setNamespaceMappingFile(File namespaceMappingFile) {
        this.namespaceMappingFile = namespaceMappingFile;
    }

    /**
     * valid deploy scopes for the task
     */
    /*
    public static class DeployScopeEnum extends EnumeratedAttribute {
        public String[] getValues() {
            return new String[]{"Application", "Request", "Session","none"};
        }

    }
    */
    
    /**
     * should the task fail the build if there is a network error?
     * optional: defaults to false
     * @param failOnNetworkErrors
     */
    public void setFailOnNetworkErrors(boolean failOnNetworkErrors) {
        this.failOnNetworkErrors = failOnNetworkErrors;
    }

    /**
     * should we print a stack trace on failure?
     * Optional, default=true.
     * @param printStackTraceOnFailure
     */
    public void setPrintStackTraceOnFailure(boolean printStackTraceOnFailure) {
        this.printStackTraceOnFailure = printStackTraceOnFailure;
    }

    /**
     * set any username required for BASIC authenticated access to the WSDL;
     * optional.
     * @param username
     */
    public void setUsername(String username) {
        this.username = username;
    }

    /**
     * set any password required for BASIC authenticated access to the WSDL;
     * optional; only used if username is set
     * @param password
     * @see #username
     */
    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * Set the noWrapped flag.
     * @param noWrapped
     */ 
    public void setNoWrapped(boolean noWrapped) {
      this.noWrapped = noWrapped;
    }
    
    private void traceSystemSetting(String setting,int logLevel) {
        String value=System.getProperty(setting);
        log("\t"+setting+"=" + value, logLevel);
    }

    private void traceNetworkSettings(int logLevel) {
        traceSystemSetting("http.proxyHost",logLevel);
        traceSystemSetting("http.proxyPort", logLevel);
        traceSystemSetting("http.proxyUser", logLevel);
        traceSystemSetting("http.proxyPassword", logLevel);
        traceSystemSetting("socks.proxyHost", logLevel);
        traceSystemSetting("socks.proxyPort", logLevel);
    }
}

