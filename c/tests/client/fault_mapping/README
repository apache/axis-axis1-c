/*
 *   Copyright 2003-2004 The Apache Software Foundation.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *
 *   @author Damitha Kumarage (damitha@opensource.lk, damitha@jkcsworld.com)
 *
 */   

   This README explains the test case of testing the Axis C++ fault mapping.
   It is recommended that you also read the README file of
   $AXISCPP_HOME/tests/server/exceptionTest/README
   
   Here I have generated the stuff using FaultMapping.wsdl. This wsdl
   simply have several complex types. One such type is DivByZeroStruct which 
   consists of three simple types(xsd:int,* xsd:foat and xsd:string). 
   For portType operation "div" we have a fault named
   DivByZero the message for which is DivByZeroFault which is of the complex
   type mentioned above(DivByZeroStruct). The server side for this client
   sample is in $AXISCPP_HOME/tests/server/exceptionTest.
   When you generated the client side it will generate header and
   implementation files for the following
  
   MathOps: Service request class which calls div service method in the server
       and getFaultDetails if there's any.
  
   DivByZeroStruct: The type corresponding to the complex type DivByZeroStruct
       in the MathOps.wsdl
  
   OutOfBoundStruct: The type corresponding to the complex type OutOfBoundStruct
       in the MathOps.wsdl
  
   SpecialDetailStruct:The type corresponding to the complex type SpecialDetailStruct
       in the MathOps.wsdl
  
   AxisDivByZeroException: For each fault in wsdl we generate an exception
       class which is derived from AxisException base class which is the root
       class for exceptions in Axis C++. This root class in tern is derived
       from std::exception. AxisDivByzeroException is the exception type
       corresponding to DivByZero fault.
  
   AxisOutOfBountException: Exception type corresponding to OutOfBound fault.
  
   AxisNormalDetailException: Exception type corresponding to NormalDetail fault.
  
   In the server side if division by zero fault is encountered
   in the service method it will call
   ...
   ...
   pIWSSZ->createSoapFault("DivByZeroStruct", "http://soapinterop.org/wsdl");
   ...
   ...
   where pIWSSZ is the soap serializer interface.
   Once this method is called
   m_pSoapEnvelope->m_pSoapBody->m_pSoapFault is assigned a new soap fault
   object. After that,
  
   DivByZeroStruct* pObjFault = new DivByZeroStruct();
    //User may write code here to fill the struct
   pObjFault->varString = "Division by zero exception";
   pObjFault->varInt = 1;
   pObjFault->varFloat = 10.52;
   if (pObjFault)
    pIWSSZ->addFaultDetail(pObjFault, (void*) Axis_Serialize_DivByZeroStruct,
    (void*) Axis_Delete_DivByZeroStruct,"DivByZero", Axis_URI_DivByZeroStruct);
    ...
    ...
   Here the service developer fills the  DivByZeroStruct with appropriate
   values and call SoapSerialzer's addFaultDetail method with the knowledge
   of serializing and deserializing. Once this method is called setFaultDetail
   method of SoapFault is called from SoapSerializer.
   ...
   ...
   int SoapFault::setFaultDetail(const Param* pFaultDetail)
   {
       m_pFaultDetail = (Param*) pFaultDetail;
       return AXIS_SUCCESS;
   }
   ...
   ...
  
   So once the serialize method of SoapSerializer is called then in addition to
   serializing Faultcode, Faultstring and Faultactor, SoapFault's FaultDetail
   object is also serialized into the soap body's fault detail tag.
   So in the wire comes the Soap message with a soap fault.
  
   Now when you run the client here, if it catch an exception
   ...
   ...
   catch(AxisException& e)
   {
       int iExceptionCode = e.getExceptionCode();
       if(AXISC_NODE_VALUE_MISMATCH_EXCEPTION != iExceptionCode)
       {
           throw;
       }
   ...
   ...
   it checks the exception code and if exception code is not equal to
   AXISC_NODE_VALUE_MISMATCH_EXCEPTION value it means that the exception
   thrown not because of a soap fault. Exception is caused by some other
   mean in the client side. If a soap fault comes in the wire SoapDeseriazer's
   checkMessageBody  method throws and exception
   ...
   ...
   throw AxisGenException(AXISC_NODE_VALUE_MISMATCH_EXCEPTION);
   ...
   ...
  
   When we catch that exception we knows that a soap fault has come.
   ...
   ...
   else if (AXIS_SUCCESS == m_pCall->checkFault("Fault",
       "http://localhost/axis/MathOps" ))
        //Exception handling code goes here
    {
        cFaultcode = m_pCall->getElementAsString("faultcode", 0);
        cFaultstring = m_pCall->getElementAsString("faultstring", 0);
        cFaultactor = m_pCall->getElementAsString("faultactor", 0);
   ...
   ...
        else if(0 == strcmp("DivByZeroStruct", cFaultstring))
        {
            if (AXIS_SUCCESS == m_pCall->checkFault("faultdetail",
                "http://localhost/axis/MathOps"))
            {
                DivByZeroStruct* pFaultDetail = NULL;
                pFaultDetail = (DivByZeroStruct*)m_pCall->
                    getCmplxObject((void*) Axis_DeSerialize_DivByZeroStruct,
                    (void*) Axis_Create_DivByZeroStruct,
                    (void*) Axis_Delete_DivByZeroStruct,"faultstruct1", 0);
                //Client developers code goes here to handle the struct can
                //be inserted here
                printf("faultcode:%s\n", cFaultcode);
                printf("faultstring:%s\n", cFaultstring);
                printf("faultactor:%s\n", cFaultactor);
                m_pCall->unInitialize();
                throw AxisDivByZeroException(pFaultDetail);
            }
        }
   ...
   ...
   Note that we compares cFaultstring which contains soap fault's faultstring
   with the DivByZeroStruct. This is so because in the server side we set the
   faultstring to take the fault's generated type name. If the faultdetail
   is just a simple string
   ...
   ...
   else
   {
       cFaultdetail = m_pCall->getElementAsString("faultdetail", 0);
       throw AxisGenException(cFaultdetail);
   }
   ...
   ...
