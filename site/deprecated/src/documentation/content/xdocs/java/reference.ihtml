<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
<HEAD>
  <META name="generator" content=
  "HTML Tidy for Windows (vers 1st October 2003), see www.w3.org">

  <TITLE>Axis Reference Guide</TITLE>
  <META http-equiv="Content-Type" content=
  "text/html; charset=us-ascii">
  <LINK href="axis.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>
  <H1 align="center"><IMG height="96" src="images/axis.jpg" width=
  "176"></H1>

  <H1>Axis Reference Guide</H1>

  <P><I>1.1 Version</I><BR>
  <I>Feedback: <A href=
  "mailto:axis-dev@ws.apache.org">axis-dev@ws.apache.org</A></I></P>

  <H3>Table of Contents</H3>

  <UL>
 <LI><A href="#Tools">Tools Reference</A></LI>

 <LI style="list-style: none">
   <UL>
  <LI><A href="#WSDL2Java">WSDL2Java</A></LI>

  <LI><A href="#Java2WSDL">Java2WSDL</A></LI>

  <LI><A href="#Java2WSDL">Java2WSDL</A></LI>
   </UL>
 </LI>

 <LI><A href="#Deployment">Deployment (WSDD) Reference</A></LI>

 <LI><A href="#global_configuration">Global Axis
 Configuration</A></LI>

 <LI><A href="#individual_service">Individual Service
 Configuration</A></LI>

 <LI><A href="#axis_logging">Axis Logging Configuration</A></LI>

 <LI><A href="#axis_components">Pre-Configured Axis Components
 Reference</A></LI>
  </UL>

  <H2><A name="Tools"></A>Tools Reference</H2>

  <H3><A name="WSDL2Java"></A>WSDL2Java Reference</H3>

  <P>Usage:&nbsp; java org.apache.axis.wsdl.WSDL2Java [options]
  WSDL-URI<BR>
  Options:<BR>
<TT>
  &nbsp;&nbsp;&nbsp;&nbsp; -h, --help<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  print this message and exit<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -v, --verbose<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  print informational messages<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -n, --noImports<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  only generate code for the immediate WSDL document<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -O, --timeout
  &lt;argument&gt;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  timeout in seconds (default is 45, specify -1 to disable)<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -D, --Debug<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  print debug information<BR>
  &nbsp;&nbsp;&nbsp; -W, --noWrapped<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  turn off support for "wrapped" document/literal<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -s, --server-side<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  emit server-side bindings for web service<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -S, --skeletonDeploy
  &lt;argument&gt;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  deploy skeleton (true) or implementation (false) in
  deploy.wsdd.<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  Default is false.&nbsp; Assumes --server-side.<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -N, --NStoPkg
  &lt;argument&gt;=&lt;value&gt;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  mapping of namespace to package<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -f, --fileNStoPkg
  &lt;argument&gt;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  file of NStoPkg mappings (default NStoPkg.properties)<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -p, --package
  &lt;argument&gt;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  override all namespace to package mappings, use this package<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;
  name instead<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -o, --output
  &lt;argument&gt;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  output directory for emitted files<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -d, --deployScope
  &lt;argument&gt;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  add scope to deploy.xml: "Application", "Request", "Session"<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -t, --testCase<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  emit junit testcase class for web service<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -a, --all<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  generate code for all elements, even unreferenced ones<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -T,
  --typeMappingVersion<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  indicate 1.1 or 1.2. The default is 1.1 (SOAP 1.1 JAX-RPC
  compliant.
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  1.2 indicates SOAP 1.1 encoded.)<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -F, --factory
  &lt;argument&gt;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  name of a custom class that implements GeneratorFactory interface
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  (for extending Java generation functions)<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -H, --helperGen<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  emits separate Helper classes for meta data<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -U, --user
  &lt;argument&gt;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  username to access the WSDL-URI<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; -P, --password
  &lt;argument&gt;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  password to access the WSDL-URI<BR>
  &nbsp;
</TT>
</P>
<TT>
  <H4>-h, --help</H4>

  <P>Print the usage statement and exit</P>

  <H4>-v, --verbose</H4>

  <P>See what the tool is generating as it is generating it.</P>

  <H4>-n, --noImports</H4>

  <P>Only generate code for the WSDL document that appears on the
  command line.&nbsp; The default behaviour is to generate files
  for all WSDL documents, the immediate one and all imported
  ones.</P>

  <H4>-O, --timeout</H4>

  <P>Timeout in seconds. The default is 45. Use -1 to disable the
  timeout.</P>

  <H4>-D, --Debug</H4>

  <P>Print debug information, which currently is WSDL2Java's symbol
  table. Note that this is only printed after the symbol table is
  complete, ie., after the WSDL is parsed successfully.</P>

  <H4>-W, --noWrapped</H4>

  <P>This turns off the special treatment of what is called
  "wrapped" document/literal style operations. &nbsp;By default,
  WSDL2Java will recognize the following conditions:</P>

  <UL>
 <LI>If an input message has is a single part.</LI>

 <LI>The part is an element.</LI>

 <LI>The element has the same name as the operation</LI>

 <LI>The element's complex type has no attributes<BR></LI>
  </UL>

  <P>When it sees this, WSDL2Java will 'unwrap' the top level
  element, and treat each of the components of the element as
  arguments to the operation. This type of WSDL is the default for
  Microsoft .NET web services, which wrap up RPC style arguments in
  this top level schema element.</P>

  <H4>-s, --server-side</H4>

  <P>Emit the server-side bindings for the web service:</P>

  <UL>
 <LI>a skeleton class named &lt;bindingName&gt;Skeleton.&nbsp;
 This may or may not be emitted (see -S, --skeletonDeploy).</LI>

 <LI>an implementation template class named
 &lt;bindingName&gt;Impl.&nbsp; Note that, if this class already
 exists, then it is not emitted.</LI>

 <LI>deploy.wsdd</LI>

 <LI>undeploy.wsdd</LI>
  </UL>

  <H4>-S, --skeletonDeploy &lt;argument&gt;</H4>

  <P>Deploy either the skeleton (true) or the implementation
  (false) in deploy.wsdd.&nbsp; In other words, for "true" the
  service clause in the deploy.wsdd file will look something
  like:</P>
  <PRE class="example">
&lt;service name="AddressBook" provider="java:RPC"&gt;
 &lt;parameter name="className" value="samples.addr.AddressBookSOAPBindingSkeleton"/&gt;
 ...
&lt;/service&gt;
</PRE>

  <P>and for "false" it would look like:</P>
  <PRE class="example">
&lt;service name="AddressBook" provider="java:RPC"&gt;
 &lt;parameter name="className" value="samples.addr.AddressBookSOAPBindingImpl"/&gt;
   ...
&lt;/service&gt;
</PRE>

  <P>The default for this option is false.  When you use this
  option, the --server-side option is assumed, so you don't have to
  explicitly specify --server-side as well.</P>

  <H4>-N, --NStoPkg &lt;argument&gt;=&lt;value&gt;</H4>

  <P>By default, package names are generated from the namespace
  strings in the WSDL document in a magical manner (typically, if
  the namespace is of the form "http://x.y.com" or "urn:x.y.com"
  the corresponding package will be "com.y.x").  If this magic is
  not what you want, you can provide your own mapping using the
  --NStoPkg argument, which can be repeated as often as necessary,
  once for each unique namespace mapping.  For example, if there is
  a namespace in the WSDL document called "urn:AddressFetcher2",
  and you want files generated from the objects within this
  namespace to reside in the package samples.addr, you would
  provide the following option to WSDL2Java:</P>
  <PRE>
--NStoPkg urn:AddressFetcher2=samples.addr
</PRE>

  <P>(Note that if you use the short option tag, "-N", then there
  must not be a space between "-N" and the namespace.)<BR>
   </P>

  <H4>-f, --fileNStoPkg &lt;argument&gt;</H4>

  <P>If there are a number of namespaces in the WSDL document,
  listing a mapping for them all could become tedious.  To help
  keep the command line terse, WSDL2Java will also look for
  mappings in a properties file.  By default, this file is named
  "NStoPkg.properties" and it must reside in the default package
  (ie., no package).  But you can explicitly provide your own file
  using the --fileNStoPkg option.</P>

  <P>The entries in this file are of the same form as the arguments
  to the --NStoPkg command line option.  For example, instead of
  providing the command line option as above, we could provide the
  same information in NStoPkg.properties:</P>
  <PRE>
urn\:AddressFetcher2=samples.addr
</PRE>

  <P>(Note that the colon must be escaped in the properties
  file.)</P>

  <P>If an entry for a given mapping exists both on the command
  line and in the properties file, the command line entry takes
  precedence.</P>

  <H4>-p, --package &lt;argument&gt;</H4>

  <P>This is a shorthand option to map all namespaces in a WSDL
  document to the same Java package name.  This can be useful, but
  dangerous.  You must make sure that you understand the effects of
  doing this.  For instance there may be multiple types with the
  same name in different namespaces.  It is an error to use the
  --NStoPkg switch and --package at the same time.</P>

  <H4>-o, --output &lt;argument&gt;</H4>

  <P>The root directory for all emitted files.</P>

  <H4>-d, --deployScope &lt;argument&gt;</H4>

  <P>Add scope to deploy.wsdd: "Application", "Request", or
  "Session".  If this option does not appear, no scope tag appears
  in deploy.wsdd, which the Axis runtime defaults to "Request".</P>

  <H4>-t, --testCase</H4>

  <P>Generate a client-side JUnit test case.  This test case can
  stand on its own, but it doesn't really do anything except pass
  default values (null for objects, 0 or false for primitive
  types).  Like the generated implementation file, the generated
  test case file could be considered a template that you may fill
  in.</P>

  <H4>-a, --all</H4>

  <P>Generate code for all elements, even unreferenced ones.  By
  default, WSDL2Java only generates code for those elements in the
  WSDL file that are referenced.</P>

  <P>A note about what it means to be referenced.  We cannot simply
  say:  start with the services, generate all bindings referenced
  by the service, generated all portTypes referenced by the
  referenced bindings, etc.  What if we're generating code from a
  WSDL file that only contains portTypes, messages, and types?  If
  WSDL2Java used service as an anchor, and there's no service in
  the file, then nothing will be generated.  So the anchor is the
  lowest element that exists in the WSDL file in the order:</P>

  <OL>
 <LI>types</LI>

 <LI>portTypes</LI>

 <LI>bindings</LI>

 <LI>services</LI>
  </OL>

  <P>For example, if a WSDL file only contained types, then all the
  listed types would be generated.  But if a WSDL file contained
  types and a portType, then that portType will be generated and
  only those types that are referenced by that portType.</P>

  <P>Note that the anchor is searched for in the WSDL file
  appearing on the command line, <B>not</B> in imported WSDL files.
  This allows one WSDL file to import constructs defined in another
  WSDL file without the nuisance of having all the imported WSDL
  file's constructs generated.</P>

  <H4>-T, --typeMappingVersion &lt;argument&gt;</H4>

  <P>Indicate 1.1 or 1.2.  The default is 1.2 (SOAP 1.2 JAX-RPC
  compliant).</P>

  <H4>-F, --factory &lt;argument&gt;</H4>

  <P>Used to extend the functionality of the WSDL2Java emitter. The
  argument is the name of a class which extends
  JavaWriterFactory.</P>

  <H4>-H, --helperGen</H4>

  <P>Emits separate Helper classes for meta data.</P>

  <H4>-U, --user &lt;argument&gt;</H4>

  <P>This username is used in resolving the WSDL-URI provided as
  the input to WSDL2Java.  If the URI contains a username, this
  will override the command line switch.  An example of a URL with
  a username and password is:
  <CODE>http://user:password@hostname:port/path/to/service?WSDL</CODE></P>

  <H4>-P, --password &lt;argument&gt;</H4>

  <P>This password is used in resolving the WSDL-URI provided as
  the input to WSDL2Java.  If the URI contains a password, this
  will override the command line switch. </P>
</TT>

  <H3><A name="Java2WSDL"></A>Java2WSDL Reference</H3>

  <P>Here is the help message generated from the current tool:</P>
  <PRE>
<FONT color="#993366">Java2WSDL emitter
Usage: java org.apache.axis.wsdl.Java2WSDL [options] class-of-portType
Options:
<TT>
  -h, --help
    print this message and exit
  -I, --input &lt;argument&gt;
    input WSDL filename
  -o, --output &lt;argument&gt;
    output WSDL filename
  -l, --location &lt;argument&gt;
    service location url
  -P, --portTypeName &lt;argument&gt;
    portType name (obtained from class-of-portType if not specified)
  -b, --bindingName &lt;argument&gt;
    binding name (--servicePortName value + "SOAPBinding" if not specified)
  -S, --serviceElementName &lt;argument&gt;
    service element name (defaults to --servicePortName value + "Service")
  -s, --servicePortName &lt;argument&gt;
    service port name (obtained from --location if not specified)
  -n, --namespace &lt;argument&gt;
    target namespace
  -p, --PkgtoNS &lt;argument&gt;=&lt;value&gt;
    package=namespace, name value pairs
  -m, --methods &lt;argument&gt;
    space or comma separated list of methods to export
  -a, --all
    look for allowed methods in inherited class
  -w, --outputWsdlMode &lt;argument&gt;
    output WSDL mode: All, Interface, Implementation
  -L, --locationImport &lt;argument&gt;
    location of interface wsdl
  -N, --namespaceImpl &lt;argument&gt;
    target namespace for implementation wsdl
  -O, --outputImpl &lt;argument&gt;
    output Implementation WSDL filename, setting this causes
     --outputWsdlMode to be ignored
  -i, --implClass &lt;argument&gt;
    optional class that contains implementation of methods in class-of-portType.  
        The debug information in the class is used
    to obtain the method parameter names, which are used to set
    the WSDL part names.
  -x, --exclude &lt;argument&gt;
    space or comma separated list of methods not to export
  -c, --stopClasses &lt;argument&gt;
    space or comma separated list of class names which will stop
    inheritance search if --all switch is given
  -T, --typeMappingVersion &lt;argument&gt;
    indicate 1.1 or 1.2.  The default is 1.1 (SOAP 1.1 JAX-RPC 
         compliant  1.2 indicates SOAP 1.1 encoded.)
  -A, --soapAction &lt;argument&gt;
    value of the operations soapAction field. Values are DEFAULT,
    OPERATION or NONE. OPERATION forces soapAction to the name
    of the operation.  DEFAULT causes the soapAction to be set
    according to the operations meta data (usually "").  NONE forces
        the soapAction to "".  The default is DEFAULT.
  -y, --style &lt;argument&gt;
    The style of binding in the WSDL, either DOCUMENT, RPC, or WRAPPED.
  -u, --use &lt;argument&gt;
    The use of items in the binding, either LITERAL or ENCODED
  -e, --extraClasses &lt;argument&gt;
    A space or comma separated list of class names to be added tO
    The type section.
Details:
   portType element name= &lt;--portTypeName value&gt; OR &lt;class-of-portType name&gt;
   binding  element name= &lt;--bindingName value&gt; OR &lt;--servicePortName value&gt;Soap
Binding
   service  element name= &lt;--serviceElementName value&gt; OR &lt;--portTypeName value&gt;
Service
   port  element name= &lt;--servicePortName value&gt;
   address location  = &lt;--location value&gt;
</TT>
</FONT>
</PRE>
<TT>
  <P><B>-h , --help</B><BR>
  Prints the help message.</P>

  <P><B>-I, --input &lt;WSDL file&gt;</B><BR>
  Optional parameter that indicates the name of the input wsdl
  file. The output wsdl file will contain everything from the input
  wsdl file plus the new constructs. If a new construct is already
  present in the input wsdl file, it is not added. This option is
  useful for constructing a wsdl file with multiple ports,
  bindings, or portTypes.</P>

  <P><B>-o, --output &lt;WSDL file&gt;</B><BR>
  Indicates the name of the output WSDL file.  If not specified, a
  suitable default WSDL file is written into the current
  directory.</P>

  <P><B>-l, --location &lt;location&gt;</B><BR>
  Indicates the url of the location of the service.  The name after
  the last slash or backslash is the name of the service port
  (unless overridden by the -s option).  The service port address
  location attribute is assigned the specified value.</P>

  <P><B>-P, --portTypeName &lt;name&gt;</B><BR>
  Indicates the name to use use for the portType element. If not
  specified, the class-of-portType name is used.</P>

  <P><B>-b, --bindingName &lt;name&gt;</B><BR>
  Indicates the name to use use for the binding element. If not
  specified, the value of the --servicePortName + "SoapBinding" is
  used.</P>

  <P><B>-S, --serviceElementName &lt;name&gt;</B><BR>
  Indicates the name of the service element.  If not specified, the
  service element is the &lt;portTypeName&gt;Service. </P>

  <P><B>-s, --servicePortName &lt;name&gt;</B><BR>
  Indicates the name of the service port.  If not specified, the
  service port name is derived from the --location value. </P>

  <P><B>-n, --namespace &lt;target namespace&gt;</B><BR>
  Indicates the name of the target namespace of the WSDL.</P>

  <P><B>-p, --PkgToNS &lt;package&gt; &lt;namespace&gt;</B><BR>
  Indicates the mapping of a package to a namespace.  If a package
  is encountered that does not have a namespace, the Java2WSDL
  emitter will generate a suitable namespace name.  This option may
  be specified multiple times.</P>

  <P><B>-m, --methods &lt;arguments&gt;</B><BR>
  If this option is specified, only the indicated methods in your
  interface class will be exported into the WSDL file.  The methods
  list must be comma separated.  If not specified, all methods
  declared in the interface class will be exported into the WSDL
  file.</P>

  <P><B>-a, --all</B><BR>
  If this option is specified, the Java2WSDL parser will look into
  extended classes to determine the list of methods to export into
  the WSDL file.</P>

  <P><B>-w, --outputWSDLMode &lt;mode&gt;</B><BR>
  Indicates the kind of WSDL to generate.  Accepted values are:</P>

  <UL>
 <LI>All --- (default) Generates wsld containing both interface
 and implementation WSDL constructs.</LI>

 <LI>Interface --- Generates a WSDL containing the interface
 constructs (no service element).</LI>

 <LI>Implementation -- Generates a WSDL containing the
 implementation.  The interface WSDL is imported via the -L
 option.</LI>
  </UL>

  <P><B>-L, --locationImport &lt;url&gt;</B><BR>
  Used to indicate the location of the interface WSDL when
  generating an implementation WSDL.</P>

  <P><B>-N, --namespaceImpl &lt;namespace&gt;</B><BR>
  Namespace of the implementation WSDL.</P>

  <P><B>-O, --outputImpl &lt;WSDL file&gt;</B><BR>
  Use this option to indicate the name of the output implementation
  WSDL file.  If specified, Java2WSDL will produce interface and
  implementation WSDL files.  If this option is used, the -w option
  is ignored.</P>

  <P><B>-i, --implClass &lt;impl-class&gt;</B><BR>
  Sometimes extra information is available in the implementation
  class file. Use this option to specify the implementation
  class.</P>

  <P><B>-x, --exclude &lt;list&gt;</B><BR>
  List of methods to not exclude from the wsdl file.</P>

  <P><B>-c, --stopClasses &lt;list&gt;</B><BR>
  List of classes which stop the Java2WSDL inheritance search.</P>

  <P><B>-T, --typeMappingVersion &lt;version&gt;</B><BR>
  Choose the default type mapping registry to use. Either 1.1 or
  1.2.</P>

  <P><B>-A, --soapAction &lt;argument&gt;</B><BR>
  The value of the operations soapAction field. Values are DEFAULT,
  OPERATION or NONE. OPERATION forces soapAction to the name of the
  operation. DEFAULT causes the soapAction to be set according to
  the operation's meta data (usually ""). NONE forces the
  soapAction to "". The default is DEFAULT.</P>

  <P><B>-y, --style &lt;argument&gt;</B><BR>
  The style of the WSDL document: RPC, DOCUMENT or WRAPPED. The
  default is RPC. If RPC is specified, an rpc wsdl is generated. If
  DOCUMENT is specified, a document wsdl is generated. If WRAPPED
  is specified, a document/literal wsdl is generated using the
  wrapped approach. Wrapped style forces the use attribute to be
  literal.</P>

  <P><B>-u, --use &lt;argument&gt;</B><BR>
  The use of the WSDL document: LITERAL or ENCODED. If LITERAL is
  specified, the XML Schema defines the representation of the XML
  for the request. If ENCODED is specified, SOAP encoding is
  specified in the generated WSDL.</P>

  <P><B>-e, --extraClasses &lt;argument&gt;</B><BR>
  Specify a space or comma seperated list of class names which
  should be included in the <B>types</B> section of the WSDL
  document. This is useful in the case where your service interface
  references a base class and you would like your WSDL to contain
  XML Schema type defintions for these other classes. The
  -extraClasses option can be specified duplicate times. Each
  specification results in the additional classes being added to
  the list.</P>
</TT>

  <H2><A name="Deployment"></A>Deployment (WSDD) Reference</H2>

  <P>Note : all the elements referred to in this section are in the
  WSDD namespace, namely "http://xml.apache.org/axis/wsdd/".</P>

  <DL>
 <DT><B><FONT face=
 "Courier New, Courier, mono">&lt;deployment&gt;</FONT></B></DT>

 <DD>The root element of the deployment document which tells the
 Axis engine that this is a deployment. A deployment document
 may represent EITHER a complete engine configuration OR a set
 of components to deploy into an active engine.</DD>

 <DT> </DT>

 <DT><B><FONT face=
 "Courier New, Courier, mono">&lt;undeployment&gt;</FONT></B></DT>

 <DD>The root element of the deployment document which tells
 Axis that this is an undeployment.</DD>

 <DT> </DT>

 <DT><B><FONT face="Courier New, Courier, mono">&lt;handler
 [name="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>name</I></FONT><B><FONT face=
 "Courier New, Courier, mono">"] type="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>type</I></FONT><B><FONT face=
 "Courier New, Courier, mono">"/&gt;</FONT></B></DT>

 <DD>Belongs at the top level inside a <B>&lt;deployment&gt;</B>
 or <B>&lt;undeployment&gt;</B>, or inside a
 <B>&lt;chain&gt;</B>, <B>&lt;requestFlow&gt;</B>, or
 <B>&lt;responseFlow&gt;</B>. Defines a Handler, and indicates
 the type of the handler. "Type" is either the name of another
 previously defined Handler, or a QName of the form
 "<B>java:<I>class.name</I></B>". The optional "name" attribute
 allows you to refer to this Handler definition in other parts
 of the deployment. May contain an arbitrary number of
 <B><FONT face="Courier New, Courier, mono">&lt;parameter
 name="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>name</I></FONT><B><FONT face=
 "Courier New, Courier, mono">" value="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>value</I></FONT><B><FONT face=
 "Courier New, Courier, mono">"&gt;</FONT></B> elements, each of
 which will supply an option to the deployed Handler.</DD>

 <DT> </DT>

 <DT><B><FONT face="Courier New, Courier, mono">&lt;service
 name="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>name</I></FONT><B><FONT face=
 "Courier New, Courier, mono">" provider="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>provider</I></FONT><B><FONT face="Courier New, Courier, mono">
 " &gt;</FONT></B></DT>

 <DD>
   Deploys/undeploys an Axis Service. This is the most complex
   WSDD tag, so we're going to spend a little time on it.<BR>
   <BR>
   <B>Options</B> may be specified as follows :
   <CODE><B>&lt;parameter name="</B>name<B>"
   value="</B>value<B>"/&gt;</B></CODE>, and common ones
   include:<BR>
   <BR>

   <UL>
  <LI><B>className</B> : the backend implementation
  class<BR></LI>

  <LI>
    <B>allowedMethods</B> : Each provider can determine which
    methods are allowed to be exposed as web services.<BR>
    To summaries for Axis supplied providers:<BR>

    <P><U>Java RPC Provider</U> (provider="java:RPC") by
    default all public methods specified by the class in the
    className option, including any inherited methods are
    available as web services.<BR>
    For more details regarding the Java Provider please see
    <B>WHERE???</B>.</P>

    <P><U>Java MsgProvder</U> (provider="java:MSG") 
    <!-- Glen to provide details --></P>

    <P>In order to further restrict the above methods, the
    <B>allowedMethods</B> option may be used to specify in a
    space delimited list the names of only those methods
    which are allowed as web services. It is also possible to
    specify for this option the value <B>"*"</B> which is
    functionally equivalent to not specify the option at all.
    Also, it is worth mentioning that the <B>operation</B>
    element is used to further define the methods being
    offered, but it does not affect which methods are made
    available.</P>

    <P><I>Note, while this is true for Axis supplied
    providers, it is implementation dependent on each
    individual provider. Please review your providers
    documentation on how or if it supports this
    option.</I></P>

    <P><B><U>Note, Exposing any web service has security
    implications.</U><BR></B>As a best practices guide it is
    <U>highly</U> recommend when offering a web service in un
    secure environment to restrict allowed methods to only
    those required for the service being offered. And, for
    those that are made available, to <B>fully</B> understand
    their function and how they may access and expose your
    systems's resources.</P>
  </LI>

  <LI><B>allowedRoles</B> : comma-separated list of roles
  allowed to access this service<BR></LI>
   </UL><BR>
   If you wish to define handlers which should be invoked either
   before or after the service's provider, you may do so with
   the <B>&lt;requestFlow&gt;</B> and the
   <B>&lt;responseFlow&gt;</B> subelements. Either of those
   elements may be specified inside the <B>&lt;service&gt;</B>
   element, and their semantics are identical to the
   <B>&lt;chain&gt;</B> element described below - in other
   words, they may contain <B>&lt;handler&gt;</B> and
   <B>&lt;chain</B>&gt; elements which will be invoked in the
   order they are specified.<BR>
   <BR>
   Example:<BR>
   <PRE>
&lt;service name="test"&gt;
  &lt;parameter name="className" value="test.Implementation"/&gt;
  &lt;parameter name="allowedMethods" value="*"/&gt;
  &lt;namespace&gt;http://testservice/&lt;/namespace&gt;
  &lt;requestFlow&gt; &lt;!-- Run these before processing the request --&gt;
 &lt;handler type="java:MyHandlerClass"/&gt;
 &lt;handler type="somethingIDefinedPreviously"/&gt;
  &lt;/requestFlow&gt;
&lt;/service&gt;
</PRE><B>Metadata</B> may be specified about particular operations
in your service by using the &lt;operation&gt; tag inside a
service. This enables you to map the java parameter names of a
method to particular XML names, to specify the parameter modes for
your parameters, and to map particular XML names to particular
operations.<BR>
   <BR>
   &lt;operation name="method"&gt;<BR>
   &lt;/operation&gt;<BR>
 </DD>

 <DT> </DT>

 <DT><B><FONT face="Courier New, Courier, mono">&lt;chain
 name="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>name</I></FONT><B><FONT face=
 "Courier New, Courier, mono">"</FONT></B><B><FONT face=
 "Courier New, Courier, mono">&gt;<BR>
 &lt;<I>subelement</I>/&gt;...<BR>
 &lt;/chain&gt;</FONT></B></DT>

 <DD>
   Defines a chain. Each <I>handler</I> (i.e. deployed handler
   name) in the list will be invoked() in turn when the chain is
   invoked. This enables you to build up "modules" of commonly
   used functionality. The subelements inside chains may be
   &lt;<B>handler</B>&gt;s or &lt;<B>chain</B>&gt;s.
   &lt;handler&gt;s inside a &lt;chain&gt; may either be defined
   in terms of their Java class:<BR>
   <PRE>
&lt;chain name="myChain"&gt;
  &lt;handler type="java:org.apache.axis.handlers.LogHandler"/&gt;
&lt;/chain&gt;
</PRE>or may refer to previously defined &lt;handlers&gt;, with the
"type" of the handler referring to the name of the other handler
definition:<BR>
   <PRE>
&lt;handler name="logger" type="java:org.apache.axis.handlers.LogHandler"/&gt;<BR>
&lt;chain name="myChain"/&gt;<BR>
   &lt;handler type="logger"/&gt;<BR>
&lt;/chain&gt;
</PRE>
 </DD>

 <DT> </DT>

 <DT><B><FONT face="Courier New, Courier, mono">&lt;transport
 name="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>name</I></FONT><B><FONT face=
 "Courier New, Courier, mono">"&gt;</FONT></B></DT>

 <DD>Defines a transport on the server side. Server transports
 are invoked when an incoming request arrives. A server
 transport may define <B>&lt;requestFlow&gt;</B> and/or
 <B>&lt;responseFlow&gt;</B> elements to specify handlers/chains
 which should be invoked during the request (i.e. incoming
 message) or response (i.e. outgoing message) portion of
 processing (this function works just like the
 <B>&lt;service&gt;</B> element above). Typically handlers in
 the transport request/response flows implement
 transport-specific functionality, such as parsing protocol
 headers, etc.</DD>

 <DD><BR>
 <BR></DD>

 <DD>For any kind of transport (though usually this relates to
 HTTP transports), users may allow Axis servlets to perform
 arbitrary actions (by means of a "plug-in") when specific query
 strings are passed to the servlet (see the section <A href=
 "developers-guide.html#Axis%20Servlet%20Query%20String%20Plug-ins">
 Axis Servlet Query String Plug-ins</A> in the <A href=
 "developers-guide.html">Axis Developer's Guide</A> for more
 information on what this means and how to create a plug-in).
 When the name of a query string handler class is known, users
 can enable it by adding an appropriate <B>&lt;parameter&gt;</B>
 element in the Axis server configuration's
 <B>&lt;transport&gt;</B> element. An example configuration
 might look like the following:<BR>
 <BR>
 <CODE>&lt;transport name="http"&gt;<BR>
   &lt;parameter name="useDefaultQueryStrings" value="false"
 /&gt;<BR>
   &lt;parameter name="qs.name" value="class.name" /&gt;<BR>
 &lt;/transport&gt;<BR></CODE><BR>
 In this example, the query string that the Axis servlet should
 respond to is <I>?name</I> and the class that it should invoke
 when this query string is encountered is named
 <CODE>class.name</CODE>. The <CODE>name</CODE> attribute of the
 <B>&lt;parameter&gt;</B> element must start with the string
 "qs." to indicate that this <B>&lt;parameter&gt;</B> element
 defines a query string handler. The <CODE>value</CODE>
 attribute must point to the name of a class implementing the
 <CODE>org.apache.axis.transport.http.QSHandler</CODE>
 interface. By default, Axis provides for three Axis servlet
 query string handlers (<I>?list</I>, <I>?method</I>, and
 <I>?wsdl</I>). See the Axis server configuration file for their
 definitions. If the user wishes not to use these default query
 string handlers (as in the example), a <B>&lt;parameter&gt;</B>
 element with a <CODE>name</CODE> attribute equal to
 "useDefaultQueryStrings" should have its <CODE>value</CODE>
 attribute set to <CODE>false</CODE>. By default it is set to
 <CODE>true</CODE> and the element is not necessary if the user
 wishes to have this default behavior.</DD>

 <DT> </DT>

 <DT><B><FONT face="Courier New, Courier, mono">&lt;transport
 name="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>name</I></FONT><B><FONT face=
 "Courier New, Courier, mono">" pivot="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>handler
 type</I><B>"</B></FONT><B><FONT face=
 "Courier New, Courier, mono">&gt;</FONT></B></DT>

 <DD>Defines a transport on the client side, which is invoked
 when sending a SOAP message. The "pivot" attribute specifies a
 Handler to be used as the actual sender for this transport (for
 example, the HTTPSender). Request and response flows may be
 specified as in server-side transports to do processing on the
 request (i.e. outgoing message) or response (i.e. incoming
 message).</DD>

 <DT> </DT>

 <DT><B><FONT face="Courier New, Courier, mono">&lt;typeMapping
 qname="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>ns:localName</I></FONT><B><FONT face="Courier New, Courier, mono">
 " classname="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>classname</I></FONT><B><FONT face="Courier New, Courier, mono">
 " serializer="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>classname</I></FONT><B><FONT face="Courier New, Courier, mono">
 " deserializer="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>classname</I></FONT><B><FONT face="Courier New, Courier, mono">
 "/&gt;</FONT></B></DT>

 <DD>Each typeMapping maps an XML qualified name to/from a Java
 class, using a specified Serializer and Deserializer.</DD>

 <DT> </DT>

 <DT><B><FONT face="Courier New, Courier, mono">&lt;beanMapping
 qname="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>ns:localName</I></FONT><B><FONT face="Courier New, Courier, mono">
 " classname="</FONT></B><FONT face=
 "Courier New, Courier, mono"><I>classname</I></FONT><B><FONT face="Courier New, Courier, mono">
 "</FONT></B><B><FONT face=
 "Courier New, Courier, mono">&gt;</FONT></B></DT>

 <DD>A simplified type mapping, which uses pre-defined
 serializers/deserializers to encode/decode JavaBeans. The class
 named by "classname" must follow the JavaBean standard pattern
 of get/set accessors.</DD>
  </DL>

  <P><A name="global_configuration"></P>

  <H2>Global Axis Configuration</H2>

  <P>The server is configured (by default) by values in the
  server-config.wsdd file, though a dedicated Axis user can write
  their own configuration handler, and so store configuration data
  in an LDAP server, database, remote web service, etc. Consult the
  source on details as to how to do that. You can also add options
  to the web.xml file and have them picked up automatically. We
  don't encourage that as it is nice to keep configuration stuff in
  one place.</P>

  <P>In the server-config file, there is a global configuration
  section, which supports parameter name/value pairs as nested
  elements. Here are the options that we currently document, though
  there may be more (consult the source, as usual).</P>
  <PRE>
   &lt;globalConfiguration&gt;
 &lt;parameter name="adminPassword" value="admin"/&gt;
 &lt;parameter name="attachments.Directory" value="c:\temp\attachments"/&gt;
 &lt;parameter name="sendMultiRefs" value="true"/&gt;
 &lt;parameter name="sendXsiTypes" value="true"/&gt;
 &lt;parameter name="attachments.implementation"
  value="org.apache.axis.attachments.AttachmentsImpl"/&gt;
 &lt;parameter name="sendXMLDeclaration" value="true"/&gt;
 &lt;parameter name="enable2DArrayEncoding" value="true"/&gt;
   &lt;/globalConfiguration&gt;
</PRE>

  <TABLE>
 <TR>
   <TD><B>adminPassword</B></TD>

   <TD>Adminstrator password, as used by AdminService.</TD>
 </TR>

 <TR>
   <TD><B>attachments.Directory</B></TD>

   <TD>The directory where attachments end up. This should be in
   the syntax appropriate for the target platform.</TD>
 </TR>

 <TR>
   <TD><B>attachments.implementation</B></TD>

   <TD>Name of class that implements attachments support.
   Default is
   <TT>org.apache.axis.attachments.AttachmentsImpl</TT></TD>
 </TR>

 <TR>
   <TD><B>axis.enableListQuery</B></TD>

   <TD>Flag to enable the "list the WSDD" feature. Set to false
   by default, because listing the current system config can
   expose information (such as the adminservice password) that
   one does not want widely avaialable.</TD>
 </TR>

 <TR>
   <TD><B>axis.Compiler</B></TD>

   <TD>Compiler adapter classname for JWS compilation. Default
   is <TT>org.apache.axis.components.compiler.Javac</TT>; change
   this to <TT>org.apache.axis.components.compiler.Jikes</TT> to
   invoke jikes instead.</TD>
 </TR>

 <TR>
   <TD><B>axis.development.system</B></TD>

   <TD>Flag to switch the system from <I>production</I> (false)
   to <I>development</I> (true). A development system gives out
   stack traces and other information that production boxes
   should not.</TD>
 </TR>

 <TR>
   <TD><B>axis.xmlEncoding</B></TD>

   <TD>Encoding used for XML messages -either UTF-8 (default) or
   UTF-16</TD>
 </TR>

 <TR>
   <TD><B>axis.engineConfigClass</B></TD>

   <TD>Name of a class that provides Axis configuration.
   Implement a new class implementing
   <TT>EngineConfiguration</TT> and name it here to use
   alternate configuration mechanisms.</TD>
 </TR>

 <TR>
   <TD><B>axis.jws.servletClassDir</B></TD>

   <TD>Path to where compiled JWS pages are placed.</TD>
 </TR>

 <TR>
   <TD><B>axis.sendMinimizedElements</B></TD>

   <TD>Flag to turn on support for a when .NET1.0 can't
   correctly handle some bits of XML <A href=
   "http://nagoya.apache.org/bugzilla/show_bug.cgi?id=17021">that
   it should.</A> The flag defaults to true; if some .NET
   clients are failing to handle a Web Service returning an
   empty array inside another object, set this flag to
   <I>false</I>.</TD>
 </TR>

 <TR>
   <TD><B>enable2DArrayEncoding</B></TD>

   <TD>Set this to "true" to turn 2D array encoding on; this
   encoding is incompatible with .NET 1.0: default="false".</TD>
 </TR>

 <TR>
   <TD><B>sendMultiRefs</B></TD>

   <TD>true/false flag to control whether multirefs are sent or
   not.</TD>
 </TR>

 <TR>
   <TD><B>sendXMLDeclaration</B></TD>

   <TD>true/false flag to control whether the &lt;?xml?&gt;
   declaration is sent in messages</TD>
 </TR>

 <TR>
   <TD><B>sendXsiTypes</B></TD>

   <TD>true/false flag to enable/disable sending the type of
   every value sent over the wire. Defaults to true.</TD>
 </TR>

 <TR>
   <TD><STRONG>SingleSOAPVersion</STRONG></TD>

   <TD>When set to either "1.1" or "1.2", this configures the
   engine to only accept the specified SOAP version. Attempts to
   connect to the engine using another version will result in a
   fault.</TD>
 </TR>

 <TR>
   <TD><B>use-servlet-security</B></TD>

   <TD>Set this flag to hand authentication off to the servlet
   container.</TD>
 </TR><!-- end table -->
  </TABLE>

  <P><A name="individual_service"></P>

  <H2>Individual Service Configuration</H2>

  <P><I>TODO</I></P>

  <P>Here are some of the per-service configuration options are
  available; these can be set in the wsdd file used to deploy a
  service, from where they will be picked up.</P>

  <P>More may exist.</P>

  <TABLE>
 <TR>
   <TD><B>style</B></TD>

   <TD>whether to use RPC:enc or doc/lit encoding</TD>
 </TR>

 <TR>
   <TD><STRONG>SingleSOAPVersion</STRONG></TD>

   <TD>When set to either "1.1" or "1.2", this configures a
   service to only accept the specified SOAP version. Attempts
   to connect to the service using another version will result
   in a fault.</TD>
 </TR>

 <TR>
   <TD><B>wsdlFile</B></TD>

   <TD>The path to a WSDL File; can be an absolute path or a
   resource that axis.jar can load. Useful to export your custom
   WSDL file. When specify a path to a resource, place a forward
   slash to start at the beginning of the classpath (e.g
   "/org/someone/res/mywsdl.wsdl"). How does Axis know whether
   to return a file or resource? It looks for a file first, if
   that is missing a resource is returned.</TD>
 </TR><!-- TODO: what does this mean?
  <tr><td><b>streaming</b></td>
 <td>
 </td>
 </tr>
  -->
  </TABLE>

  <P><A name="axis_logging"></P>

  <H2>Axis Logging Configuration</H2>

  <P>Axis uses the Jakarta Projects's <A href=
  "http://jakarta.apache.org/commons/logging.html">commons-logging
  API</A>, as implemented in <TT>commons-logging.jar</TT> to
  implement logging throughout the code. Normally this library
  routes the logging to the Log4j library, provided that an
  implementation of log4j is on the classpath of the server or
  client. The commons-logging API can also bind to Avalon,
  <TT>System.out</TT> or the Java1.4 logger. The JavaDocs for the
  library explain the process for selecting a logger, which can be
  done via a system property or a properties file in the
  classpath.</P>

  <P>Log4J can be configured using the file log4j.properties in the
  classpath; later versions also support an XML configuration. Axis
  includes a preconfigured log4j.properties file in
  <TT>axis.jar</TT>. While this is adequate for basic use, any
  complex project will want to modify their own version of the
  file. Here is what to do</P>

  <OL>
 <LI>Open up axis.jar in a zipfile viewer and remove
 log4j.properties from the jar</LI>

 <LI>Or, when building your own copy of axis.jar, set the Ant
 property <TT>exclude.log4j.configuration</TT> to keep the
 properties file out the JAR.</LI>

 <LI>Create your own log4J.properties file, and include it in
 <TT>WEB-INF/classes</TT> (server-side), in your main
 application JAR file client side.</LI>

 <LI>Edit this log4J properties file to your hearts content.
 Server side, setting up rolling logs with fancy html output is
 convenient, though once you start clustering the back end
 servers that ceases to be as usuable. Log4J power tools, such
 as 'chainsaw', are the secret here.</LI>
  </OL>

  <H3>Log Categories</H3>

  <P>Axis classes that log information create their own per-class
  log, each of which may output information at different levels.
  For example, the main entry point servlet has a log called
  <TT>org.apache.axis.transport.http.AxisServlet</TT>, the
  AxisEngine is <TT>org.apache.axis.AxisEngine</TT>, and so on.
  There are also special logs for special categories.</P>

  <TABLE border="0">
 <TR>
   <TD valign="top"><TT>org.apache.axis.TIME</TT></TD>

   <TD>A log that records the time to execute incoming messages,
   splitting up into preamble, invoke, post and send times.
   These are only logged at debug level.</TD>
 </TR>

 <TR>
   <TD valign="top"><TT>org.apache.axis.EXCEPTIONS</TT></TD>

   <TD>Exceptions that are sent back over the wire. AxisFaults,
   which are normally created in 'healthy' operation, are logged
   at debug level. Other Exceptions are logged at the Info
   level, as they are more indicative of server side
   trouble.</TD>
 </TR>

 <TR>
   <TD valign="top"><TT>org.apache.axis.enterprise</TT></TD>

   <TD>''Enterprise'' level stuff, which generally means stuff
   that an enterprise product might want to track, but in a
   simple environment (like the Axis build) would be nothing
   more than a nuisance.</TD>
 </TR>
  </TABLE>

  <P><A name="axis_components"></P>

  <H2>Pre-Configured Axis Components Reference</H2>

  <H3>On the server:</H3>

  <DL>
 <DT><B>SimpleSessionHandler</B></DT>

 <DD>uses SOAP headers to do simple session management</DD>

 <DT> </DT>

 <DT><B>LogHandler</B></DT>

 <DD>The LogHandler will simply log a message to a logger when
 it gets invoked.</DD>

 <DT><B>SoapMonitorHandler</B></DT>

 <DD>Provides the hook into the message pipeline sending the
 SOAP request and response messages to the SoapMonitor
 utility.</DD>

 <DT><B>DebugHandler</B></DT>

 <DD>Example handler that demonstrates dynamically setting the
 debug level based on a the value of a soap header element.</DD>

 <DT> </DT>

 <DT><B>ErrorHandler</B></DT>

 <DD>Example handler that throws an AxisFault to stop
 request/response flow processing.</DD>

 <DT> </DT>

 <DT><B>EchoHandler</B></DT>

 <DD>The EchoHandler copies the request message into the
 response message.</DD>

 <DT> </DT>

 <DT><B>HTTPAuth</B></DT>

 <DD>The HTTPAuthHandler takes HTTP-specific authentication
 information (right now, just Basic authentication) and turns it
 into generic MessageContext properties for username and
 password</DD>

 <DT><B>SimpleAuthenticationHandler</B></DT>

 <DD>The SimpleAuthentication handler passes a MessageContext to
 a SecurityProvider (see org.apache.axis.security) to
 authenticate the user using whatever information the
 SecurityProvider wants (right now, just the username and
 password).</DD>

 <DT><B>SimpleAuthorizationHandler</B></DT>

 <DD>This handler, typically deployed alongside the
 SimpleAuthenticationHandler (a chain called "authChecks" is
 predefined for just this combination), checks to make sure that
 the currently authenticated user satisfies one of the allowed
 roles for the target service. Throws a Fault if access is
 denied.</DD>

 <DT><B>MD5AttachHandler</B></DT>

 <DD>Undocumented, uncalled, untested handler that generates an
 MD5 hash of attachment information and adds the value as an
 attribute in the soap body.</DD>

 <DT> </DT>

 <DT><B>URLMapper</B></DT>

 <DD>The URLMapper, an HTTP-specific handler, usually goes on
 HTTP transport chains (it is deployed by default). It serves to
 do service dispatch based on URL - for instance, this is the
 Handler which allows URLs like
 http://localhost:8080/axis/services/MyService?wsdl to
 work.</DD>

 <DT> </DT>

 <DT><B>RPCProvider</B></DT>

 <DD>The RPCProvider is the pivot point for all RPC services. It
 accepts the following options:<BR>
 <B><I>className</I></B> = the class of the backend object to
 invoke<BR>
 <B><I>methodName</I></B> = a space-separated list of methods
 which are exported as web services. The special value "*"
 matches all public methods in the class.</DD>

 <DT><B>MsgProvider</B></DT>

 <DD>The MsgProvider is the pivot point for all messaging
 services. It accepts the following options:<BR></DD>

 <DD><B><I>className</I></B> = the class of the backend object
 to invoke<BR>
 <B><I>methodName</I></B> = a space-separated list of methods
 which are exported as web services. The special value "*"
 matches all public methods in the class.</DD>

 <DT><B>JWSHandler</B></DT>

 <DD>Performs drop-in deployment magic.</DD>

 <DT><B>JAXRPCHandler</B></DT>

 <DD>Wrapper around JAX-RPC compliant handlers that exposes an
 Axis handler interface to the engine.</DD>

 <DT> </DT>

 <DT><B>LocalResponder</B></DT>

 <DD>The LocalResponder is a Handler whose job in life is to
 serialize the response message coming back from a local
 invocation into a String. It is by default on the server's
 local transport response chain, and it ensures that serializing
 the message into String form happens in the context of the
 server's type mappings.</DD>
  </DL>

  <H3>On the client:</H3>

  <DL>
 <DT><B>SimpleSessionHandler</B></DT>

 <DD>uses SOAP headers to do simple session management</DD>

 <DT> </DT>

 <DT><B>JAXRPCHandler</B></DT>

 <DD>Wrapper around JAX-RPC compliant handlers that exposes an
 Axis handler interface to the engine.</DD>

 <DT> </DT>

 <DT><B>HTTPSender</B></DT>

 <DD>A Handler which sends the request message to a remote
 server via HTTP, and collects the response message.</DD>

 <DT><B>LocalSender</B></DT>

 <DD>
   A Handler which sends the request message to a "local"
   AxisServer, which will process it and return a response
   message. This is extremely useful for testing, and is by
   default mapped to the "local:" transport. So, for instance,
   you can test the AdminClient by doing something like
   this:<BR>
   <PRE>
% java org.apache.axis.client.AdminClient -llocal:// list
</PRE>
 </DD>
  </DL>
</BODY>
</HTML>
