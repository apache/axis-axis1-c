<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
  <META name="generator" content=
  "HTML Tidy for Windows (vers 1st October 2003), see www.w3.org">
  <META http-equiv="Content-Type" content=
  "text/html; charset=us-ascii">

  <TITLE>Axis User's Guide</TITLE>
  <LINK href="axis.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>
  <CENTER>
    <H1><IMG src="images/axis.jpg" height="96" width="176"></H1>
  </CENTER>

  <H1>Axis User's Guide</H1>

  <P><I>1.1 Version</I><BR>
  <I>Feedback: <A href=
  "mailto:axis-dev@ws.apache.org">axis-dev@ws.apache.org</A></I></P>

  <H3>Table of Contents</H3>

  <UL>
    <LI><A href="#Introduction">Introduction</A></LI>

    <LI><A href="#Installation">Installing Axis</A></LI>

    <LI><A href="#ConsumingServices">Consuming Web Services with
    Axis</A></LI>

    <LI><A href="#PublishingServices">Publishing Web Services with
    Axis</A></LI>

    <LI><A href="#DataMapping">XML &lt;-&gt; Java Data Mapping in
    Axis</A></LI>

    <LI><A href="#WSDL">Using WSDL with Axis</A></LI>

    <LI style="list-style: none">
      <UL>
        <LI><A href=
        "#WSDL:%20Obtaining%20WSDL%20for%20deployed%20services">?WSDL:
        Obtaining WSDL for deployed services</A></LI>

        <LI><A href=
        "#WSDL2Java:%20Building%20stubs,%20skeletons,%20and%20data">
        WSDL2Java: Building stubs, skeletons, and data</A></LI>

        <LI><A href=
        "#Java2WSDL:%20Building%20WSDL%20from%20Java">Java2WSDL:
        Building WSDL from Java</A></LI>
      </UL>
    </LI>

    <LI><A href="#published%20interfaces">Published
    Interfaces</A></LI>

    <LI><A href="#newbie">Newbie Tips: Finding Your Way
    Around</A></LI>

    <LI><A href="#tcpmon">Appendix : Using TCPMon</A></LI>

    <LI><A href="#soapmon">Appendix : Using SOAP Monitor</A></LI>

    <LI><A href="#Glossary">Glossary</A></LI>
  </UL>

  <H2><A name="Introduction"></A>Introduction</H2>

  <P>Welcome to Axis, the third generation of Apache SOAP!</P>

  <H3>What is SOAP?</H3>

  <P>SOAP is an XML<I>-</I>based communication protocol and
  encoding format for inter-application communication. Originally
  conceived by Microsoft and Userland software, it has evolved
  through several generations and the current spec, <A href=
  "http://w3.org/TR/soap">SOAP 1.1</A>, is fast growing in
  popularity and usage. The W3C's <A href=
  "http://www.w3.org/2000/xp/Group/">XML Protocol working group</A>
  is in the process of turning SOAP into a true open standard, and
  as of this writing has released a working draft of SOAP 1.2,
  which cleans up some of the more confusing areas of the 1.1
  spec.</P>

  <P>SOAP is widely viewed as the backbone to a new generation of
  cross-platform cross-language distributed computing applications,
  termed Web Services.</P>

  <H3>What is Axis?</H3>

  <P>Axis is essentially a <I>SOAP engine</I> -- a framework for
  constructing SOAP processors such as clients, servers, gateways,
  etc. The current version of Axis is written in Java, but a C++
  implementation of the client side of Axis is being developed.</P>

  <P>But Axis isn't just a SOAP engine -- it also includes:</P>

  <UL>
    <LI>a simple stand-alone server,</LI>

    <LI>a server which plugs into servlet engines such as
    Tomcat,</LI>

    <LI>extensive support for the <I>Web Service Description
    Language (WSDL)</I>,</LI>

    <LI>emitter tooling that generates Java classes from WSDL.</LI>

    <LI>some sample programs, and</LI>

    <LI>a tool for monitoring TCP/IP packets.</LI>
  </UL>

  <P>Axis is the third generation of Apache SOAP (which began at
  IBM as "SOAP4J"). In late 2000, the committers of Apache SOAP v2
  began discussing how to make the engine much more flexible,
  configurable, and able to handle both SOAP and the upcoming XML
  Protocol specification from the W3C.</P>

  <P>After a little while, it became clear that a ground-up
  rearchitecture was required. Several of the v2 committers
  proposed very similar designs, all based around configurable
  "chains" of message "handlers" which would implement small bits
  of functionality in a very flexible and composable manner.</P>

  <P>After months of continued discussion and coding effort in this
  direction, Axis now delivers the following key features:</P>

  <UL>
    <LI><B>Speed.</B> Axis uses SAX (event-based) parsing to
    acheive significantly greater speed than earlier versions of
    Apache SOAP.</LI>

    <LI><B>Flexibility.</B> The Axis architecture gives the
    developer complete freedom to insert extensions into the engine
    for custom header processing, system management, or anything
    else you can imagine.</LI>

    <LI><B>Stability.</B> Axis defines a set of <A href=
    "#published%20interfaces">published interfaces</A> which change
    relatively slowly compared to the rest of Axis.</LI>

    <LI><B>Component-oriented deployment.</B> You can easily define
    reusable networks of Handlers to implement common patterns of
    processing for your applications, or to distribute to
    partners.</LI>

    <LI><B>Transport framework.</B> We have a clean and simple
    abstraction for designing transports (i.e., senders and
    listeners for SOAP over various protocols such as SMTP, FTP,
    message-oriented middleware, etc), and the core of the engine
    is completely transport-independent.</LI>

    <LI><B>WSDL support.</B> Axis supports the <A href=
    "http://www.w3.org/TR/wsdl">Web Service Description
    Language</A>, version 1.1, which allows you to easily build
    stubs to access remote services, and also to automatically
    export machine-readable descriptions of your deployed services
    from Axis.</LI>
  </UL>

  <P>We hope you enjoy using Axis. Please note that this is an
  open-source effort - if you feel the code could use some new
  features or fixes, please get involved and lend a hand! The Axis
  developer community welcomes your participation. And in case
  you're wondering what <I>Axis</I> stands for, it's <B>A</B>pache
  E<B>X</B>tensible <B>I</B>nteraction <B>S</B>ystem - a fancy way
  of implying it's a very configurable SOAP engine.</P>

  <H4><B>Let us know what you think!</B></H4>

  <P>Please send feedback about the package to "<A href=
  "mailto:axis-user@ws.apache.org">axis-user@ws.apache.org</A>".
  Also, Axis is registered in <A href=
  "http://nagoya.apache.org/bugzilla">bugzilla</A>, the Apache bug
  tracking and feature-request database.</P>

  <H3>What's in this release?</H3>

  <P>This release includes the following features:</P>

  <UL>
    <LI>SOAP 1.1/1.2 compliant engine</LI>

    <LI>Flexible configuration / deployment system</LI>

    <LI>Support for "drop-in" deployment of SOAP services
    (JWS)</LI>

    <LI>Support for all basic types, and a type mapping system for
    defining new serializers/deserializers</LI>

    <LI>Automatic serialization/deserialization of Java Beans,
    including customizable mapping of fields to XML
    elements/attributes</LI>

    <LI>Automatic two-way conversions between Java Collections and
    SOAP Arrays</LI>

    <LI>Providers for RPC and message based SOAP services</LI>

    <LI>Automatic WSDL generation from deployed services</LI>

    <LI>WSDL2Java tool for building Java proxies and skeletons from
    WSDL documents</LI>

    <LI>Java2WSDL tool for building WSDL from Java classes.</LI>

    <LI>Preliminary security extensions, which can integrate with
    Servlet 2.2 security/roles</LI>

    <LI>Support for session-oriented services, via HTTP cookies or
    transport-independent SOAP headers</LI>

    <LI>Preliminary support for the <B>SOAP with Attachments</B>
    specification</LI>

    <LI>An EJB provider for accessing EJB's as Web Services</LI>

    <LI>HTTP servlet-based transport</LI>

    <LI>JMS based transport</LI>

    <LI>Standalone version of the server (with HTTP support)</LI>

    <LI>Examples, including a client and server for the
    SoapBuilders community interoperability tests and experimental
    TCP, JMS, and file-based transports.</LI>
  </UL>

  <H3>What's still to do?</H3>

  <P>Please click for <A href="to-do.html">a list of what we think
  needs doing</A> - and please consider helping out if you're
  interested &amp; able!</P>

  <H2><A name="Installation"></A>Installing Axis and Using this
  Guide</H2>

  <P>See the <A href="install.html">Axis Installation Guide</A> for
  instructions on installing Axis as a web application on your J2EE
  server.</P>

  <P>Before running the examples in this guide, you'll need to make
  sure that your CLASSPATH includes (Note: If you build Axis from a
  CVS checkout, these will be in xml-axis/java/build/lib instead of
  axis-1_1/lib):</P>

  <UL>
    <LI>axis-1_1/lib/axis.jar</LI>

    <LI>axis-1_1/lib/jaxrpc.jar</LI>

    <LI>axis-1_1/lib/saaj.jar</LI>

    <LI>axis-1_1/lib/commons-logging.jar</LI>

    <LI>axis-1_1/lib/commons-discovery.jar</LI>

    <LI>axis-1_1/lib/wsdl4j.jar</LI>

    <LI>axis-1_1/ <I><FONT color="#9966FF">(for the sample
    code)</FONT></I></LI>

    <LI>A JAXP-1.1 compliant XML parser such as Xerces or
    Crimson</LI>
  </UL>

  <H2><A name="ConsumingServices"></A>Consuming Web Services with
  Axis</H2>

  <H3>Basics - Getting Started</H3>

  <P>Let's take a look at an example Web Service client that will
  call the <B>echoString</B> method on the public Axis server at
  Apache.</P>
  <PRE class="example">
1   import org.apache.axis.client.Call;
2   import org.apache.axis.client.Service;
3   import javax.xml.namespace.QName;
4   
5   public class TestClient {
6      public static void main(String [] args) {
7          try {
8              String endpoint =
9                       "http://nagoya.apache.org:5049/axis/services/echo";
10  
11             Service  service = new Service();
12             Call     call    = (Call) service.createCall();
13  
14             call.setTargetEndpointAddress( new java.net.URL(endpoint) );
15             call.setOperationName(new QName("<FONT color=
"#009933">http://soapinterop.org/</FONT>", "<FONT color=
"#993333">echoString</FONT>"));
16  
17             String ret = (String) call.invoke( new Object[] { "<FONT color="#CC00CC">Hello!</FONT>" } );
18  
19             System.out.println("Sent 'Hello!', got '" + ret + "'");
20         } catch (Exception e) {
21             System.err.println(e.toString());
22         }
23     }
24  }
</PRE>

  <P>(You'll find this file in <A href=
  "../samples/userguide/example1/TestClient.java">samples/userguide/example1/TestClient.java</A>)</P>

  <P>Assuming you have a network connection active, this program
  can be run as follows:</P>
  <PRE class="example">
% java samples.userguide.example1.TestClient
Sent 'Hello!', got 'Hello!'
%
</PRE>

  <P>So what's happening here? On lines 11 and 12 we create new
  Service and Call objects. These are the standard JAX-RPC objects
  that are used to store metadata about the service to invoke. On
  line 14, we set up our endpoint URL - this is the destination for
  our SOAP message. On line 15 we define the operation (method)
  name of the Web Service. And on line 17 we actually invoke the
  desired service, passing in an array of parameters - in this case
  just one String.</P>

  <P>You can see what happens to the arguments by looking at the
  SOAP request that goes out on the wire (look at the colored
  sections, and notice they match the values in the call
  above):</P>
  <PRE class="xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;SOAP-ENV:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;SOAP-ENV:Body&gt;
    &lt;ns1:<B><FONT color=
"#993333">echoString</FONT></B> xmlns:ns1="<B><FONT color=
"#009933">http://soapinterop.org/</FONT></B>"&gt;
      &lt;arg0 xsi:type="xsd:string"&gt;<B><FONT color=
"#CC00CC">Hello!</FONT></B>&lt;/arg0&gt;
    &lt;/ns1:echoString&gt;
  &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
</PRE>

  <P>The String argument is automatically serialized into XML, and
  the server responds with an identical String, which we
  deserialize and print.</P>

  <P><I>Note: To actually watch the XML flowing back and forth
  between a SOAP client and server, you can use the included
  <A href="#tcpmon">tcpmon</A> tool or <A href="#soapmon">SOAP
  monitor</A> tool. See the appendix for an overview.</I></P>

  <H3>Naming Parameters</H3>

  <P>In the above example, you can see that Axis automatically
  names the XML-encoded arguments in the SOAP message "arg0",
  "arg1", etc. (In this case there's just "arg0") If you want to
  change this, it's easy! Before calling <TT>invoke()</TT> you need
  to call <TT>addParameter</TT> for each parameter and
  <TT>setReturnType</TT> for the return, like so:</P>
  <PRE class="example">
  call.addParameter("testParam", 
                    org.apache.axis.Constants.XSD_STRING,
                    javax.xml.rpc.ParameterMode.IN);
  call.setReturnType(org.apache.axis.Constants.XSD_STRING); 
</PRE>

  <P>This will assign the name <B>testParam</B> to the 1st (and
  only) parameter on the invoke call. This will also define the
  type of the parameter
  (<TT>org.apache.axis.Constants.XSD_STRING</TT>) and whether it is
  an input, output or inout parameter - in this case its an input
  parameter. Now when you run the program you'll get a message that
  looks like this:</P>
  <PRE class="xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;SOAP-ENV:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;SOAP-ENV:Body&gt;
    &lt;ns1:echoString xmlns:ns1="http://soapinterop.org/"&gt;
      &lt;<FONT color=
"#CC00CC">testParam</FONT> xsi:type="xsd:string"&gt;Hello!&lt;/<FONT color="#CC00CC">testParam</FONT>&gt;
    &lt;/ns1:echoString&gt;
  &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
</PRE>

  <P>Note that the param is now named "testParam" as expected.</P>

  <H3>Interoperating with "untyped" servers</H3>

  <P>In the above examples, we've been casting the return type of
  invoke(), which is Object, to the appropriate "real" type - for
  instance, we know that the echoString method returns a String, so
  we expect to get one back from client.invoke(). Let's take a
  moment and investigate how this happens, which sheds light on a
  potential problem (to which, of course, we have a solution - so
  don't fret :)).</P>

  <P>Here's what a typical response might look like to the
  echoString method:</P>
  <PRE class="xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;<BR>
 &lt;SOAP-ENV:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
                    xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; 
  &lt;SOAP-ENV:Body&gt;
   &lt;ns1:echoStringResponse xmlns:ns1="http://soapinterop.org/"&gt; 
    &lt;result <FONT color=
"#FF0000">xsi:type="xsd:string"</FONT>&gt;Hello!&lt;/result&gt;
   &lt;/ns1:echoStringResponse&gt; 
  &lt;/SOAP-ENV:Body&gt;
 &lt;/SOAP-ENV:Envelope&gt;
</PRE>

  <P>Take a look at the section which we've highlighted in
  <FONT color="#FF0000">red</FONT> - that attribute is a schema
  <B>type declaration</B>, which Axis uses to figure out that the
  contents of that element are, in this case, deserializable into a
  Java String object. Many toolkits put this kind of explicit
  typing information in the XML to make the message
  "self-describing". On the other hand, some toolkits return
  responses that look like this:</P>
  <PRE class="xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;SOAP-ENV:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
 &lt;SOAP-ENV:Body&gt;
  &lt;ns1:echoStringResponse xmlns:ns1="http://soapinterop.org/"&gt;
   &lt;result&gt;Hello, I'm a string!&lt;/result&gt;
  &lt;/ns1:echoStringResponse&gt;
 &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
</PRE>

  <P>There's no type in the message, so how do we know what Java
  object we should deserialize the &lt;result&gt; element into? The
  answer is <B>metadata</B> - data about data. In this case, we
  need a <B>description</B> of the service that tells us what to
  expect as the return type. Here's how to do it on the client side
  in Axis:</P>
  <PRE class="example">
  call.setReturnType( org.apache.axis.Constants.XSD_STRING );
</PRE>

  <P>This method will tell the Axis client that if the return
  element is not typed then it should act as if the return value
  has an xsi:type attribute set to the predefined SOAP String type.
  (You can see an example of this in action in the interop
  echo-test client - samples/echo/TestClient.java.)</P>

  <P>There is also a similar method which allows you to specify the
  Java class of the expected return type:</P>
  <PRE class="example">
call.setReturnClass(String.class);
</PRE>

  <P>OK - so now you know the basics of accessing SOAP services as
  a client. But how do you publish your own services?</P>

  <H2><A name="PublishingServices"></A>Publishing Web Services with
  Axis</H2>

  <P>Let's say we have a simple class like the following:</P>
  <PRE class="example">
public class Calculator {
  public int add(int i1, int i2)
  {
    return i1 + i2; 
  }
  
  public int subtract(int i1, int i2)
  {
    return i1 - i2;
  }
}
</PRE>

  <P>(You'll find this very class in <A href=
  "../samples/userguide/example2/Calculator.java">samples/userguide/example2/Calculator.java</A>.)</P>

  <P>How do we go about making this class available via SOAP? There
  are a couple of answers to that question, but we'll start with
  the easiest way Axis provides to do this, which takes almost no
  effort at all!</P>

  <H3>JWS (Java Web Service) Files - Instant Deployment</H3>

  <P>OK, here's step 1 : copy the above .java file into your webapp
  directory, and rename it "Calculator.jws". So you might do
  something like this:</P>
  <PRE>
% copy Calculator.java <I><FONT color=
"#0000FF">&lt;your-webapp-root&gt;</FONT></I>/axis/Calculator.jws
</PRE>

  <P>Now for step 2... hm, wait a minute. You're done! You should
  now be able to access the service at the following URL (assuming
  your Axis web application is on port 8080):</P>

  <P><A href=
  "http://localhost:8080/axis/Calculator.jws">http://localhost:8080/axis/Calculator.jws</A></P>

  <P>Axis automatically locates the file, compiles the class, and
  converts SOAP calls correctly into Java invocations of your
  service class. Try it out - there's a calculator client in
  samples/userguide/example2/CalcClient.java, which you can use
  like this:</P>
  <PRE class="example">
% java samples.userguide.example2.CalcClient -p8080 add 2 5
Got result : 7
% java samples.userguide.example2.CalcClient -p8080 subtract 10 9
Got result : 1
%
</PRE>

  <P>(Note that you may need to replace the "-p8080" with whatever
  port your J2EE server is running on)</P>

  <P><I><B>Important:</B></I> JWS web services are intended for
  simple web services. You cannot use packages in the pages, and as
  the code is compiled at run time you can not find out about
  errors until after deployment. Production quality web services
  should use Java classes with custom deployment.</P>

  <H3>Custom Deployment - Introducing WSDD</H3>

  <P>JWS files are great quick ways to get your classes out there
  as Web Services, but they're not always the best choice. For one
  thing, you need the source code - there might be times when you
  want to expose a pre-existing class on your system without
  source. Also, the amount of configuration you can do as to how
  the service gets accessed is pretty limited - you can't specify
  custom type mappings, or control which Handlers get invoked when
  people are using your service. <I>(Note for the future : the Axis
  team, and the Java SOAP community at large, are thinking about
  ways to be able to embed this sort of metadata into your source
  files if desired - stay tuned!)</I></P>

  <H4><A name="descriptors"></A>Deploying via descriptors</H4>

  <P>To really use the flexibility available to you in Axis, you
  should get familiar with the Axis <B>Web Service Deployment
  Descriptor (WSDD)</B> format. A deployment descriptor contains a
  bunch of things you want to "deploy" into Axis - i.e. make
  available to the Axis engine. The most common thing to deploy is
  a Web Service, so let's start by taking a look at a deployment
  descriptor for a basic service (this file is <A href=
  "../samples/userguide/example3/deploy.wsdd">samples/userguide/example3/deploy.wsdd</A>):</P>
  <PRE class="example">
&lt;deployment xmlns="http://xml.apache.org/axis/wsdd/"
            xmlns:java="http://xml.apache.org/axis/wsdd/providers/java"&gt;
 &lt;service name="MyService" provider="java:RPC"&gt;
  &lt;parameter name="className" value="samples.userguide.example3.MyService"/&gt;
  &lt;parameter name="allowedMethods" value="*"/&gt;
 &lt;/service&gt;
&lt;/deployment&gt;
</PRE>

  <P>Pretty simple, really - the outermost element tells the engine
  that this is a WSDD deployment, and defines the "java" namespace.
  Then the service element actually defines the service for us. A
  service is a <B>targeted chain</B> (see the <A href=
  "architecture-guide.html">Architecture Guide</A>), which means it
  may have any/all of: a request flow, a pivot Handler (which for a
  service is called a "provider"), and a response flow. In this
  case, our provider is "java:RPC", which is built into Axis, and
  indicates a Java RPC service. The actual class which handles this
  is <B>org.apache.axis.providers.java.RPCProvider</B>. We'll go
  into more detail later on the different styles of services and
  their providers.</P>

  <P>We need to tell the RPCProvider that it should instantiate and
  call the correct class (e.g.
  samples.userguide.example3.MyService), and we do so by including
  &lt;parameter&gt; tags, giving the service one parameter to
  configure the class name, and another to tell the engine that any
  public method on that class may be called via SOAP (that's what
  the "*" means; we could also have restricted the SOAP-accessible
  methods by using a space or comma separated list of available
  method names).</P>

  <H4>Advanced WSDD - specifying more options</H4>

  <P>WSDD descriptors can also contain other information about
  services, and also other pieces of Axis called "Handlers" which
  we'll cover in a later section.</P>

  <H5>Scoped Services</H5>

  <P>Axis supports scoping service objects (the actual Java objects
  which implement your methods) three ways. "Request" scope, the
  default, will create a new object each time a SOAP request comes
  in for your service. "Application" scope will create a singleton
  shared object to service <B>all</B> requests. "Session" scope
  will create a new object for each session-enabled client who
  accesses your service. To specify the scope option, you add a
  &lt;parameter&gt; to your service like this (where
  "<I><FONT color="#FF0000">value</FONT></I>" is request, session,
  or application):</P>
  <PRE class="xml">
&lt;service name="MyService"...&gt;
  &lt;parameter name="scope" value="<FONT color=
"#FF0000"><I>value</I></FONT>"/&gt;
  ...
&lt;/service&gt;
</PRE>

  <H4>Using the AdminClient</H4>

  <P>Once we have this file, we need to send it to an Axis server
  in order to actually deploy the described service. We do this
  with the AdminClient, or the "org.apache.axis.client.AdminClient"
  class. If you have deployed Axis on a server other than Tomcat,
  you may need to use the -p <EM>&lt;port&gt;</EM> argument. The
  default port is 8080. A typical invocation of the AdminClient
  looks like this:</P>
  <PRE class="example">
% java org.apache.axis.client.AdminClient deploy.wsdd
&lt;Admin&gt;Done processing&lt;/Admin&gt;
</PRE>

  <P>This command has now made our service accessible via SOAP.
  Check it out by running the Client class - it should look like
  this:</P>
  <PRE class="example">
% java samples.userguide.example3.Client -lhttp://localhost:8080/axis/services/MyService "test me!"
You typed : test me!
%
</PRE>

  <P>If you want to prove to yourself that the deployment really
  worked, try undeploying the service and calling it again. 
  There's an "undeploy.wsdd" file in the example3/ directory which
  you can use just as you did the deploy.wsdd file above.  Run the
  AdminClient on that file, then try the service Client again and
  see what happens.</P>

  <P>You can also use the AdminClient to get a listing of all the
  deployed components in the server:</P>
  <PRE class="example">
% java org.apache.axis.client.AdminClient list
&lt;big XML document returned here&gt;
</PRE>

  <P>In there you'll see services, handlers, transports, etc. Note
  that this listing is an exact copy of the server's
  "server-config.wsdd" file, which we'll talk about in more detail
  a little later.</P>

  <H4>More deployment - Handlers and Chains</H4>

  <P>Now let's start to explore some of the more powerful features
  of the Axis engine. Let's say you want to track how many times
  your service has been called. We've included a sample handler in
  the samples/log directory to do just this. To use a handler class
  like this, you first need to deploy the Handler itself, and then
  use the name that you give it in deploying a service. Here's a
  sample deploy.wsdd file (this is example 4 in
  samples/userguide):</P>
  <PRE class="example">
&lt;deployment xmlns="http://xml.apache.org/axis/wsdd/"
            xmlns:java="http://xml.apache.org/axis/wsdd/providers/java"&gt;
  &lt;!-- define the logging handler configuration --&gt;
 &lt;handler name="track" type="java:samples.userguide.example4.LogHandler"&gt;
  &lt;parameter name="filename" value="MyService.log"/&gt;
 &lt;/handler&gt;
 
 &lt;!-- define the service, using the log handler we just defined --&gt;
 &lt;service name="LogTestService"<B> </B>provider="java:RPC"&gt;
  &lt;requestFlow&gt;
   &lt;handler type="track"/&gt;
  &lt;/requestFlow&gt;
 
  &lt;parameter name="className" value="samples.userguide.example4.Service"/&gt;
  &lt;parameter name="allowedMethods" value="*"/&gt;
 &lt;/service&gt;
&lt;/deployment&gt;
</PRE>

  <P>The first section defines a Handler called "track" that is
  implemented by the class samples.userguide.example4.LogHandler.
  We give this Handler an option to let it know which file to write
  its messages into.</P>

  <P>Then we define a service, LogTestService, which is an RPC
  service just like we saw above in our first example. The
  difference is the &lt;requestFlow&gt; element inside the
  &lt;service&gt; - this indicates a set of Handlers that should be
  invoked when the service is invoked, before the provider. By
  inserting a reference to "track", we ensure that the message will
  be logged each time this service is invoked.</P>

  <H4>Remote Administration</H4>

  <P>Note that by default, the Axis server is configured to only
  accept administration requests from the machine on which it
  resides - if you wish to enable remote administration, you must
  set the "enableRemoteAdmin" property of the AdminService to
  <B>true</B>. To do this, find the "server-config.wsdd" file in
  your webapp's WEB-INF directory. In it, you'll see a deployment
  for the AdminService. Add an option as follows:</P>
  <PRE class="xml">
&lt;service name="AdminService" provider="java:MSG"&gt;
  &lt;parameter name="className" value="org.apache.axis.util.Admin"/&gt;
  &lt;parameter name="allowedMethods" value="*"/&gt;
  <B>&lt;parameter name="enableRemoteAdmin" value="true"/&gt;
</B>&lt;/service&gt;
</PRE>

  <P><B>WARNING: enabling remote administration may give
  unauthorized parties access to your machine. If you do this,
  please make sure to add security to your configuration!</B></P>

  <H3>Service Styles - RPC, Document, Wrapped, and Message</H3>

  <P>There are four "styles" of service in Axis. <B>RPC</B>
  services use the SOAP RPC conventions, and also the SOAP "section
  5" encoding. <B>Document</B> services do not use any encoding (so
  in particular, you won't see multiref object serialization or
  SOAP-style arrays on the wire) but DO still do XML&lt;-&gt;Java
  databinding. <B>Wrapped</B> services are just like document
  services, except that rather than binding the entire SOAP body
  into one big structure, they "unwrap" it into individual
  parameters. <B>Message</B> services receive and return arbitrary
  XML in the SOAP Envelope without any type mapping / data binding.
  If you want to work with the raw XML of the incoming and outgoing
  SOAP Envelopes, write a message service.</P>

  <H4>RPC services</H4>

  <P>RPC services are the default in Axis. They are what you get
  when you deploy services with &lt;service ...
  provider="java:RPC"&gt; or &lt;service ... style="RPC"&gt;. RPC
  services follow the SOAP RPC and encoding rules, which means that
  the XML for an RPC service will look like the "echoString"
  example above - each RPC invocation is modeled as an outer
  element which matches the operation name, containing inner
  elements each of which maps to a parameter of the operation. Axis
  will deserialize XML into Java objects which can be fed to your
  service, and will serialize the returned Java object(s) from your
  service back into XML. Since RPC services default to the soap
  section 5 encoding rules, objects will be encoded via "multi-ref"
  serialization, which allows object graphs to be encoded. (See the
  SOAP spec for more on multi-ref serialization.)</P>

  <H4>Document / Wrapped services</H4>

  <P>Document services and wrapped services are similar in that
  neither uses the SOAP encoding for data; it's just plain old XML
  schema. In both cases, however, Axis still "binds" Java
  representations to the XML (see the <A href=
  "#DataMapping">databinding</A> section for more), so you end up
  dealing with Java objects, not directly with XML constructs.</P>

  <P>A good place to start in describing the difference between
  document and wrapped services is with a sample SOAP message
  containing a purchase order:</P>
  <PRE class="xml">
&lt;soap:Envelope xmlns="http://xml.apache.org/axis/wsdd/"
            xmlns:java="http://xml.apache.org/axis/wsdd/providers/java"&gt;
  &lt;soap:Body&gt;
    &lt;myNS:PurchaseOrder xmlns:myNS="http://commerce.com/PO"&gt;
      &lt;item&gt;SK001&lt;/item&gt;
      &lt;quantity&gt;1&lt;/quantity&gt;
      &lt;description&gt;Sushi Knife&lt;/description&gt;
    &lt;/myNS:PurchaseOrder&gt;
  &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
</PRE>

  <P>The relevant schema for the PurchaseOrder looks like this:</P>
  <PRE class="xml">
&lt;schema targetNamespace="http://commerce.com/PO"&gt;
  &lt;complexType name="POType"&gt;
    &lt;sequence&gt;
      &lt;element name="item" type="xsd:string"/&gt;
      &lt;element name="quantity" type="xsd:int"/&gt;
      &lt;element name="description" type="xsd:string"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;
  &lt;element name="PurchaseOrder" type="POType"/&gt;
&lt;/deployment&gt;
</PRE>

  <P>For a <B>document</B> style service, this would map to a
  method like this:</P>

  <P class="example">public void method(PurchaseOrder po)</P>

  <P>In other words, the ENTIRE &lt;PurchaseOrder&gt; element would
  be handed to your method as a single bean with three fields
  inside it. On the other hand, for a <B>wrapped</B> style service,
  it would map to a method like this:</P>

  <P class="example">public void purchaseOrder(String item, int
  quantity, String description)</P>

  <P>Note that in the "wrapped" case, the &lt;PurchaseOrder&gt;
  element is a "wrapper" (hence the name) which only serves to
  indicate the correct operation. The arguments to our method are
  what we find when we "unwrap" the outer element and take each of
  the inner ones as a parameter.</P>

  <P>The document or wrapped style is indicated in WSDD as
  follows:</P>

  <P><SPAN class="example">&lt;service ...
  style="document"&gt;</SPAN> for document style<BR>
  <SPAN class="example">&lt;service ... style="wrapped"&gt;</SPAN>
  for wrapped style</P>

  <P>In most cases you won't need to worry about document or
  wrapped services if you are starting from a WSDL document
  (<A href="#WSDL">see below</A>).</P>

  <H4>Message services</H4>

  <P>Finally, we arrive at "Message" style services, which should
  be used when you want Axis to step back and let your code at the
  actual XML instead of turning it into Java objects. There are
  four valid signatures for your message-style service methods:</P>

  <P><CODE>public Element [] method(Element []
  bodies);</CODE><CODE><BR>
  public SOAPBodyElement [] method (SOAPBodyElement []
  bodies);</CODE><CODE><BR>
  public Document method(Document body);<BR>
  public void method(SOAPEnvelope req, SOAPEnvelope
  resp);</CODE></P>

  <P>The first two will pass your method arrays of either DOM
  Elements or SOAPBodyElements - the arrays will contain one
  element for each XML element inside the &lt;soap:body&gt; in the
  envelope.</P>

  <P>The third signature will pass you a DOM Document representing
  the &lt;soap:body&gt;, and expects the same in return.</P>

  <P>The fourth signature passes you two SOAPEnvelope objects
  representing the request and response messages. This is the
  signature to use if you need to look at or modify headers in your
  service method. Whatever you put into the response envelope will
  automatically be sent back to the caller when you return. Note
  that the response envelope may already contain headers which have
  been inserted by other Handlers.</P>

  <P><B>Message Example</B></P>

  <P>A sample message service can be found in <A href=
  "../samples/message/MessageService.java">samples/message/MessageService.java</A>.
  The service class, <CODE>MessageService</CODE>, has one public
  method, <CODE>echoElements</CODE>, which matches the first of the
  three method signatures above:</P>
  <PRE class="example">
public Element[] echoElements(Element [] elems) 
</PRE>

  <P>The <CODE>MsgProvider</CODE> handler calls the method with an
  array of <CODE>org.w3c.dom.Element</CODE> objects that correspond
  to the immediate children of the incoming message's SOAP Body.
  Often, this array will contain a single Element (perhaps the root
  element of some XML document conforming to some agreed-upon
  schema), but the SOAP Body can handle any number of children. The
  method returns an <CODE>Element[]</CODE> array to be returned in
  the SOAP body of the response message.</P>

  <P>Message services must be deployed with a WSDD file. Here is
  the full WSDD for the <CODE>MessageService</CODE> class:</P>
  <PRE class="XML">
&lt;deployment name="test" xmlns="http://xml.apache.org/axis/wsdd/"
      xmlns:java="http://xml.apache.org/axis/wsdd/providers/java"
      xmlns:xsi="http://www.w3.org/2000/10/XMLSchema-instance"&gt;
        &lt;service name="MessageService" <FONT color=
"#FF0000">style="message"</FONT>&gt;
    &lt;parameter name="className" value="samples.message.MessageService"/&gt;
    &lt;parameter name="allowedMethods" value="echoElements"/&gt;
  &lt;/service&gt;<BR>
&lt;/deployment&gt;
</PRE>

  <P>Note that the "style" attribute is different from the RPC
  deployment example. The "message" style tells Axis that this
  service is to be handled by
  <CODE>org.apache.axis.providers.java.MsgProvider</CODE> rather
  than <CODE>org.apache.axis.providers.java.RPCProvider</CODE>.</P>

  <P>You can test this service by deploying it, then running
  samples.message.TestMsg (look at the source to see what the test
  driver does).</P>

  <H2><A name="DataMapping"></A>XML &lt;-&gt; Java Data Mapping in
  Axis</H2>

  <H3>How your Java types map to SOAP/XML types</H3>

  <P>Interoperability, <I>interop</I>, is an ongoing challenge
  between SOAP implementations. If you want your service to work
  with other platforms and implementations, you do need to
  understand the issues. There are some <A href=
  "reading.html#interop">external articles</A> on the subject that
  act as a good starting place. The basic mapping between Java
  types and WSDL/XSD/SOAP in Axis is determined by the JAX-RPC
  specification. Read chapters 4 and 5 of the <A href=
  "http://java.sun.com/xml/jaxrpc/">specification</A> to fully
  understand how things are converted. Here are some of the salient
  points.</P>

  <H4>Standard mappings from WSDL to Java</H4>

  <TABLE>
    <TR>
      <TD>xsd:base64Binary</TD>

      <TD><TT>byte[]</TT></TD>
    </TR>

    <TR>
      <TD>xsd:boolean</TD>

      <TD><TT>boolean</TT></TD>
    </TR>

    <TR>
      <TD>xsd:byte</TD>

      <TD><TT>byte</TT></TD>
    </TR>

    <TR>
      <TD>xsd:dateTime</TD>

      <TD><TT>java.util.Calendar</TT></TD>
    </TR>

    <TR>
      <TD>xsd:decimal</TD>

      <TD><TT>java.math.BigDecimal</TT></TD>
    </TR>

    <TR>
      <TD>xsd:double</TD>

      <TD><TT>double</TT></TD>
    </TR>

    <TR>
      <TD>xsd:float</TD>

      <TD><TT>float</TT></TD>
    </TR>

    <TR>
      <TD>xsd:hexBinary</TD>

      <TD><TT>byte[]</TT></TD>
    </TR>

    <TR>
      <TD>xsd:int</TD>

      <TD><TT>int</TT></TD>
    </TR>

    <TR>
      <TD>xsd:integer</TD>

      <TD><TT>java.math.BigInteger</TT></TD>
    </TR>

    <TR>
      <TD>xsd:long</TD>

      <TD><TT>long</TT></TD>
    </TR>

    <TR>
      <TD>xsd:QName</TD>

      <TD><TT>javax.xml.namespace.QName</TT></TD>
    </TR>

    <TR>
      <TD>xsd:short</TD>

      <TD><TT>short</TT></TD>
    </TR>

    <TR>
      <TD>xsd:string</TD>

      <TD><TT>java.lang.String</TT></TD>
    </TR>
  </TABLE>

  <P>If the WSDL says that an object can be <TT>nillable</TT>, that
  is the caller may choose to return a value of <TT>nil</TT>, then
  the primitive data types are replaced by their wrapper classes,
  such as Byte, Double, Boolean, etc.</P>

  <H4>SOAP Encoding Datatypes</H4>

  <P>Alongside the XSD datatypes are the SOAP 'Section 5' datatypes
  that are all nillable, and so only ever map to the wrapper
  classes. These types exist because they all support the "ID" and
  "HREF" attributes, and so will be used when in an RPC-encoded
  context to support multi-ref serialization.</P>

  <H3>Exceptions</H3>

  <P>This is an area which causes plenty of confusion, and indeed,
  the author of this section is not entirely sure how everything
  works, especially from an interop perspective. This means treat
  this section as incomplete and potentially inaccurate. See also
  section 5.5.5 and chapter 14 in the JAX-RPC specification</P>

  <H4>RemoteExceptions map to SOAP Faults</H4>

  <P>If the server method throws a
  <TT>java.rmi.RemoteException</TT> then this will be mapped into a
  SOAP Fault. The <TT>faultcode</TT> of this will contain the
  classname of the fault. The recipient is expected to deserialize
  the body of the fault against the classname.</P>

  <P>Obviously, if the recipient does not know how to create an
  instance of the received fault, this mechanism does not work.
  Unless you include information about the exception class in the
  WSDL description of the service, or sender and receiver share the
  implementation, you can only reliably throw
  <TT>java.rmi.RemoteException</TT> instances, rather than
  subclasses.</P>

  <P>When an implementation in another language receives such an
  exception, it should see the name of the class as the faultCode,
  but still be left to parse the body of the exception. You need to
  experiment to find out what happens there.</P>

  <H4>Exceptions are represented as <TT>wsdl:fault</TT>
  elements</H4>

  <P>If a method is marked as throwing an <TT>Exception</TT> that
  is not an instance or a subclass of
  <TT>java.rmi.RemoteException</TT>, then things are subtly
  different. The exception is no longer a SOAP Fault, but described
  as a <TT>wsdl:fault</TT> in the WSDL of the method. According to
  the JAX-RPC specification, your subclass of Exception must have
  accessor methods to access all the fields in the object to be
  marshalled <I>and</I> a constructor that takes as parameters all
  the same fields (i.e, arguments of the same name and type). This
  is a kind of immutable variant of a normal <A href=
  "http://java.sun.com/products/javabeans">JavaBean</A>. The fields
  in the object must be of the datatypes that can be reliably
  mapped into WSDL.</P>

  <P>If your exception meets this specification, then the WSDL
  describing the method will describe the exception too, enabling
  callers to create stub implementations of the exception,
  regardless of platform.</P>

  <P>Again, to be sure of interoperability, you need to be
  experiment a bit. Remember, the calling language may not have the
  notion of Exceptions, or at least not be as rigorous as Java in
  the rules as to how exceptions must be handled.</P>

  <H3>What Axis can send via SOAP with restricted
  Interoperability</H3>

  <H5>Unsigned data</H5>

  <P>You cannot consume or generate services that use unsigned
  datatypes with pure JAX-RPC, because there are no unsigned
  dataypes in Java.</P>

  <P>Axis does have support for the unsigned types, so you can
  consume services written in C++, C# and the like, and
  re-implement interfaces designed for those languages. Be very
  wary about exporting unsigned datatypes, however, as to do so
  will stop Java clients that do not use Axis or another SOAP
  client library with unsigned support from using them. The current
  JAX-RPC specification does not address this issue.</P>

  <H5>Java Collections</H5>

  <P>Some of the Collection classes, such as <TT>Hashtable</TT>, do
  have serializers, but there is no formal interoperability with
  other SOAP implementations, and nothing in the SOAP
  specifications which covers complex objects. The most reliable
  way to send aggregate objects is to use arrays. In particular,
  .NET cannot handle them, though many Java SOAP implementations
  can marshall and unmarshall hash tables.</P>

  <H3>What Axis can not send via SOAP</H3>

  <H5>Arbitrary Objects without Pre-Registration</H5>

  <P>You cannot send arbitrary Java objects over the wire and
  expect them to be understood at the far end. With RMI you can
  send and receive <TT>Serializable</TT> Java objects, but that is
  because you are running Java at both ends. <B>Axis will only send
  objects for which there is a registered Axis serializer.</B> This
  document shows below how to use the BeanSerializer to serialize
  any class that follows the JavaBean pattern of accessor and
  mutator. To serve up objects you must either register your
  classes with this BeanSerializer, or there must be serialization
  support built in to Axis. Remote References Remote references are
  neither part of the SOAP specification, nor the JAX-RPC
  specification. You cannot return some object reference and expect
  the caller to be able to use it as an endpoint for SOAP calls or
  as a parameter in other calls. Instead you must use some other
  reference mechanism, such as storing them in a <TT>HashMap</TT>
  with numeric or string keys that can be passed over the wire.</P>

  <H3>Encoding Your Beans - the BeanSerializer</H3>

  <P>Axis includes the ability to serialize/deserialize, without
  writing any code, arbitrary Java classes which follow the
  standard <A href=
  "http://java.sun.com/products/javabeans">JavaBean</A> pattern of
  get/set accessors. All you need to do is tell Axis which Java
  classes map to which XML Schema types. Configuring a bean mapping
  looks like this:</P>
  <PRE class="xml">
&lt;beanMapping qname="ns:local" xmlns:ns="someNamespace"
             languageSpecificType="java:my.java.thingy"/&gt;
</PRE>

  <P>The &lt;beanMapping&gt; tag maps a Java class (presumably a
  bean) to an XML QName. You'll note that it has two important
  attributes, <B>qname</B> and <B>languageSpecificType</B>. So in
  this case, we'd be mapping the "my.java.thingy" class to the XML
  QName [someNamespace]:[local].</P>

  <P>Let's take a look at how this works in practice. Go look at
  <A href=
  "../samples/userguide/example5/BeanService.java">samples/userguide/example5/BeanService.java</A>.
  The key thing to notice is that the argument to the service
  method is an Order object. Since Order is not a basic type which
  Axis understands by default, trying to run this service without a
  type mapping will result in a fault. (If you want to try this for
  yourself, you can use the bad-deploy.wsdd file in the example5
  directory.) But if we put a beanMapping into our deployment, all
  will be well. Here's how to run this example (from the example5
  directory):</P>
  <PRE class="example">
% java org.apache.axis.client.AdminClient -llocal:///AdminService deploy.wsdd
&lt;Admin&gt;Done processing&lt;/Admin&gt;

% java samples.userguide.example5.Client -llocal://
Hi, Glen Daniels!

You seem to have ordered the following:

1 of item : mp3jukebox
4 of item : 1600mahBattery

If this had been a real order processing system, we'd probably have charged you about now.
%

</PRE>

  <H3>When Beans Are Not Enough - Custom Serialization</H3>

  <P>Just as JWS deployment is sometimes not flexible enough to
  meet all needs, the default bean serialization model isn't robust
  enough to handle every case either. At times there will be
  non-bean Java classes (especially in the case of pre-existing
  assets) which you need to map to/from XML, and there also may be
  some custom XML schema types which you want to map into Java in
  particular ways. Axis gives you the ability to write custom
  serializers/deserializers, and some tools to help make your life
  easier when you do so.</P>

  <P><I><FONT color="#FF0000">TBD - this section will be expanded
  in a future version! For now look at the DataSer/DataDeser
  classes (in samples/encoding). Also look at the BeanSerializer,
  BeanDeserializer, ArraySerializer, ArrayDeserializer and other
  classes in the org.apache.axis.encoding.ser
  package.</FONT></I></P>

  <H4>Deploying custom mappings - the &lt;typeMapping&gt; tag</H4>

  <P>Now that you've built your serializers and deserializers, you
  need to tell Axis which types they should be used for. You do
  this with a typeMapping tag in WSDD, which looks like this:</P>
  <PRE class="xml">
&lt;typeMapping qname="ns:local" xmlns:ns="someNamespace"
             languageSpecificType="java:my.java.thingy"
             serializer="my.java.Serializer"
             deserializer="my.java.DeserializerFactory"
             encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&gt;
</PRE>

  <P>This looks a lot like the &lt;beanMapping&gt; tag we saw
  earlier, but there are three extra attributes. One,
  <B>serializer</B>, is the Java class name of the Serializer
  <I>factory</I> which gets the serializer to be used to marshal an
  object of the specified Java class (i.e., my.java.thingy) into
  XML. Another, <B>deserializer</B>, is the class name of a
  Deserializer <I>factory</I> that gets the deserializer to be used
  to unmarshall XML into the correct Java class. The final
  attribute, the <B>encodingStyle</B>, which is SOAP encoding.</P>

  <P>(The &lt;beanMapping&gt; tag is really just shorthand for a
  &lt;typeMapping&gt; tag with
  <TT>serializer="org.apache.axis.encoding.ser.BeanSerializerFactory"</TT>,
  <TT>deserializer="org.apache.axis.encoding.ser.BeanDeserializerFactory"</TT>,
  and
  <TT>encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"</TT>,
  but clearly it can save a lot of typing!)</P>

  <H2><A name="WSDL"></A>Using WSDL with Axis</H2>

  <P>The <A href="http://www.w3.org/TR/wsdl">Web Service
  Description Language</A> is a specification authored by IBM and
  Microsoft, and supported by many other organizations. WSDL serves
  to describe Web Services in a structured way. A WSDL description
  of a service tells us, in a machine-understandable way, the
  interface to the service, the data types it uses, and where the
  service is located. Please see the spec (follow the link in the
  first sentence) for details about WSDL's format and options.</P>

  <P>Axis supports WSDL in three ways:</P>

  <OL>
    <LI>When you deploy a service in Axis, users may then access
    your service's URL with a standard web browser and by appending
    "?WSDL" to the end of the URL, they will obtain an
    automatically-generated WSDL document which describes your
    service.</LI>

    <LI>We provide a "WSDL2Java" tool which will build Java proxies
    and skeletons for services with WSDL descriptions.</LI>

    <LI>We provide a "Java2WSDL" tool which will build WSDL from
    Java classes.</LI>
  </OL>

  <H3><A name=
  "WSDL: Obtaining WSDL for deployed services"></A>?WSDL: Obtaining
  WSDL for deployed services</H3>

  <P>When you make a service available using Axis, there is
  typically a unique URL associated with that service. For JWS
  files, that URL is simply the path to the JWS file itself. For
  non-JWS services, this is usually the URL
  "http://&lt;host&gt;/axis/services/&lt;service-name&gt;".</P>

  <P>If you access the service URL in a browser, you'll see a
  message indicating that the endpoint is an Axis service, and that
  you should usually access it using SOAP. However, if you tack on
  "?wsdl" to the end of the URL, Axis will automatically generate a
  service description for the deployed service, and return it as
  XML in your browser (try it!). The resulting description may be
  saved or used as input to proxy-generation, described next. You
  can give the WSDL-generation URL to your online partners, and
  they'll be able to use it to access your service with toolkits
  like .NET, SOAP::Lite, or any other software which supports using
  WSDL.</P>

  <P>You can also generate WSDL files from existing Java classes
  (see <A href=
  "#Java2WSDL:%20Building%20WSDL%20from%20Java">Java2WSDL: Building
  WSDL from Java</A> ).<BR>
   </P>

  <H3><A name=
  "WSDL2Java: Building stubs, skeletons, and data"></A>WSDL2Java:
  Building stubs, skeletons, and data types from WSDL</H3>

  <H4>Client-side bindings</H4>

  <P>You'll find the Axis WSDL-to-Java tool in
  "org.apache.axis.wsdl.WSDL2Java". The basic invocation form looks
  like this:</P>
  <PRE class="example">
% java org.apache.axis.wsdl.WSDL2Java (WSDL-file-URL)
</PRE>

  <P>This will generate only those bindings necessary for the
  client.  Axis follows the JAX-RPC specification when generating
  Java client bindings from WSDL.  For this discussion, assume we
  executed the following:</P>
  <PRE class="example">
% cd samples/addr
% java org.apache.axis.wsdl.WSDL2Java AddressBook.wsdl
</PRE>

  <P>The generated files will reside in the directory
  "AddressFetcher2".  They are put here because that is the target
  namespace from the WSDL and namespaces map to Java packages. 
  Namespaces will be discussed in detail later.</P>

  <TABLE border cols="2" width="100%">
    <TR>
      <TD><B>WSDL clause</B></TD>

      <TD><B>Java class(es) generated</B></TD>
    </TR>

    <TR>
      <TD>For each entry in the type section</TD>

      <TD>A java class</TD>
    </TR>

    <TR>
      <TD></TD>

      <TD>A holder if this type is used as an inout/out
      parameter</TD>
    </TR>

    <TR>
      <TD>For each portType</TD>

      <TD>A java interface</TD>
    </TR>

    <TR>
      <TD>For each binding</TD>

      <TD>A stub class</TD>
    </TR>

    <TR>
      <TD>For each service</TD>

      <TD>A service interface</TD>
    </TR>

    <TR>
      <TD></TD>

      <TD>A service implementation (the locator)</TD>
    </TR>
  </TABLE>

  <P>There is an <A href="ant/axis-wsdl2java.html">Ant Task</A> to
  integrate this action with an Ant based build process.</P>

  <H4>Types</H4>

  <P>The Java class generated from a WSDL type will be named from
  the WSDL type.  This class will typically, though not always, be
  a bean.  For example, given the WSDL (the WSDL used throughout
  the WSDL2Java discussion is from the <A href=
  "../samples/addr/AddressBook.wsdl">Address Book sample</A>):</P>
  <PRE class="example">
&lt;xsd:complexType name="phone"&gt;
  &lt;xsd:all&gt;
    &lt;xsd:element name="areaCode" type="xsd:int"/&gt;
    &lt;xsd:element name="exchange" type="xsd:string"/&gt;
    &lt;xsd:element name="number" type="xsd:string"/&gt;
  &lt;/xsd:all&gt;
&lt;/xsd:complexType&gt;
</PRE>

  <P>WSDL2Java will generate:</P>
  <PRE class="example">
public class Phone implements java.io.Serializable {
    public Phone() {...}
    public int getAreaCode() {...}
    public void setAreaCode(int areaCode) {...}
    public java.lang.String getExchange() {...}
    public void setExchange(java.lang.String exchange) {...}
    public java.lang.String getNumber() {...}
    public void setNumber(java.lang.String number) {...}
    public boolean equals(Object obj) {...}
    public int hashCode() {...}
}
</PRE>

  <H4>Mapping XML to Java types : Metadata</H4>

  <P>Notice in the mapping above, the XML type name is "phone" and
  the generated Java class is "Phone" - the capitalization of the
  first letter has changed to match the Java coding convention that
  classes begin with an uppercase letter. This sort of thing
  happens a lot, because the rules for expressing XML
  names/identifiers are much less restrictive than those for Java.
  For example, if one of the sub-elements in the "phone" type above
  was named "new", we couldn't just generate a Java field called
  "new", since that is a reserved word and the resultant source
  code would fail to compile.</P>

  <P>To support this kind of mapping, and also to enable the
  serialization/deserialization of XML attributes, we have a
  <B>type metadata</B> system which allows us to associate Java
  data classes with descriptors which control these things.</P>

  <P>When the WSDL2Java tool creates a data bean like the Phone
  class above, it notices if the schema contains any attributes, or
  any names which do not map directly to Java field/property names.
  If it finds any of these things, it will generate a static piece
  of code to supply a <B>type descriptor</B> for the class. The
  type descriptor is essentially a collection of <B>field
  descriptors</B>, each of which maps a Java field/property to an
  XML element or attribute.</P>

  <P>To see an example of this kind of metadata, look at the
  "test.encoding.AttributeBean" class in the Axis source, or
  generate your own bean from XML which uses attributes or names
  which would be illegal in Java.</P>

  <H4>Holders</H4>

  <P>This type may be used as an inout or out parameter.  Java does
  not have the concept of inout/out parameters.  In order to
  achieve this behavior, JAX-RPC specifies the use of holder
  classes.  A holder class is simply a class that contains an
  instance of its type.  For example, the holder for the Phone
  class would be:</P>
  <PRE class="example">
package samples.addr.holders;
public final class PhoneHolder implements javax.xml.rpc.holders.Holder {
    public samples.addr.Phone value;

    public PhoneHolder()
    {
    }

    public PhoneHolder(samples.addr.Phone value) {
        this.value = value;
    }
}
</PRE>

  <P>A holder class is <B>only</B> generated for a type if that
  type is used as an inout or out parameter. Note that the holder
  class has the suffix "Holder" appended to the class name, and it
  is generated in a sub-package with the "holders".</P>

  <P>The holder classes for the primitive types can be found in
  javax.xml.rpc.holders.</P>

  <H4>PortTypes</H4>

  <P>The Service Definition Interface (SDI) is the interface that's
  derived from a WSDL's portType.  This is the interface you use to
  access the operations on the service.  For example, given the
  WSDL:</P>
  <PRE class="example">
&lt;message name="empty"&gt;
&lt;message name="AddEntryRequest"&gt;
  &lt;part name="name" type="xsd:string"/&gt;
  &lt;part name="address" type="typens:address"/&gt;
&lt;/message&gt;
&lt;portType name="AddressBook"&gt;
  &lt;operation name="addEntry"&gt;
    &lt;input message="tns:AddEntryRequest"/&gt;
    &lt;output message="tns:empty"/&gt;
  &lt;/operation&gt;
&lt;/portType&gt;
</PRE>

  <P>WSDL2Java will generate:</P>
  <PRE class="example">
public interface AddressBook extends java.rmi.Remote {
    public void addEntry(String name, Address address) throws java.rmi.RemoteException;
}
</PRE>

  <P>A note about the name of the SDI. The name of the SDI is
  typically the name of the portType. However, to construct the
  SDI, WSDL2Java needs information from both the portType
  <B>and</B> the binding. (This is unfortunate and is a topic of
  discussion for WSDL version 2.)</P>

  <P>JAX-RPC says (section 4.3.3): "The name of the Java interface
  is mapped from the name attribute of the wsdl:portType element.
  ... If the mapping to a service definition interface uses
  elements of the wsdl:binding ..., then the name of the service
  definition interface is mapped from the name of the wsdl:binding
  element."</P>

  <P>Note the name of the spec. It contains the string "RPC". So
  this spec, and WSDL2Java, assumes that the interface generated
  from the portType is an RPC interface. If information from the
  binding tells us otherwise (in other words, we use elements of
  the wsdl:binding), then the name of the interface is derived
  instead from the binding.</P>

  <P>Why? We could have one portType - pt - and two bindings - bRPC
  and bDoc. Since document/literal changes what the interface looks
  like, we cannot use a single interface for both of these
  bindings, so we end up with two interfaces - one named pt and
  another named bDoc - and two stubs - bRPCStub (which implements
  pt) and bDocStub (which implements bDoc).</P>

  <P>Ugly, isn't it? But you can see why it's necessary. Since
  document/literal changes what the interface looks like, and we
  could have more than one binding referring to a single portType,
  we have to create more than one interface, and each interface
  must have a unique name.<BR>
   </P>

  <H4>Bindings</H4>

  <P>A Stub class implements the SDI.  Its name is the binding name
  with the suffix "Stub".  It contains the code which turns the
  method invocations into SOAP calls using the Axis Service and
  Call objects.  It stands in as a <B>proxy</B> (another term for
  the same idea) for the remote service, letting you call it
  exactly as if it were a local object. In other words, you don't
  need to deal with the endpoint URL, namespace, or parameter
  arrays which are involved in dynamic invocation via the Service
  and Call objects. The stub hides all that work for you.</P>

  <P>Given the following WSDL snippet:</P>
  <PRE class="example">
&lt;binding name="AddressBookSOAPBinding" type="tns:AddressBook"&gt;
  ...
&lt;/binding&gt;
</PRE>

  <P>WSDL2Java will generate:</P>
  <PRE class="example">
public class AddressBookSOAPBindingStub extends org.apache.axis.client.Stub
                                        implements AddressBook {
    public AddressBookSOAPBindingStub() throws org.apache.axis.AxisFault
    {...}

    public AddressBookSOAPBindingStub(URL endpointURL, 
                                      javax.xml.rpc.Service service)
        throws org.apache.axis.AxisFault
    {...}
<BR>
    public AddressBookSOAPBindingStub(javax.xml.rpc.Service service)
        throws org.apache.axis.AxisFault
    {...}
<BR>
    public void addEntry(String name, Address address) throws RemoteException
    {...}<BR>
}
</PRE>

  <H4>Services</H4>

  <P>Normally, a client program would not instantiate a stub
  directly.  It would instead instantiate a service locator and
  call a get method which returns a stub.  This locator is derived
  from the service clause in the WSDL.  WSDL2Java generates two
  objects from a service clause.  For example, given the WSDL:</P>
  <PRE class="example">
&lt;service name="AddressBookService"&gt;
  &lt;port name="AddressBook" binding="tns:AddressBookSOAPBinding"&gt;
    &lt;soap:address location="http://localhost:8080/axis/services/AddressBook"/&gt;
  &lt;/port&gt;
&lt;/service&gt;
</PRE>

  <P>WSDL2Java will generate the service interface:</P>
  <PRE class="example">
public interface AddressBookService extends javax.xml.rpc.Service {
    public String getAddressBookAddress();
<BR>
    public AddressBook getAddressBook() throws javax.xml.rpc.ServiceException;
<BR>
    public AddressBook getAddressBook(URL portAddress) throws javax.xml.rpc.ServiceException;
}
</PRE>

  <P>WSDL2Java will also generate the locator which implements this
  interface:</P>
  <PRE class="example">
public class AddressBookServiceLocator extends org.apache.axis.client.Service
                                       implements AddressBookService {
    ...
}
</PRE>

  <P>The service interface defines a get method for each port
  listed in the service element of the WSDL. The locator is the
  implementation of this service interface.  It implements these
  get methods. It serves as a locator for obtaining Stub instances.
  The Service class will by default make a Stub which points to the
  endpoint URL described in the WSDL file, but you may also specify
  a different URL when you ask for the PortType.</P>

  <P>A typical usage of the stub classes would be as follows:</P>
  <PRE class="example">
public class Tester
{
    public static void main(String [] args) throws Exception {
        // Make a service
        AddressBookService service = new AddressBookServiceLocator();
 
        // Now use the service to get a stub which implements the SDI.
        AddressBook port = service.getAddressBook();
 
        // Make the actual call
        Address address = new Address(...);
        port.addEntry("Russell Butek", address);
    }<BR>
}
</PRE>

  <H4>Server-side bindings</H4>

  <P>Just as a stub is the client side of a Web Service represented
  in Java, a <B>skeleton</B> is a Java framework for the server
  side.  To make skeleton classes, you just specify the
  "--server-side --skeletonDeploy true" options to WSDL2Java. For
  instance, using the AddressBook.wsdl as we had above:</P>
  <PRE class="example">
% java org.apache.axis.wsdl.WSDL2Java --server-side --skeletonDeploy true AddressBook.wsdl
</PRE>

  <P>You will see that WSDL2Java generates all the classes that
  were generated before for the client, but it generates a few new
  files:<BR>
   <BR>
   </P>

  <TABLE border cols="2" width="100%">
    <TR>
      <TD><B>WSDL clause</B></TD>

      <TD><B>Java class(es) generated</B></TD>
    </TR>

    <TR>
      <TD>For each binding</TD>

      <TD>A skeleton class</TD>
    </TR>

    <TR>
      <TD></TD>

      <TD>An implementation template class</TD>
    </TR>

    <TR>
      <TD>For all services</TD>

      <TD>One deploy.wsdd file</TD>
    </TR>

    <TR>
      <TD></TD>

      <TD>One undeploy.wsdd file</TD>
    </TR>
  </TABLE>

  <P>If you don't specify the "--skeletonDeploy true" option, a
  skeleton will not be generated. Instead, the generated
  deploy.wsdd will indicate that the implementation class is
  deployed directly. In such cases, the deploy.wsdd contains extra
  meta data describing the operations and parameters of the
  implementation class. Here is how you run WSDL2Java to deploy
  directly to the implementation:</P>
  <PRE class="example">
% java org.apache.axis.wsdl.WSDL2Java --server-side AddressBook.wsdl
</PRE>

  <P>And here are the server side files that are generated:<BR>
   <BR>
   </P>

  <TABLE border cols="2" width="100%">
    <TR>
      <TD><B>WSDL clause</B></TD>

      <TD><B>Java class(es) generated</B></TD>
    </TR>

    <TR>
      <TD>For each binding</TD>

      <TD>An implementation template class</TD>
    </TR>

    <TR>
      <TD>For all services</TD>

      <TD>One deploy.wsdd file with operation meta data</TD>
    </TR>

    <TR>
      <TD></TD>

      <TD>One undeploy.wsdd file</TD>
    </TR>
  </TABLE>

  <H4>Bindings</H4>

  <H5>Skeleton Description (for Skeleton Deployment)</H5>

  <P>The skeleton class is the class that sits between the Axis
  engine and the actual service implementation.  Its name is the
  binding name with suffix "Skeleton".  For example, for the
  AddressBook binding, WSDL2Java will generate:</P>
  <PRE class="example">
public class AddressBookSOAPBindingSkeleton implements AddressBook,
                                                       org.apache.axis.wsdl.Skeleton {
    private AddressBook impl;
 
    public AddressBookSOAPBindingSkeleton() {
        this.impl = new AddressBookSOAPBindingImpl();
    }
 
    public AddressBookSOAPBindingSkeleton(AddressBook impl) {
        this.impl = impl;
    }
 
    public void addEntry(java.lang.String name, Address address)
        throws java.rmi.RemoteException
    {
        impl.addEntry(name, address);
    }
}
</PRE>

  <P>(The real skeleton is actually much richer.  For brevity we
  just show you the basic skeleton.)</P>

  <P>The skeleton contains an implementation of the AddressBook
  service.  This implementation is either passed into the skeleton
  on construction, or an instance of the generated implementation
  is created.  When the Axis engine calls the skeleton's addEntry
  method, it simply delegates the invocation to the real
  implementation's addEntry method.</P>

  <H5>Implementation Template Description</H5>

  <P>WSDL2Java also generates an implementation template from the
  binding:</P>
  <PRE class="example">
public class AddressBookSOAPBindingImpl implements AddressBook {
<BR>
    public void addEntry(String name, Address address)
        throws java.rmi.RemoteException {
    }
}
</PRE>

  <P>This template could actually be used as a test implementation
  but, as you can see, it doesn't do anything.  It is intended that
  the service writer fill out the implementation from this
  template.</P>

  <P>When WSDL2Java is asked to generate the implementation
  template (via the --server-side flag), it will ONLY generate it
  if it does not already exist.  If this implementation already
  exists, it will not be overwritten.</P>

  <H4>Services</H4>

  <P>The tool also builds you a "deploy.wsdd" and an
  "undeploy.wsdd" for each service for use with the AdminClient.
  These files may be used to deploy the service once you've filled
  in the methods of the Implementation class, compiled the code,
  and made the classes available to your Axis engine.</P>

  <H3><A name="Java2WSDL: Building WSDL from Java"></A>Java2WSDL:
  Building WSDL from Java</H3>

  <P>The Java2WSDL and WSDL2Java emitters make it easy to develop a
  new web service. The following sections describe the steps in
  building a web service from a Java interface.<BR>
   </P>

  <H4>Step 1: Provide a Java interface or class</H4>

  <P>Write and compile a Java interface (or class) that describes
  the web service interface.  Here is an example interface that
  describes a web services that can be used to set/query the price
  of widgets (<A href=
  "../samples/userguide/example6/WidgetPrice.java">samples/userguide/example6/WidgetPrice.java</A>):</P>
  <PRE class="example">
package samples.userguide.example6;
<BR>
/**
 * Interface describing a web service to set and get Widget prices.
 **/
public interface WidgetPrice {
    public void setWidgetPrice(String widgetName, String price);
    public String getWidgetPrice(String widgetName);
}
</PRE>

  <P><B>Note:</B> If you compile your class with debug information,
  Java2WSDL will use the debug information to obtain the method
  parameter names.</P>

  <H4>Step 2: Create WSDL using Java2WSDL</H4>

  <P>Use the Java2WSDL tool to create a WSDL file from the
  interface above.</P>

  <P>Here is an example invocation that produces the wsdl file
  (<TT>wp.wsdl</TT>) from the interface described in the previous
  section:</P>
  <PRE class="example">
% java org.apache.axis.wsdl.Java2WSDL -o wp.wsdl  -l"http://localhost:8080/axis/services/WidgetPrice" -n  "urn:Example6" -p"samples.userguide.example6" "urn:Example6"  samples.userguide.example6.WidgetPrice
</PRE>

  <P>Where:</P>

  <UL>
    <LI>-o indicates the name of the <B><I>output WSDL</I></B>
    file</LI>

    <LI>-l indicates the<B><I>location of the service</I></B></LI>

    <LI>-n is the target <B><I>namespace</I></B> of the WSDL
    file</LI>

    <LI>-p indicates a mapping from the <B><I>package to a
    namespace</I></B>.  There may be multiple mappings.</LI>

    <LI>the class specified contains the interface of the
    webservice.</LI>
  </UL>

  <P>The output WSDL document will contain the appropriate WSDL
  types, messages, portType, bindings and service descriptions to
  support a SOAP rpc, encoding web service.  If your specified
  interface methods reference other classes, the Java2WSDL tool
  will generate the appropriate xml types to represent the classes
  and any nested/inherited types.  The tool supports JAX-RPC
  complex types (bean classes), extension classes, enumeration
  classes, arrays and Holder classes.</P>

  <P>The Java2WSDL tool has many additional options which are
  detailed in the <A href="reference.html#Java2WSDL">reference
  guide</A>. There is an <A href="ant/axis-java2wsdl.html">Ant
  Task</A> to integrate this action with an Ant based build
  process.</P>

  <H4>Step 3: Create Bindings using WSDL2Java</H4>

  <P>Use the generated WSDL file to build the appropriate
  client/server bindings for the web service (see <A href=
  "#WSDL2Java:%20Building%20stubs,%20skeletons,%20and%20data">WSDL2Java</A>):</P>
  <PRE class="example">
% java org.apache.axis.wsdl.WSDL2Java -o . -d Session -s -S true  -Nurn:Example6 samples.userguide.example6 wp.wsdl
</PRE>

  <P>This will generate the following files:</P>

  <UL>
    <LI><B><TT>WidgetPriceSoapBindingImpl.java</TT></B> : Java file
    containing the default server implementation of the WidgetPrice
    web service.</LI>

    <LI style="list-style: none"><BR>
    You will need to modify the *SoapBindingImpl file to add your
    implementation (see  <A href=
    "../samples/userguide/example6/WidgetPriceSoapBindingImpl.java">
    ../samples/userguide/example6/WidgetPriceSoapBindingImpl.java</A>
    ).</LI>

    <LI><B><TT>WidgetPrice.java</TT></B>:  New interface file that
    contains the appropriate <B><TT>java.rmi.Remote</TT></B>
    usages.</LI>

    <LI><B><TT>WidgetPriceService.java</TT></B>: Java file
    containing the client side service interface.</LI>

    <LI><B><TT>WidgetPriceServiceLocator.java</TT></B>: Java file
    containing the client side service implementation class.</LI>

    <LI><B><TT>WidgetPriceSoapBindingSkeleton.java</TT></B>: Server
    side skeleton.</LI>

    <LI><B><TT>WidgetPriceSoapBindingStub.java</TT></B>: Client
    side stub.</LI>

    <LI><B><TT>deploy.wsdd</TT></B>: Deployment descriptor</LI>

    <LI><B><TT>undeploy.wsdd</TT></B>: Undeployment descriptor</LI>

    <LI>(data types):  Java files will be produced for all of the
    other types and holders necessary for the web service.  There
    are no additional files for the WidgetPrice web service.</LI>
  </UL>

  <P>Now you have all of the necessary files to build your
  client/server side code and deploy the web service!</P>

  <H2><A name="published interfaces"></A>Published Axis
  Interfaces</H2>

  <P>Although you may use any of the interfaces and classes present
  in Axis, you need to be aware that some are more stable than
  others since there is a continuing need to refactor Axis to
  maintain and improve its modularity.</P>

  <P>Hence certain interfaces are designated as <I>published</I>,
  which means that they are relatively stable. As Axis is
  refactored, the Axis developers will try to avoid changing
  published interfaces unnecessarily and will certainly consider
  the impact on users of any modifications.</P>

  <P>So if you stick to using only published interfaces, you'll
  minimise the pain of migrating between releases of Axis. On the
  other hand, if you decide to use unpublished interfaces,
  migrating between releases could be an interesting exercise! If
  you would like an interface to be published, you should make the
  case for this on the <A href=
  "mailto:axis-user@ws.apache.org">axis-user</A> mailing list.</P>

  <P>The current list of published interfaces is as follows:</P>

  <UL>
    <LI>JAX-RPC interfaces. These interfaces are from JAX-RPC 1.0
    specification, and will change only when new versions of the
    specification are released.

      <UL>
        <LI>javax.xml.messaging.Endpoint</LI>

        <LI>javax.xml.messaging.URLEndpoint</LI>

        <LI>javax.xml.rpc.Call</LI>

        <LI>javax.xml.rpc.FaultException</LI>

        <LI>javax.xml.rpc.JAXRPCException</LI>

        <LI>javax.xml.rpc.ParameterMode</LI>

        <LI>javax.xml.rpc.Service</LI>

        <LI>javax.xml.rpc.ServiceException</LI>

        <LI>javax.xml.rpc.ServiceFactory</LI>

        <LI>javax.xml.rpc.Stub</LI>

        <LI>javax.xml.rpc.encoding.DeserializationContext</LI>

        <LI>javax.xml.rpc.encoding.Deserializer</LI>

        <LI>javax.xml.rpc.encoding.DeserializerFactory</LI>

        <LI>javax.xml.rpc.encoding.SerializationContext</LI>

        <LI>javax.xml.rpc.encoding.Serializer</LI>

        <LI>javax.xml.rpc.encoding.SerializerFactory</LI>

        <LI>javax.xml.rpc.encoding.TypeMapping</LI>

        <LI>javax.xml.rpc.encoding.TypeMappingRegistry</LI>

        <LI>javax.xml.rpc.handler.Handler</LI>

        <LI>javax.xml.rpc.handler.HandlerChain</LI>

        <LI>javax.xml.rpc.handler.HandlerInfo</LI>

        <LI>javax.xml.rpc.handler.HandlerRegistry</LI>

        <LI>javax.xml.rpc.handler.MessageContext</LI>

        <LI>javax.xml.rpc.handler.soap.SOAPMessageContext</LI>

        <LI>javax.xml.rpc.holders.BigDecimalHolder</LI>

        <LI>javax.xml.rpc.holders.BigIntegerHolder</LI>

        <LI>javax.xml.rpc.holders.BooleanHolder</LI>

        <LI>javax.xml.rpc.holders.BooleanWrapperHolder</LI>

        <LI>javax.xml.rpc.holders.ByteArrayHolder</LI>

        <LI>javax.xml.rpc.holders.ByteHolder</LI>

        <LI>javax.xml.rpc.holders.ByteWrapperArrayHolder</LI>

        <LI>javax.xml.rpc.holders.ByteWrapperHolder</LI>

        <LI>javax.xml.rpc.holders.CalendarHolder</LI>

        <LI>javax.xml.rpc.holders.DateHolder</LI>

        <LI>javax.xml.rpc.holders.DoubleHolder</LI>

        <LI>javax.xml.rpc.holders.DoubleWrapperHolder</LI>

        <LI>javax.xml.rpc.holders.FloatHolder</LI>

        <LI>javax.xml.rpc.holders.FloatWrapperHolder</LI>

        <LI>javax.xml.rpc.holders.Holder</LI>

        <LI>javax.xml.rpc.holders.IntHolder</LI>

        <LI>javax.xml.rpc.holders.IntegerWrapperHolder</LI>

        <LI>javax.xml.rpc.holders.LongHolder</LI>

        <LI>javax.xml.rpc.holders.LongWrapperHolder</LI>

        <LI>javax.xml.rpc.holders.ObjectHolder</LI>

        <LI>javax.xml.rpc.holders.QNameHolder</LI>

        <LI>javax.xml.rpc.holders.ShortHolder</LI>

        <LI>javax.xml.rpc.holders.ShortWrapperHolder</LI>

        <LI>javax.xml.rpc.holders.StringHolder</LI>

        <LI>javax.xml.rpc.namespace.QName</LI>

        <LI>javax.xml.rpc.server.ServiceLifecycle</LI>

        <LI>javax.xml.rpc.soap.SOAPFault</LI>

        <LI>javax.xml.rpc.soap.SOAPHeaderFault</LI>

        <LI>javax.xml.transform.Source</LI>
      </UL>
    </LI>

    <LI>Axis interfaces. These have less guarantees of stability:

      <UL>
        <LI>org.apache.axis.AxisFault</LI>

        <LI>org.apache.axis.Handler</LI>

        <LI>org.apache.axis.DefaultEngineConfigurationFactory</LI>

        <LI>org.apache.axis.EngineConfiguration</LI>

        <LI>org.apache.axis.EngineConfigurationFactory</LI>

        <LI>org.apache.axis.Message</LI>

        <LI>org.apache.axis.MessageContext</LI>

        <LI>org.apache.axis.SOAPPart</LI>

        <LI>org.apache.axis.client.Call</LI>

        <LI>org.apache.axis.client.Service</LI>

        <LI>org.apache.axis.client.ServiceFactory</LI>

        <LI>org.apache.axis.client.Stub</LI>

        <LI>org.apache.axis.client.Transport</LI>

        <LI>org.apache.axis.description.TypeDesc</LI>

        <LI>org.apache.axis.description.AttributeDesc</LI>

        <LI>org.apache.aixs.description.ElementDesc</LI>

        <LI>org.apache.axis.encoding.DeserializationContext</LI>

        <LI>org.apache.axis.encoding.Deserializer</LI>

        <LI>org.apache.axis.encoding.DeserializerFactory</LI>

        <LI>org.apache.axis.encoding.DeserializerTarget</LI>

        <LI>org.apache.axis.encoding.FieldTarget</LI>

        <LI>org.apache.axis.encoding.MethodTarget</LI>

        <LI>org.apache.axis.encoding.SerializationContext</LI>

        <LI>org.apache.axis.encoding.Serializer</LI>

        <LI>org.apache.axis.encoding.SerializerFactory</LI>

        <LI>org.apache.axis.encoding.SimpleType</LI>

        <LI>org.apache.axis.encoding.Target</LI>

        <LI>org.apache.axis.encoding.TypeMapping</LI>

        <LI>org.apache.axis.encoding.TypeMappingRegistry</LI>

        <LI>
        org.apache.axis.encoding.ser.BaseDeserializerFactory</LI>

        <LI>org.apache.axis.encoding.ser.BaseSerializerFactory</LI>

        <LI>org.apache.axis.encoding.ser.BeanPropertyTarget</LI>

        <LI>org.apache.axis.encoding.ser.SimpleSerializer</LI>

        <LI>org.apache.axis.encoding.ser.SimpleDeserializer</LI>

        <LI>org.apache.axis.session.Session</LI>

        <LI>org.apache.axis.transport.http.SimpleAxisServer</LI>

        <LI>org.apache.axis.transport.jms.SimpleJMSListener</LI>

        <LI>org.apache.axis.utils.BeanProperty</LI>

        <LI>org.apache.axis.wsdl.WSDL2Java</LI>

        <LI>org.apache.axis.wsdl.Java2WSDL</LI>
      </UL>
    </LI>
  </UL>

  <H2><A name="newbie"></A>Newbie Tips: Finding Your Way
  Around</H2>

  <P>So you've skimmed the User's Guide and written your first .jws
  service, and everything went perfectly! Now it's time to get to
  work on a real project, and you have something specific you need
  to do that the User's Guide didn't cover. It's a simple thing,
  and you know it must be in Axis <EM>somewhere</EM>, but you don't
  know what it's called or how to get at it. This section is meant
  to give you some starting points for your search.</P>

  <H3>Places to Look for Clues</H3>

  <P>Here are the big categories.</P>

  <UL>
    <LI><A href="../samples/"><B>The samples.</B></A> These
    examples are complete with deployment descriptors and often
    contain both client and server code.</LI>

    <LI><B>The Javadocs.</B> Full Javadocs are included with the
    binary distribution. The Javadocs can be intimidating at first,
    but once you know the major user classes, they are one of the
    fastest ways to an answer.</LI>

    <LI><B><A href="http://ws.apache.org/axis/mail.html">The
    mailing list archives.</A></B> If you know what you want but
    don't know what it's called in Axis, this is the best place to
    look. Chances are someone has wanted the same thing and someone
    else has used (or developed) Axis long enough know the
    name.</LI>

    <LI>Consult the <A href="http://ws.apache.org/axis">Axis web
    site</A> for updated documentation and the <A href=
    "http://nagoya.apache.org/wiki/apachewiki.cgi?AxisProjectPages">
    Axis Wiki</A> for its Frequently Asked Questions (FAQ),
    installation notes, interoperability issues lists, and other
    useful information.</LI>

    <LI><B>WSDL2Java.</B> Point WSDL2Java at a known webservice
    that does some of the things you want to do. See what comes
    out. This is useful even if you will be writing the actual
    service or client from scratch. If you want nice,
    human-readable descriptions of existing web services, try
    <A href=
    "http://www.xmethods.net">http://www.xmethods.net</A>.</LI>
  </UL>

  <H3>Classes to Know</H3>

  <H4>org.apache.axis.MessageContext</H4>

  <P>The answer to most "where do I find..." questions for an Axis
  web service is "in the MessageContext." Essentially everything
  Axis knows about a given request/response can be retrieved via
  the MessageContext. Here Axis stores:</P>

  <UL>
    <LI>A reference to the AxisEngine</LI>

    <LI>The request and response messages
    (<CODE>org.apache.axis.Message</CODE> objects available via
    getter and setter methods)</LI>

    <LI>Information about statefulness and service scope (whether
    the service is maintaining session information, etc.)</LI>

    <LI>The current status of processing (whether or not the
    "pivot" has been passed, which determines whether the request
    or response is the current message)</LI>

    <LI>Authentication information (username and password, which
    can be provided by a servlet container or other means)</LI>

    <LI>Properties galore. Almost anything you would want to know
    about the message can be retrieved via
    <CODE>MessageContext.getProperty()</CODE>. You only need to
    know the name of the property. This can be tricky, but it is
    usually a constant, like those defined in
    <CODE>org.apache.axis.transport.http.HTTPConstants</CODE>. So,
    for example, to retrieve the ServletContext for the Axis
    Servlet, you would want:
    <CODE>((HttpServlet)msgC.getProperty(HTTPConstants.MC_HTTP_SERVLET)).getServletContext();</CODE><BR>
    </LI>
  </UL>

  <P>From within your service, the current MessageContext object is
  always available via the static method
  <CODE>MessageContext.getCurrentContext()</CODE>. This allows you
  to do any needed customization of the request and response
  methods, even from within an RPC service that has no explicit
  reference to the MessageContext.</P>

  <H4>org.apache.axis.Message</H4>

  <P>An <CODE>org.apache.axis.Message</CODE> object is Axis's
  representation of a SOAP message. The request and response
  messages can be retrieved from the MessageContext as described
  above. A Message has:</P>

  <UL>
    <LI>MIME headers (if the message itself has MIME
    information)</LI>

    <LI>Attachments (if the message itself has attachments)</LI>

    <LI>A SOAPPart (and a convenience method for quick retrieval of
    the SOAPPart's SOAPEnvelope). The SOAPPart gives you access to
    the SOAP "guts" of the message (everything inside the
    &lt;soap:Envelope&gt; tags)</LI>
  </UL>

  <H4>org.apache.axis.SOAPEnvelope</H4>

  <P>As you can see, starting with the MessageContext lets you work
  your way down through the API, discovering all the information
  available to you about a single request/response exchange. A
  MessageContext has two Messages, which each have a SOAPPart that
  contains a SOAPEnvelope. The SOAPEnvelope, in turn, holds a full
  representation of the SOAP Envelope that is sent over the wire.
  From here you can get and set the contents of the SOAP Header and
  the SOAP Body. See the Javadocs for a full list of the properties
  available.</P>

  <H2><A name="tcpmon"></A>Appendix : Using the Axis TCP Monitor
  (tcpmon)</H2>

  <P>The included "tcpmon" utility can be found in the
  org.apache.axis.utils package. To run it from the command
  line:</P>
  <PRE>
% java org.apache.axis.utils.tcpmon [listenPort targetHost targetPort]
</PRE>

  <P>Without any of the optional arguments, you will get a gui
  which looks like this:</P>

  <CENTER>
    <P><IMG src="images/tcpmon1.jpg" height="599" width="599"></P>
  </CENTER>

  <P>To use the program, you should select a local port which
  tcpmon will monitor for incoming connections, a target host where
  it will forward such connections, and the port number on the
  target machine which should be "tunneled" to. Then click "add".
  You should then notice another tab appearing in the window for
  your new tunneled connection. Looking at that panel, you'll see
  something like this:</P>

  <CENTER>
    <P><IMG src="images/tcpmon2.jpg" height="600" width="599"></P>
  </CENTER>

  <P>Now each time a SOAP connection is made to the local port, you
  will see the request appear in the "Request" panel, and the
  response from the server in the "Response" panel. Tcpmon keeps a
  log of all request/response pairs, and allows you to view any
  particular pair by selecting an entry in the top panel. You may
  also remove selected entries, or all of them, or choose to save
  to a file for later viewing.</P>

  <P>The "resend" button will resend the request you are currently
  viewing, and record a new response. This is particularly handy in
  that you can edit the XML in the request window before resending
  - so you can use this as a great tool for testing the effects of
  different XML on SOAP servers. Note that you may need to change
  the content-length HTTP header value before resending an edited
  request.</P>

  <H2><A name="soapmon"></A>Appendix: Using the SOAP Monitor</H2>

  <P>Web service developers often have the need to see the SOAP
  messages being used to invoke web services along with the results
  of those messages. The goal of the SOAP Monitor utility is to
  provide a way for these developers to monitor the SOAP messages
  being used without requiring any special configuration or
  restarting of the server.</P>

  <P>In this utility, a handler has been written and added to the
  global handler chain. As SOAP requests and responses are
  received, the SOAP message information is forwarded to a SOAP
  monitor service where it can be displayed using a web browser
  interface.</P>

  <P>The SOAP message information is accessed with a web browser by
  going to http://localhost:&lt;port&gt;/axis/SOAPMonitor (where
  &lt;port&gt; is the port number where the application server is
  running).</P>

  <P>The SOAP message information is displayed through a web
  browser by using an applet that opens a socket connection to the
  SOAP monitor service. This applet requires a Java plug-in 1.3 or
  higher to be installed in your browser. If you do not have a
  correct plug-in, the browser should prompt you to install
  one.</P>

  <P>The port used by the SOAP monitor service to comminicate with
  applets is configurable. Edit the web.xml file for the Axis web
  application to change the port to be used. <B>Note: The SOAP
  Monitor is NOT enabled by default for security reasons.</B></P>

  <H2><A name="Glossary">Glossary</A></H2>

  <DL>
    <DT><I>Handler</I></DT>

    <DD>A reusable class which is responsible for processing a
    MessageContext in some custom way. The Axis engine invokes a
    series of Handlers whenever a request comes in from a client or
    a transport listener.</DD>

    <DT><I>SOAP</I></DT>

    <DD>The Simple Object Access Protocol (yes, despite the fact
    that it sometimes doesn't seem so simple, and doesn't have
    anything to do with objects... :)). You can read the SOAP 1.1
    specification at <A href=
    "http://www.w3.org/TR/SOAP">http://www.w3.org/TR/SOAP</A>. The
    W3C is currently in the midst of work on SOAP 1.2, under the
    auspices of the <A href="http://www.w3.org/2000/xp/Group/">XML
    Protocol Group</A>.</DD>

    <DT><I>Provider</I></DT>

    <DD>A provider is the "back-end" Handler which is responsible
    for actually performing the "meat" of the desired SOAP
    operation. Typically this means calling a method on some
    back-end service object. The two commonly used providers are
    RPCProvider and MsgProvider, both in the
    org.apache.axis.providers.java package.</DD>
  </DL>
</BODY>
</HTML>
