// Copyright 2003-2004 The Apache Software Foundation.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
 * This file was auto-generated by the Axis C++ Web Service Generator (WSDL2Ws)
 * This file contains Client Stub implementation for remote web service.
 */

#include "Calculator.hpp"

#include <axis/AxisWrapperAPI.hpp>

Calculator::Calculator(const char* pcEndpointUri, AXIS_PROTOCOL_TYPE eProtocol):Stub(pcEndpointUri, eProtocol)
{
}

Calculator::Calculator()
:Stub(" ", APTHTTP1_1)
{
	m_pCall->setEndpointURI("http://localhost/axis/Calculator");
}

Calculator::~Calculator()
{
}


/*Methods corresponding to the web service methods*/

/*
 * This method wrap the service methodadd
 */
xsd__int Calculator::add(xsd__int Value0, xsd__int Value1)
{
	xsd__int Ret = 0;
	const char* pcCmplxFaultName;
	pcCmplxFaultName = NULL;
	try
	{	if (AXIS_SUCCESS != m_pCall->initialize(CPP_DOC_PROVIDER)) return Ret;
		if (NULL==m_pCall->getTransportProperty("SOAPAction",false))
	{
		m_pCall->setTransportProperty(SOAPACTION_HEADER , "Calculator#add");
	}
	m_pCall->setSOAPVersion(SOAP_VER_1_1);
	m_pCall->setOperation("add", "http://localhost/axis/Calculator");
	includeSecure();
	applyUserPreferences();
	char cPrefixAndParamName0[17];
	sprintf( cPrefixAndParamName0, "%s:arg_0_0", m_pCall->getNamespacePrefix("http://localhost/axis/Calculator"));
	m_pCall->addParameter((void*)&Value0, cPrefixAndParamName0, XSD_INT);
	char cPrefixAndParamName1[17];
	sprintf( cPrefixAndParamName1, "%s:arg_1_0", m_pCall->getNamespacePrefix("http://localhost/axis/Calculator"));
	m_pCall->addParameter((void*)&Value1, cPrefixAndParamName1, XSD_INT);
	if (AXIS_SUCCESS == m_pCall->invoke())
	{
		if(AXIS_SUCCESS == m_pCall->checkMessage("addResponse", "http://localhost/axis/Calculator"))
		{
			xsd__int * pReturn = m_pCall->getElementAsInt("addReturn", 0);
			if(pReturn)
				Ret = *pReturn;
		}
	}
	m_pCall->unInitialize();
	return Ret;
	}
	catch(AxisException& e)
	{
		int iExceptionCode = e.getExceptionCode();

		if(AXISC_NODE_VALUE_MISMATCH_EXCEPTION != iExceptionCode)
		{
			m_pCall->unInitialize();
			throw;
		}

		ISoapFault* pSoapFault = (ISoapFault*)
			m_pCall->checkFault("Fault","http://localhost/axis/Calculator" );

		if(pSoapFault)
		{
				const char *detail = pSoapFault->getSimpleFaultDetail();
				bool deleteDetail=false;

				if (NULL==detail || 0==strlen(detail))
				{
					detail=m_pCall->getFaultAsXMLString();
					if (NULL==detail)
					{
						detail="";
					}
					else
					{
						deleteDetail=true;
					}
				}

				OtherFaultException ofe(pSoapFault->getFaultcode(),
					pSoapFault->getFaultstring(), pSoapFault->getFaultactor(),
					detail, iExceptionCode);

				if (deleteDetail && NULL!=detail)
				{
					delete [] const_cast<char*>(detail);
				}

				m_pCall->unInitialize();
				throw ofe;
		}
		else
		{
			m_pCall->unInitialize();
			throw;
		}
	}
}


/*
 * This method wrap the service methodsub
 */
xsd__int Calculator::sub(xsd__int Value0, xsd__int Value1)
{
	xsd__int Ret = 0;
	const char* pcCmplxFaultName;
	pcCmplxFaultName = NULL;
	try
	{	if (AXIS_SUCCESS != m_pCall->initialize(CPP_DOC_PROVIDER)) return Ret;
		if (NULL==m_pCall->getTransportProperty("SOAPAction",false))
	{
		m_pCall->setTransportProperty(SOAPACTION_HEADER , "Calculator#sub");
	}
	m_pCall->setSOAPVersion(SOAP_VER_1_1);
	m_pCall->setOperation("sub", "http://localhost/axis/Calculator");
	includeSecure();
	applyUserPreferences();
	char cPrefixAndParamName0[17];
	sprintf( cPrefixAndParamName0, "%s:arg_0_1", m_pCall->getNamespacePrefix("http://localhost/axis/Calculator"));
	m_pCall->addParameter((void*)&Value0, cPrefixAndParamName0, XSD_INT);
	char cPrefixAndParamName1[17];
	sprintf( cPrefixAndParamName1, "%s:arg_1_1", m_pCall->getNamespacePrefix("http://localhost/axis/Calculator"));
	m_pCall->addParameter((void*)&Value1, cPrefixAndParamName1, XSD_INT);
	if (AXIS_SUCCESS == m_pCall->invoke())
	{
		if(AXIS_SUCCESS == m_pCall->checkMessage("subResponse", "http://localhost/axis/Calculator"))
		{
			xsd__int * pReturn = m_pCall->getElementAsInt("subReturn", 0);
			if(pReturn)
				Ret = *pReturn;
		}
	}
	m_pCall->unInitialize();
	return Ret;
	}
	catch(AxisException& e)
	{
		int iExceptionCode = e.getExceptionCode();

		if(AXISC_NODE_VALUE_MISMATCH_EXCEPTION != iExceptionCode)
		{
			m_pCall->unInitialize();
			throw;
		}

		ISoapFault* pSoapFault = (ISoapFault*)
			m_pCall->checkFault("Fault","http://localhost/axis/Calculator" );

		if(pSoapFault)
		{
				const char *detail = pSoapFault->getSimpleFaultDetail();
				bool deleteDetail=false;

				if (NULL==detail || 0==strlen(detail))
				{
					detail=m_pCall->getFaultAsXMLString();
					if (NULL==detail)
					{
						detail="";
					}
					else
					{
						deleteDetail=true;
					}
				}

				OtherFaultException ofe(pSoapFault->getFaultcode(),
					pSoapFault->getFaultstring(), pSoapFault->getFaultactor(),
					detail, iExceptionCode);

				if (deleteDetail && NULL!=detail)
				{
					delete [] const_cast<char*>(detail);
				}

				m_pCall->unInitialize();
				throw ofe;
		}
		else
		{
			m_pCall->unInitialize();
			throw;
		}
	}
}


/*
 * This method wrap the service methodmul
 */
xsd__int Calculator::mul(xsd__int Value0, xsd__int Value1)
{
	xsd__int Ret = 0;
	const char* pcCmplxFaultName;
	pcCmplxFaultName = NULL;
	try
	{	if (AXIS_SUCCESS != m_pCall->initialize(CPP_DOC_PROVIDER)) return Ret;
		if (NULL==m_pCall->getTransportProperty("SOAPAction",false))
	{
		m_pCall->setTransportProperty(SOAPACTION_HEADER , "Calculator#mul");
	}
	m_pCall->setSOAPVersion(SOAP_VER_1_1);
	m_pCall->setOperation("mul", "http://localhost/axis/Calculator");
	includeSecure();
	applyUserPreferences();
	char cPrefixAndParamName0[17];
	sprintf( cPrefixAndParamName0, "%s:arg_0_2", m_pCall->getNamespacePrefix("http://localhost/axis/Calculator"));
	m_pCall->addParameter((void*)&Value0, cPrefixAndParamName0, XSD_INT);
	char cPrefixAndParamName1[17];
	sprintf( cPrefixAndParamName1, "%s:arg_1_2", m_pCall->getNamespacePrefix("http://localhost/axis/Calculator"));
	m_pCall->addParameter((void*)&Value1, cPrefixAndParamName1, XSD_INT);
	if (AXIS_SUCCESS == m_pCall->invoke())
	{
		if(AXIS_SUCCESS == m_pCall->checkMessage("mulResponse", "http://localhost/axis/Calculator"))
		{
			xsd__int * pReturn = m_pCall->getElementAsInt("mulReturn", 0);
			if(pReturn)
				Ret = *pReturn;
		}
	}
	m_pCall->unInitialize();
	return Ret;
	}
	catch(AxisException& e)
	{
		int iExceptionCode = e.getExceptionCode();

		if(AXISC_NODE_VALUE_MISMATCH_EXCEPTION != iExceptionCode)
		{
			m_pCall->unInitialize();
			throw;
		}

		ISoapFault* pSoapFault = (ISoapFault*)
			m_pCall->checkFault("Fault","http://localhost/axis/Calculator" );

		if(pSoapFault)
		{
				const char *detail = pSoapFault->getSimpleFaultDetail();
				bool deleteDetail=false;

				if (NULL==detail || 0==strlen(detail))
				{
					detail=m_pCall->getFaultAsXMLString();
					if (NULL==detail)
					{
						detail="";
					}
					else
					{
						deleteDetail=true;
					}
				}

				OtherFaultException ofe(pSoapFault->getFaultcode(),
					pSoapFault->getFaultstring(), pSoapFault->getFaultactor(),
					detail, iExceptionCode);

				if (deleteDetail && NULL!=detail)
				{
					delete [] const_cast<char*>(detail);
				}

				m_pCall->unInitialize();
				throw ofe;
		}
		else
		{
			m_pCall->unInitialize();
			throw;
		}
	}
}


/*
 * This method wrap the service methoddiv
 */
xsd__int Calculator::div(xsd__int Value0, xsd__int Value1)
{
	xsd__int Ret = 0;
	const char* pcCmplxFaultName;
	pcCmplxFaultName = NULL;
	try
	{	if (AXIS_SUCCESS != m_pCall->initialize(CPP_DOC_PROVIDER)) return Ret;
		if (NULL==m_pCall->getTransportProperty("SOAPAction",false))
	{
		m_pCall->setTransportProperty(SOAPACTION_HEADER , "Calculator#div");
	}
	m_pCall->setSOAPVersion(SOAP_VER_1_1);
	m_pCall->setOperation("div", "http://localhost/axis/Calculator");
	includeSecure();
	applyUserPreferences();
	char cPrefixAndParamName0[17];
	sprintf( cPrefixAndParamName0, "%s:arg_0_3", m_pCall->getNamespacePrefix("http://localhost/axis/Calculator"));
	m_pCall->addParameter((void*)&Value0, cPrefixAndParamName0, XSD_INT);
	char cPrefixAndParamName1[17];
	sprintf( cPrefixAndParamName1, "%s:arg_1_3", m_pCall->getNamespacePrefix("http://localhost/axis/Calculator"));
	m_pCall->addParameter((void*)&Value1, cPrefixAndParamName1, XSD_INT);
	if (AXIS_SUCCESS == m_pCall->invoke())
	{
		if(AXIS_SUCCESS == m_pCall->checkMessage("divResponse", "http://localhost/axis/Calculator"))
		{
			xsd__int * pReturn = m_pCall->getElementAsInt("divReturn", 0);
			if(pReturn)
				Ret = *pReturn;
		}
	}
	m_pCall->unInitialize();
	return Ret;
	}
	catch(AxisException& e)
	{
		int iExceptionCode = e.getExceptionCode();

		if(AXISC_NODE_VALUE_MISMATCH_EXCEPTION != iExceptionCode)
		{
			m_pCall->unInitialize();
			throw;
		}

		ISoapFault* pSoapFault = (ISoapFault*)
			m_pCall->checkFault("Fault","http://localhost/axis/Calculator" );

		if(pSoapFault)
		{
				const char *detail = pSoapFault->getSimpleFaultDetail();
				bool deleteDetail=false;

				if (NULL==detail || 0==strlen(detail))
				{
					detail=m_pCall->getFaultAsXMLString();
					if (NULL==detail)
					{
						detail="";
					}
					else
					{
						deleteDetail=true;
					}
				}

				OtherFaultException ofe(pSoapFault->getFaultcode(),
					pSoapFault->getFaultstring(), pSoapFault->getFaultactor(),
					detail, iExceptionCode);

				if (deleteDetail && NULL!=detail)
				{
					delete [] const_cast<char*>(detail);
				}

				m_pCall->unInitialize();
				throw ofe;
		}
		else
		{
			m_pCall->unInitialize();
			throw;
		}
	}
}

/*Methods for supporting SecureChannel*/

void Calculator::SetSecure( char * pszArguments, ...)
{
	int		iArgIndex = 0;
	va_list	args;
	char *	pszArg = NULL;
	
	va_start( args, pszArguments);
	
	if( (pszArg = pszArguments) != NULL)
	{
		do
		{
			if( pszArg == (char *) 1)
			{
				sArguments[iArgIndex] = "true";
			}
			else
			{
				sArguments[iArgIndex] = pszArg;
			}

		iArgIndex++;
		} while( (pszArg = va_arg( args, char *)) != NULL && iArgIndex < 8);

		if( iArgIndex == 6)
		{
			sArguments[iArgIndex] = "false";
		}
	}

	va_end( args);
}

void Calculator::includeSecure()
{
	m_pCall->setTransportProperty( SECURE_PROPERTIES, (const char *) &sArguments);
}
