/*
 *   Copyright 2003-2004 The Apache Software Foundation.
 // (c) Copyright IBM Corp. 2004, 2005 All Rights Reserved
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

/**
 * @author Susantha Kumara(susantha@opensource.lk, skumara@virtusa.com)
 * @author Samisa Abeysinghe (sabeysinghe@virtusa.com)
 */

package org.apache.axis.wsdl.wsdl2ws.cpp;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import javax.xml.namespace.QName;

import org.apache.axis.wsdl.wsdl2ws.CUtils;
import org.apache.axis.wsdl.wsdl2ws.WSDL2Ws;
import org.apache.axis.wsdl.wsdl2ws.WrapperFault;
import org.apache.axis.wsdl.wsdl2ws.WrapperUtils;
import org.apache.axis.wsdl.wsdl2ws.info.FaultInfo;
import org.apache.axis.wsdl.wsdl2ws.info.MethodInfo;
import org.apache.axis.wsdl.wsdl2ws.info.ParameterInfo;
import org.apache.axis.wsdl.wsdl2ws.info.Type;
import org.apache.axis.wsdl.wsdl2ws.info.WebServiceContext;

public class ClientStubWriter extends CPPClassWriter
{
    protected ArrayList methods;

    public ClientStubWriter(WebServiceContext wscontext) throws WrapperFault
    {
        super(WrapperUtils.getClassNameFromFullyQualifiedName(wscontext
                .getSerInfo().getQualifiedServiceName()));
        this.wscontext = wscontext;
        this.methods = wscontext.getSerInfo().getMethods();
    }

    protected String getServiceName() throws WrapperFault
    {
        return wscontext.getSerInfo().getServicename();
    }

    protected void writeClassComment() throws WrapperFault
    {
        try
        {
            writer.write("/*\n");
            writer.write(" * This file was auto-generated by the Axis C++ Web Service "
                            + "Generator (WSDL2Ws)\n");
            writer.write(" * This file contains Client Stub implementation for remote web service.\n");
            writer.write(" */\n\n");
        } 
        catch (IOException e)
        {
            throw new WrapperFault(e);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.axis.wsdl.wsdl2ws.cpp.HeaderFileWriter#writeConstructors()
     */
    protected void writeConstructors() throws WrapperFault
    {
        try
        {
            writer.write(classname + "::" + classname
                    + "(const char* pchEndpointUri, AXIS_PROTOCOL_TYPE eProtocol)\n:Stub(pchEndpointUri, eProtocol)\n{\n");
            writer.write("}\n\n");
            writer.write(classname + "::" + classname
                    + "()\n:Stub(\" \", APTHTTP1_1)\n{\n");
            //TODO get TransportURI from WrapInfo and check what the transport
            // is and do the following line accordingly
            writer.write("\tm_pCall->setEndpointURI(\""
                            + wscontext.getWrapInfo().getTargetEndpointURI()
                            + "\");\n");
            writer.write("}\n\n");
        } 
        catch (IOException e)
        {
            throw new WrapperFault(e);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.axis.wsdl.wsdl2ws.cpp.HeaderFileWriter#writeDistructors()
     */
    protected void writeDestructors() throws WrapperFault
    {
        try
        {
            writer.write(classname + "::~" + classname + "()\n{\n}\n\n");
        } 
        catch (IOException e)
        {
            throw new WrapperFault(e);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.axis.wsdl.wsdl2ws.cpp.HeaderFileWriter#writeMethods()
     */
    protected void writeMethods() throws WrapperFault
    {
        try
        {
            writer.write("\n/*Methods corresponding to the web service methods*/\n");
            MethodInfo minfo;
            for (int i = 0; i < methods.size(); i++)
            {
                minfo = (MethodInfo) methods.get(i);
                this.writeMethodInWrapper(minfo);
                writer.write("\n");
            }
            //damitha
        } 
        catch (IOException e)
        {
            throw new WrapperFault(e);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.axis.wsdl.wsdl2ws.cpp.HeaderFileWriter#writePreprocssorStatements()
     */
    protected void writePreprocessorStatements() throws WrapperFault
    {
        try
        {
            if ("AxisClientException".equals(classname))
            {
                writer.write("#include \"" + getServiceName() + "_" + classname
                        + CUtils.CPP_HEADER_SUFFIX + "\"\n\n");
            }
            else
                writer.write("#include \"" + classname + CUtils.CPP_HEADER_SUFFIX + "\"\n\n");

            writer.write("#include <axis/AxisWrapperAPI.hpp>\n");
            writer.write ("#include <axis/Axis.hpp>\n\n");
        } 
        catch (IOException e)
        {
            throw new WrapperFault(e);
        }
    }

    /**
     * This method genarate methods that wraps the each method of the service
     * 
     * @param methodName
     * @param params
     * @param outparam
     * @throws IOException
     */

    public void writeMethodInWrapper(MethodInfo minfo) throws WrapperFault,
            IOException
    {
        boolean isAllTreatedAsOutParams = false;
        ParameterInfo returntype = null;
        int noOfOutParams = minfo.getOutputParameterTypes().size();
        if (0 == noOfOutParams)
            returntype = null;
        else if (1 == noOfOutParams)
            returntype = (ParameterInfo) minfo.getOutputParameterTypes().iterator().next();
        else
            isAllTreatedAsOutParams = true;
        
        Collection params = minfo.getInputParameterTypes();

        String methodName = minfo.getMethodname();
        Type retType = null;
        boolean returntypeissimple = false;
        boolean returntypeisarray = false;
        String outparamTypeName = null;
        if (returntype != null)
        {
            outparamTypeName = 
                WrapperUtils.getClassNameFromParamInfoConsideringArrays(returntype, wscontext);
            retType = wscontext.getTypemap().getType(returntype.getSchemaName());
            if (retType != null)
            {
                returntypeisarray = retType.isArray();
                if (WSDL2Ws.verbose)
                {
                    System.out.println(retType.getLanguageSpecificName()
                            + "LanguageName  .................... ");
                }
                if (CUtils.isSimpleType(retType.getLanguageSpecificName()))
                    returntypeissimple = true;
            }
        }
        writer.write("\n/*\n");
        writer.write(" * This method wrap the service method " + methodName + "\n");
        writer.write(" */\n");
        //method signature
        String paramTypeName;
        boolean typeisarray = false;
        boolean typeissimple = false;
        Type type;
        if (returntype == null)
            writer.write("void");
        else
        {
            if (returntypeissimple
                    && (!(returntype.isNillable() || returntype.isOptional()) 
                            || CUtils.isPointerType(outparamTypeName)))
                writer.write (outparamTypeName);
            else if (outparamTypeName.lastIndexOf ("*") > 0)
                writer.write (outparamTypeName);
            else
                writer.write (outparamTypeName + "*");

            if (WSDL2Ws.verbose)
                System.out.println("Output Parameter type Name :" + outparamTypeName);
        }
        
        writer.write(" " + classname + "::" + methodName + "(");
        ArrayList paramsB = (ArrayList) params;
        for (int i = 0; i < paramsB.size(); i++)
        {
            paramTypeName = 
                WrapperUtils.getClassNameFromParamInfoConsideringArrays((ParameterInfo) paramsB.get(i), wscontext);
            
            if (i > 0)
                writer.write(", ");
            
            typeissimple = CUtils.isSimpleType(paramTypeName);
            if (typeissimple
                    && (!(((ParameterInfo) paramsB.get (0)).isNillable () 
                            || ((ParameterInfo) paramsB.get (0)).isOptional())
                    || CUtils.isPointerType(paramTypeName)))
                writer.write (paramTypeName + " Value" + i);
            else if (paramTypeName.lastIndexOf ("*") > 0)
                writer.write (paramTypeName + " Value" + i);
            else
                writer.write (paramTypeName + "* Value" + i);
        }
        
        // Multiples parameters so fill the methods prototype
        ArrayList paramsC = (ArrayList) minfo.getOutputParameterTypes();
        if (isAllTreatedAsOutParams)
        {
            String currentParaTypeName;
            for (int i = 0; i < paramsC.size(); i++)
            {
                type = wscontext.getTypemap().getType(
                        ((ParameterInfo) paramsC.get(i)).getSchemaName());
                writer.write(", AXIS_OUT_PARAM  "
                    + WrapperUtils.getClassNameFromParamInfoConsideringArrays(
                                (ParameterInfo) paramsC.get(i),wscontext) + " *OutValue" + i);
            }
        }
        
        writer.write(")\n{\n");
        
        if (returntype != null)
        {
            writer.write("\t");
            if (returntypeisarray)
                writer.write(outparamTypeName + " *\tRetArray = new " + outparamTypeName + "();\n");
            else if (!returntypeissimple)
                writer.write(outparamTypeName + "\tpReturn = NULL;\n");
            else if (returntype.isNillable() || returntype.isOptional()
                        || CUtils.isPointerType(outparamTypeName))
            {
                writer.write(outparamTypeName);
                if (!CUtils.isPointerType(outparamTypeName))
                    writer.write(" *");

                writer.write("\tRet = NULL;\n");
            }
            else if ("xsd__base64Binary".equals(outparamTypeName) 
                        || "xsd__hexBinary".equals(outparamTypeName))
                writer.write(outparamTypeName + "\tRet;\n");
            else
                writer.write(outparamTypeName + "\tRet = " + CUtils.getInitValue(outparamTypeName) + ";\n");
        }

        //writer.write("\tchar* cFaultcode;\n");
        //writer.write("\tchar* cFaultstring;\n");
        //writer.write("\tchar* cFaultactor;\n");
        writer.write("\tconst char *\tpcCmplxFaultName = NULL;\n\n");
        writer.write("\ttry\n\t{");
        writer.write("\n\t\tif( AXIS_SUCCESS != m_pCall->initialize( CPP_RPC_PROVIDER"
                        + "))\n\t\t{\n\t\t\treturn ");
        //damitha

        if (returntype != null)
        {
            if (returntypeisarray)
                writer.write("RetArray;\n");
            else if (CUtils.isPointerType(outparamTypeName) || 
                       (returntypeissimple && !(returntype.isNillable() || returntype.isOptional())))
                writer.write("Ret;\n");
            else if (returntypeissimple)
                writer.write("*Ret;\n");
            else
                writer.write("pReturn;\n");
        }
        else
            writer.write(";\n");

        writer.write("\t\t}\n\n");

        writer.write("\t\tif( NULL == m_pCall->getTransportProperty( \"SOAPAction\", false))\n");
        writer.write("\t\t{\n");
        writer.write("\t\t\tm_pCall->setTransportProperty( SOAPACTION_HEADER,\n\t\t\t\t\t\t\t\t\t\t\t\""
                + minfo.getSoapAction() + "\");\n");
        writer.write("\t\t}\n\n");
        writer.write("\t\tm_pCall->setSOAPVersion( SOAP_VER_1_1);\n");
        //TODO check which version is it really.
        writer.write("\t\tm_pCall->setOperation( \"" + minfo.getMethodname()
                + "\", \"" + wscontext.getWrapInfo().getTargetNameSpaceOfWSDL()
                + "\");\n");
        writer.write("\t\tapplyUserPreferences();\n");
        
        for (int i = 0; i < paramsB.size(); i++)
        {
            type = wscontext.getTypemap().getType( ((ParameterInfo) paramsB.get(i)).getSchemaName());
            
            if (type != null)
            {
                paramTypeName = type.getLanguageSpecificName();
                typeisarray = type.isArray();
            }
            else
            {
                paramTypeName = ((ParameterInfo) paramsB.get(i)).getLangName();
                typeisarray = false;
            }
            
            typeissimple = CUtils.isSimpleType(paramTypeName);
            
            if (typeisarray)
            {
                //arrays
                QName qname = WrapperUtils.getArrayType(type).getName();
                String containedType = null;
                if (CUtils.isSimpleType(qname))
                {
                    containedType = CUtils.getclass4qname(qname);
                    writer.write("\t\tm_pCall->addBasicArrayParameter( ");
                    writer.write("Value" + i + ", "
                            + CUtils.getXSDTypeForBasicType(containedType)
                            + ", \""
                            + ((ParameterInfo) paramsB.get(i)).getParamName()
                            + "\"");
                }
                else
                {
                    containedType = qname.getLocalPart();
                    writer.write("\t\tm_pCall->addCmplxArrayParameter( ");
                    writer.write("Value" + i
                            + ",\n\t\t\t\t\t\t\t\t\t\t(void *) Axis_Serialize_" + containedType
                            + ",\n\t\t\t\t\t\t\t\t\t\t(void *) Axis_Delete_" + containedType
                            + ",\n\t\t\t\t\t\t\t\t\t\t\"" + ((ParameterInfo) paramsB.get(i)).getParamName() + "\""
                            + ",\n\t\t\t\t\t\t\t\t\t\tAxis_URI_" + containedType);
                }
            }
            else
            {
                if (typeissimple)
                {

                    //for simple types
                    if (((ParameterInfo) paramsB.get(i)).isNillable()
                            || CUtils.isPointerType(paramTypeName))
                    {
                        writer.write("\t\tm_pCall->addParameter( ");
                        writer.write("(void *) Value"
                                + i
                                + ", \""
                                + ((ParameterInfo) paramsB.get(i))
                                        .getParamName() + "\", "
                                + CUtils.getXSDTypeForBasicType(paramTypeName));
                    }
                    else
                    {
                        writer.write("\t\tm_pCall->addParameter( ");
                        writer.write("(void *) &Value"
                                + i
                                + ", \""
                                + ((ParameterInfo) paramsB.get(i))
                                        .getParamName() + "\", "
                                + CUtils.getXSDTypeForBasicType(paramTypeName));
                    }
                }
                else
                {
                    //for complex types
                    writer.write("\t\tm_pCall->addCmplxParameter( ");
                    writer.write("Value" + i + ",\n\t\t\t\t\t\t\t\t\t(void *) Axis_Serialize_"
                            + paramTypeName + ",\n\t\t\t\t\t\t\t\t\t(void *) Axis_Delete_"
                            + paramTypeName + ",\n\t\t\t\t\t\t\t\t\t\""
                            + ((ParameterInfo) paramsB.get(i)).getParamName()
                            + "\",\n\t\t\t\t\t\t\t\t\tAxis_URI_" + paramTypeName);
                }
            }
            writer.write(");\n");
        }
        writer.write("\n\t\tif( AXIS_SUCCESS == m_pCall->invoke())\n\t\t{\n");
        writer.write("\t\t\tif( AXIS_SUCCESS == m_pCall->checkMessage( \""
                + minfo.getOutputMessage().getLocalPart() + "\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\""
                + wscontext.getWrapInfo().getTargetNameSpaceOfWSDL()
                + "\"))\n\t\t\t{\n");

        // Because getParamName will prefix any c++ reserved word with an
        // underscore (i.e 'return' becomes '_return'), this unnecessary
        // modification needs to be removed before using the name as a soap
        // tag identifier.
        
        String paramTagName = "";
        
        if( returntype != null)
        {
            paramTagName = returntype.getParamName();

            if( paramTagName.charAt(0) == '_')
                paramTagName = paramTagName.substring( 1);
        }
        
        if (isAllTreatedAsOutParams)
        {
            String currentParamName;
            String currentParaType;
            for (int i = 0; i < paramsC.size(); i++)
            {
                ParameterInfo currentType = (ParameterInfo) paramsC.get(i);
                type = wscontext.getTypemap().getType(
                        currentType.getSchemaName());
                if (type != null)
                {
                    currentParaType = type.getLanguageSpecificName();
                    typeisarray = type.isArray();
                }
                else
                {
                    currentParaType = ((ParameterInfo) paramsC.get(i))
                            .getLangName();
                    typeisarray = false;
                }
                typeissimple = CUtils.isSimpleType(currentParaType);

                currentParamName = "*OutValue" + i;
                    
                // Some code need to be merged as we have some duplicated in
                // coding here.
                if (typeisarray)
                {
                    QName qname = WrapperUtils.getArrayType(type).getName();
                    String containedType = null;
                    if (CUtils.isSimpleType(qname))
                    {
                        containedType = CUtils.getclass4qname(qname);
                        writer.write("\n\t\t\tAxis_Array * pReturn" + i + " = m_pCall->getBasicArray( " + CUtils.getXSDTypeForBasicType (containedType) 
                                + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"" + currentType.getParamName()
                                + "\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0);\n\n");
                        writer.write("\t\t\tif( pReturn" + i + " != NULL && OutValue" + i + " != NULL)\n");
                        writer.write("\t\t\t{\n");
                        writer.write("\t\t\t\tif( *OutValue" + i + " == NULL)\n");
                        writer.write("\t\t\t\t{\n");
                        writer.write("\t\t\t\t\t*OutValue" + i + " = new " + currentParaType 
                                + "();\n");
                        writer.write("\t\t\t\t}\n");
                        writer.write("\t\t\t\telse\n");
                        writer.write("\t\t\t\t{\n");
                        writer.write("\t\t\t\t\t(*OutValue" + i + ")->clear();\n");
                        writer.write("\t\t\t\t}\n\n");
                        writer.write("\t\t\t\t(*OutValue" + i + ")->clone( *pReturn" + i + ");\n");
                        writer.write("\t\t\t}\n\n");
                        writer.write("\t\t\tAxis::AxisDelete( (void *) pReturn" + i + ", XSD_ARRAY);\n");
                    }
                    else
                    {
                        containedType = qname.getLocalPart();
                        writer.write("\n\t\t\tif( OutValue" + i + " != NULL)\n" );
                        writer.write("\t\t\t{\n");
                        writer.write("\t\t\t\tif( " + currentParamName + " == NULL)\n");
                        writer.write("\t\t\t\t{\n");
                        writer.write("\t\t\t\t\t" + currentParamName + " = new " + containedType + "_Array();\n");
                        writer.write("\t\t\t\t}\n");
                        writer.write("\t\t\t\telse\n");
                        writer.write("\t\t\t\t{\n");
                        writer.write("\t\t\t\t\t(" + currentParamName + ")->clear();\n");
                        writer.write("\t\t\t\t}\n");
                        writer.write("\t\t\t\tm_pCall->getCmplxArray( " + currentParamName + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *) Axis_DeSerialize_"
                         + containedType);

                        writer.write (",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *) Axis_Create_" + containedType
                              + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *) Axis_Delete_" + containedType
                              + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"" +currentType.getElementNameAsString() +
                              "\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tAxis_URI_" + containedType +
                              ");\n");
                        writer.write("\t\t\t}\n");
                        writer.write("\t\t\telse\n");
                        writer.write("\t\t\t{\n");
                        writer.write("\t\t\t\t// Unable to return value, but will deserialize to ensure subsequent elements can be correctly processed.\n");
                        writer.write("\t\t\t\t" + containedType + "_Array * pTemp" + i + " = new " + containedType + "_Array();\n");
                        writer.write("\t\t\t\tm_pCall->getCmplxArray( pTemp" + i + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *) Axis_DeSerialize_"
                                 + containedType);
                        writer.write (",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *) Axis_Create_" + containedType
                              + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *) Axis_Delete_" + containedType
                              + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"" + currentType.getElementNameAsString() +
                              "\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tAxis_URI_" + containedType +
                              ");\n");
                        writer.write("\t\t\t\tdelete pTemp" + i + ";\n");
                        writer.write("\t\t\t}\n");
                    }
                }
                else
                {
                    if (typeissimple)
                    {
                        if( i > 0)
                            writer.write( "\n");
                        
                        if (CUtils.isPointerType(currentParaType))
                        {
                            String xsdType =  WrapperUtils.getClassNameFromParamInfoConsideringArrays ((ParameterInfo) paramsC.get (i), wscontext);
                            
                            if( !CUtils.isPointerType(xsdType))
                                xsdType += " *";
                            
                            writer.write( "\t\t\t" + currentParaType + " pReturn" + i + " = m_pCall->" + CUtils.getParameterGetValueMethodName( currentParaType, false) + "( \"" + currentType.getParamName() + "\", 0);\n");
                            writer.write( "\n");
                            writer.write( "\t\t\tif( pReturn" + i + " != NULL && OutValue" + i + " != NULL)\n");
                            writer.write( "\t\t\t\t{\n");
                            writer.write( "\t\t\t\tif( *OutValue" + i + " != NULL)\n");
                            writer.write( "\t\t\t\t{\n");
                            writer.write( "\t\t\t\t\tint\tiStringSize" + i + " = strlen( (char *) *OutValue" + i + ");\n");
                            writer.write( "\t\t\t\t\tint\tiStrLenValue" + i + " = strlen( pReturn" + i + ");\n");
                            writer.write( "\n");
                            writer.write( "\t\t\t\t\tif( iStrLenValue" + i + " > iStringSize" + i + ")\n");
                            writer.write( "\t\t\t\t\t{\n");
                            writer.write( "\t\t\t\t\t\t*OutValue" + i + " =(" + xsdType + ") new char[iStrLenValue" + i + " + 1];\n");
                            writer.write( "\t\t\t\t\t\tstrcpy( (char *) *OutValue" + i + ", pReturn" + i + ");\n");
                            writer.write( "\t\t\t\t\t}\n");
                            writer.write( "\t\t\t\t\telse\n");
                            writer.write( "\t\t\t\t\t{\n");
                            writer.write( "\t\t\t\t\t\tstrcpy( (char *) *OutValue" + i + ", pReturn" + i + ");\n");
                            writer.write( "\t\t\t\t\t}\n");
                            writer.write( "\t\t\t\t}\n");
                            writer.write( "\t\t\t\telse\n");
                            writer.write( "\t\t\t\t{\n");
                            writer.write( "\t\t\t\t\t*OutValue" + i + " = (" + xsdType + ") new char[strlen( pReturn" + i + ") + 1];\n");
                            writer.write( "\t\t\t\t\tstrcpy( (char *) *OutValue" + i + ", pReturn" + i + ");\n");
                            writer.write( "\t\t\t\t}\n");
                            writer.write( "\t\t\t}\n");
                            writer.write( "\n");
                            writer.write( "\t\t\tAxis::AxisDelete( (void *) pReturn" + i + ", " + CUtils.getXSDTypeForBasicType( currentParaType) + ");\n");
                        }
                        else 
                        {
                            writer.write( "\t\t\t" + currentParaType + " * pReturn" + i + " = m_pCall->" + CUtils.getParameterGetValueMethodName( currentParaType, false) + "( \"" + currentType.getParamName() + "\", 0);\n");
                            writer.write( "\n");
                            writer.write( "\t\t\tif( pReturn" + i + " != NULL && OutValue" + i + " != NULL)\n");
                            writer.write( "\t\t\t{\n");
                            writer.write( "// OutValue" + i + " is not nillable.\n");
//                            writer.write( "\t\t\t\tif( *OutValue" + i + " == NULL)\n");
//                            writer.write( "\t\t\t\t{\n");
//                            writer.write( "\t\t\t\t\t*OutValue" + i + " = new " + currentParaType + "();\n");
//                            writer.write( "\t\t\t\t}\n");
                            writer.write( "\t\t\t\tOutValue" + i + " = new " + currentParaType + "();\n");
                            writer.write( "\n");
                            writer.write( "\t\t\t\t*OutValue" + i + " = *pReturn" + i + ";\n");
                            writer.write( "\t\t\t}\n");
                            writer.write( "\n");
                            writer.write( "\t\t\tAxis::AxisDelete( (void *) pReturn" + i + ", " + CUtils.getXSDTypeForBasicType( currentParaType) + ");\n");
                        }
                    }
                    else
                    {
                        writer.write("\t\t\t\t"
                                        + currentParamName
                                        + " = ("
                                        + currentParaType
                                        + " *) m_pCall->getCmplxObject( (void *) Axis_DeSerialize_" + currentParaType
                                        + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *) Axis_Create_" + currentParaType
                                        + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *) Axis_Delete_" + currentParaType
                                        + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"" + currentType.getParamName()
                                        + "\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0);\n");
                    }
                }
            }
            writer.write("\t\t\t}\n");
            writer.write("\t\t}\n\n");
            writer.write("\t\tm_pCall->unInitialize();\n");
        }
        else if (returntype == null)
        {
            writer.write("\t\t\t\t/*not successful*/\n\t\t\t}\n");
            writer.write("\t\t}\n\n");
            writer.write("\t\tm_pCall->unInitialize();\n");
        }
        else if (returntypeisarray)
        {
            QName qname = WrapperUtils.getArrayType(retType).getName();
            String containedType = null;
            if (CUtils.isSimpleType(qname))
            {
                containedType = CUtils.getclass4qname(qname);
                writer.write("\t\t\t\tAxis_Array * RetAxisArray = m_pCall->getBasicArray( "
                        + CUtils.getXSDTypeForBasicType(containedType) + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\""
                        + paramTagName + "\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0);\n");
                writer.write ("\t\t\t\tRetArray->clone( *RetAxisArray);\n");
                writer.write ("\t\t\t\tAxis::AxisDelete( (void *) RetAxisArray, XSD_ARRAY);\n");
            }
            else
            {
                containedType = qname.getLocalPart();
                writer.write("\t\t\t\tRetArray = (" + containedType 
                        + "_Array *) m_pCall->getCmplxArray( RetArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *) Axis_DeSerialize_"
                        + containedType);
                //damitha
                writer.write(",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *) Axis_Create_" + containedType
                        + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *) Axis_Delete_" + containedType
                        + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"" + paramTagName
                        + "\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tAxis_URI_" + containedType + ");\n");            
            }
            writer.write("\t\t\t}\n\t\t}\n\n");
            writer.write("\t\tm_pCall->unInitialize();\n\n");
            //        writer.write("\t\t}\n\t\tm_pCall->unInitialize();\n");
            writer.write("\t\treturn RetArray;\n");
        }
        else if (returntypeissimple)
        {
            writer.write("\t\t\t\t" + outparamTypeName);
            if (!CUtils.isPointerType(outparamTypeName))
                writer.write(" *");
            
            writer.write(" pReturn = m_pCall->"
                    + CUtils.getParameterGetValueMethodName(outparamTypeName,
                            false) + "( \"" + paramTagName + "\", 0);\n\n");
            writer.write("\t\t\t\tif( pReturn)\n");
            writer.write("\t\t\t\t{\n");
            if (CUtils.isPointerType(outparamTypeName))
            {
                writer.write("\t\t\t\t\tRet = new char[strlen( pReturn) + 1];\n");
                writer.write("\t\t\t\t\tstrcpy( Ret, pReturn);\n");
            }
            else if (returntype.isOptional() || returntype.isNillable())
                writer.write("\t\t\t\t\tRet = new " + outparamTypeName + "( *pReturn);\n");
            else
                writer.write("\t\t\t\t\tRet = *pReturn;\n");

            writer.write("\t\t\t\t\tAxis::AxisDelete( (void *) pReturn, " + CUtils.getXSDTypeForBasicType(outparamTypeName) + ");\n");
            writer.write("\t\t\t\t}\n");
            writer.write("\t\t\t}\n");
            writer.write("\t\t}\n\n");
            writer.write("\t\tm_pCall->unInitialize();\n");
            writer.write("\t\treturn Ret;\n");
        }
        else
        {
            outparamTypeName = returntype.getLangName();
            //need to have complex type name without *
            writer.write("\t\t\t\tpReturn = (" + outparamTypeName
                    + " *) m_pCall->getCmplxObject( (void *) Axis_DeSerialize_"
                    + outparamTypeName + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *) Axis_Create_"
                    + outparamTypeName + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *) Axis_Delete_"
                    + outparamTypeName + ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"" + paramTagName
                    + "\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0);\n\t\t\t}\n");
            writer.write("\t\t}\n\n");
            writer.write("\t\tm_pCall->unInitialize();\n\n");
            //            writer.write("\t\t}\n\t\tm_pCall->unInitialize();\n");
            writer.write("\t\treturn pReturn;\n");

        }
        //added by nithya
        writer.write("\t}\n");
        writer.write("\tcatch( AxisException& e)\n\t{\n");
        writer.write("\t\tint iExceptionCode = e.getExceptionCode();\n\n");
        writer.write("\t\tif( AXISC_NODE_VALUE_MISMATCH_EXCEPTION != iExceptionCode)\n");
        writer.write("\t\t{\n");
        writer.write("\t\t\tm_pCall->unInitialize();\n");
        writer.write("\t\t\tthrow;\n");
        writer.write("\t\t}\n\n");
        //ISoapFault* pSoapFault = (ISoapFault*) m_pCall->checkFault("Fault",
        // "http://localhost/axis/MathOps");

        writer.write("\t\tISoapFault * pSoapFault = (ISoapFault *)\n\t\t\tm_pCall->checkFault(\"Fault\",\""
                + wscontext.getWrapInfo().getTargetEndpointURI() + "\");\n\n");
        writer.write("\t\tif(pSoapFault)\n");
        writer.write("\t\t{\n");
        //writer.write("\t\t\tpcCmplxFaultName =
        // pSoapFault->getCmplxFaultObjectName();\n");
        //to get fault info
        Iterator paramsFault = minfo.getFaultType().iterator();
        String faultInfoName = null;
        String faultType = null;
        String langName = null;
        String paramName = null;
        boolean flag = false;
        int j = 0;
        if (!paramsFault.hasNext())
        {
            writer.write("\t\t\tconst char *detail = pSoapFault->getSimpleFaultDetail();\n");
            writer.write("\t\t\tbool deleteDetail=false;\n\n");
            writer.write("\t\t\tif (NULL==detail || 0==strlen(detail))\n");
            writer.write("\t\t\t{\n");
            writer.write("\t\t\t\tdetail=m_pCall->getFaultAsXMLString();\n");
            writer.write("\t\t\t\tif (NULL==detail)\n");
            writer.write("\t\t\t\t{\n");
            writer.write("\t\t\t\t\tdetail=\"\";\n");
            writer.write("\t\t\t\t}\n");
            writer.write("\t\t\t\telse\n");
            writer.write("\t\t\t\t{\n");
            writer.write("\t\t\t\t\tdeleteDetail=true;\n");
            writer.write("\t\t\t\t}\n");
            writer.write("\t\t\t}\n\n");
            writer.write("\t\t\tOtherFaultException ofe(pSoapFault->getFaultcode(),\n");
            writer.write("\t\t\t\tpSoapFault->getFaultstring(), pSoapFault->getFaultactor(),\n");
            writer.write("\t\t\t\tdetail, iExceptionCode);\n\n");
            writer.write("\t\t\tif (deleteDetail && NULL!=detail)\n");
            writer.write("\t\t\t{\n");
            writer.write("\t\t\t\tAxis::AxisDelete( (void *) const_cast<char*>(detail), XSD_STRING);\n");
            writer.write("\t\t\t}\n\n");
            writer.write("\t\t\tm_pCall->unInitialize();\n");
            writer.write("\t\t\tdelete pSoapFault;\n");
            writer.write("\t\t\tthrow ofe;\n");
        }
        else
        {
            flag = true;
            writer
                    .write("\t\t\tpcCmplxFaultName = pSoapFault->getCmplxFaultObjectName();\n");
        }
        while (paramsFault.hasNext())
        {
            j = j + 1;
            FaultInfo info = (FaultInfo) paramsFault.next();
            faultInfoName = info.getFaultInfo();
            ArrayList paramInfo = info.getParams();
            for (int i = 0; i < paramInfo.size(); i++)
            {
                ParameterInfo par = (ParameterInfo) paramInfo.get(i);
                paramName = par.getParamName();
                langName = par.getLangName();
                faultType = WrapperUtils
                        .getClassNameFromParamInfoConsideringArrays(par,
                                wscontext);
                if (j > 1)
                {
                    writer.write("\t\t\telse if");
                    writeExceptions(faultType, faultInfoName, paramName,
                            langName);
                }
                else
                {
                    writer.write("\t\t\tif");
                    writeExceptions(faultType, faultInfoName, paramName,
                            langName);
                }
            }
        }

        if (flag == true)
        {
            writer.write("\t\t\telse\n");
            writer.write("\t\t\t{\n");
            writer.write("\t\t\t\tconst char *detail = pSoapFault->getSimpleFaultDetail();\n");
            writer.write("\t\t\t\tbool deleteDetail=false;\n\n");
            writer.write("\t\t\t\tif (NULL==detail || 0==strlen(detail))\n");
            writer.write("\t\t\t\t{\n");
            writer.write("\t\t\t\t\tdetail=m_pCall->getFaultAsXMLString();\n");
            writer.write("\t\t\t\t\tif (NULL==detail)\n");
            writer.write("\t\t\t\t\t{\n");
            writer.write("\t\t\t\t\t\tdetail=\"\";\n");
            writer.write("\t\t\t\t\t}\n");
            writer.write("\t\t\t\t\telse\n");
            writer.write("\t\t\t\t\t{\n");
            writer.write("\t\t\t\t\t\tdeleteDetail=true;\n");
            writer.write("\t\t\t\t\t}\n");
            writer.write("\t\t\t\t}\n\n");
            writer.write("\t\t\t\tOtherFaultException ofe(pSoapFault->getFaultcode(),\n");
            writer.write("\t\t\t\t\tpSoapFault->getFaultstring(), pSoapFault->getFaultactor(),\n");
            writer.write("\t\t\t\t\tdetail, iExceptionCode);\n\n");
            writer.write("\t\t\t\tif (deleteDetail && NULL!=detail)\n");
            writer.write("\t\t\t\t{\n");
            writer.write("\t\t\t\t\tAxis::AxisDelete( (void *) const_cast<char*>(detail), XSD_STRING);\n");
            writer.write("\t\t\t\t}\n\n");
            writer.write("\t\t\t\tm_pCall->unInitialize();\n");
            writer.write("\t\t\t\tdelete pSoapFault;\n");
            writer.write("\t\t\t\tthrow ofe;\n");
            writer.write("\t\t\t}\n");
        }

        writer.write("\t\t}\n");
        writer.write("\t\telse\n");
        writer.write("\t\t{\n");
        writer.write("\t\t\tm_pCall->unInitialize();\n");
        writer.write("\t\t\tdelete pSoapFault;\n");
        writer.write("\t\t\tthrow;\n");
        writer.write("\t\t}\n");
        writer.write("\t}\n");
        writer.write("}\n");
    }

    private void writeExceptions(String faulttype, String faultInfoName,
            String paramName, String langName) throws WrapperFault
    {
        try
        {
            writer.write("(0 == strcmp(\"" + faultInfoName
                    + "\", pcCmplxFaultName))\n");
            writer.write("\t\t\t{\n");
            writer.write("\t\t\t\t" + faulttype + " pFaultDetail = \n");
            writer.write("\t\t\t\t\t(" + faulttype
                    + ")pSoapFault->getCmplxFaultObject(\n");
            writer.write("\t\t\t\t\t\t(void*) Axis_DeSerialize_" + langName
                    + ",\n");
            writer.write("\t\t\t\t\t\t(void*) Axis_Create_" + langName + ",\n");
            writer.write("\t\t\t\t\t\t(void*) Axis_Delete_" + langName + ",\n");
            writer.write("\t\t\t\t\t\t\"" + faultInfoName + "\",\n");
            writer.write("\t\t\t\t\t\t0);\n\n");
            writer.write("\t\t\t\tpFaultDetail->setFaultCode(pSoapFault->getFaultcode());\n");
            writer.write("\t\t\t\tpFaultDetail->setFaultString(pSoapFault->getFaultstring());\n");
            writer.write("\t\t\t\tpFaultDetail->setFaultActor(pSoapFault->getFaultactor());\n");
            writer.write("\t\t\t\tpFaultDetail->setExceptionCode(e.getExceptionCode());\n");
            writer.write("\t\t\t\tm_pCall->unInitialize();\n");
            writer.write("\t\t\t\tthrow *pFaultDetail;\n");
            writer.write("\t\t\t}\n");
        } 
        catch (IOException e)
        {
            throw new WrapperFault(e);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.axis.wsdl.wsdl2ws.cpp.CPPClassWriter#writeGlobalCodes()
     */
    protected void writeGlobalCodes() throws WrapperFault
    {

    }
}
